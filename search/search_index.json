{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome","text":"<ul> <li> <p> Get started</p> <ul> <li> <p>Visual Studio Code setup</p> </li> <li> <p>Intro to VoltScript tutorial</p> </li> <li> <p>Write code</p> </li> <li> <p>Run code</p> </li> </ul> </li> <li> <p> What's New?</p> <p>Find out what's new in the latest VoltScript release.</p> <p> Go to What's New</p> </li> <li> <p> Tutorials</p> <p>Hands-on introduction to VoltScript.</p> <p> Go to Tutorials</p> </li> <li> <p> How-to guides</p> <p>Practical step-by-step guides for performing tasks and operation.</p> <p> Go to How-to guides</p> <p> Go to Videos</p> </li> <li> <p> Topic guides</p> <p>High-level discussion and explanation of key topics and concepts to give background information.</p> <p> Go to Topic guides</p> </li> <li> <p> References</p> <p>Technical references and descriptions on using VoltScript.</p> <p> Go to References</p> </li> <li> <p> Quick links</p> <ul> <li> <p>VoltScript Components</p> </li> <li> <p>VoltScript Extensions</p> </li> <li> <p>VoltScript Library Modules</p> </li> <li> <p>HCL Volt MX Go Documentation</p> </li> <li> <p>Documentation and source code references</p> </li> </ul> </li> </ul>"},{"location":"blog/posts/welcome.html","title":"Welcome","text":"<p>Welcome to the new VoltScript documentation</p>"},{"location":"howto/index.html","title":"How-to guides","text":"<p>How-to guides instruct users in completing key goals and tasks related to VoltScript.</p> <ul> <li>Write code</li> <li>Run code</li> <li>Volt Foundry</li> <li>Share code</li> <li>Core language</li> <li>VoltScript Extensions</li> <li>VoltScript Library Modules</li> <li>Videos</li> </ul>"},{"location":"howto/libraries.html","title":"VoltScript Library Modules","text":"<p>VoltScript Libraries are .vss files with provided classes, subs, and functions for use in main and test scripts. They shouldn't have a <code>Sub Initialize</code>.</p> <p>For documentation on HCL-developed VoltScript Libraries, see:</p> <ul> <li> <p>VoltScript Testing provides classes for unit-/integration-testing and validation. </p> <ul> <li>Source Code </li> <li>How-to guides</li> </ul> </li> <li> <p>VoltScript JSON Converter provides classes for configured deserialization / serialization of JSON.</p> <ul> <li>Source Code</li> <li>How-to guides</li> </ul> </li> <li> <p>VoltScript Collections provides Collection, Map and Pair classes. </p> <ul> <li>Source Code</li> <li>How-to guides</li> </ul> </li> <li> <p>VoltScript Console Colors provides constants for changing the console colors when printing to a terminal that supports this functionality. </p> <ul> <li>Source Code</li> </ul> </li> </ul> <p>Within this documentation, you can access aggregated API Docs.</p>"},{"location":"howto/libraries.html#dependency-management","title":"Dependency management","text":"<p>Dependency management is available in the documentation for each project, but also aggregated in references.</p>"},{"location":"howto/archipelago/index.html","title":"Use VoltScript Build Manager","text":"<p>Info</p> <p>To get the JSON for existing VoltScript Extensions and Library Modules via dependency management, see the relevant repository or, for HCL-developed code, see the extension references or library module references.</p> <p>This is delivered as a command line tool called \"VoltScript_Archipelago\" and a subdirectory called \"archipelago\". The functions available are:</p> <ul> <li>VoltScript_Archipelago setup checks for existence of <code>.vss</code> directory in the user's directory and creates it, if necessary.</li> <li>VoltScript_Archipelago installDeps prompts for parameters, builds project directories, and adds dependencies.</li> <li>VoltScript_Archipelago listdeps prompts for parameters and lists the dependencies that will get loaded.</li> <li>VoltScript_Archipelago foundrypack prompts for parameters and builds a zip to upload to Foundry.</li> </ul>"},{"location":"howto/archipelago/index.html#vs-code-extension","title":"VS Code Extension","text":"<p>There is a separate VS Code Extension called VoltScript Build Manager. This provides Command Palette commands for \"VoltScript: Run Dependency Setup\", which calls <code>VoltScript_Archipelago setup</code>, and \"VoltScript: Install Dependencies\", which calls <code>VoltScript_Archipelago installDeps</code>.</p> <p>The setup runs automatically, if there is an <code>atlas.json</code> file in the workspace. It also provides JSON validation for <code>atlas.json</code> and <code>atlas-settings.json</code> files, as well as code snippets for both.</p> <p></p> <p>If an <code>atlas.json</code> file is open, installing dependencies can also be done via the download icon added to the top of the editor.</p> <p></p>"},{"location":"howto/archipelago/index.html#required-files","title":"Required files","text":"<p>Dependency management requires two files:</p> <ul> <li>an atlas-settings.json file which is expected to be in the .vss directory of your user home directory.</li> <li>an atlas.json file which will be in your project.</li> </ul> <p>For more details about setup, read the how to documentation for atlas-settings.json and constructing and building atlas.json.</p> <p>Once you have your atlas-settings.json and atlas.json set up, you're ready to run dependency management.</p>"},{"location":"howto/archipelago/atlas.html","title":"atlas.json","text":"<p>The <code>atlas.json</code> file is used to define a project's metadata as well as dependencies and the repositories in which they reside. It's intended to be included in source control for the project so it does not include any credentials for accessing repositories. For more details, see How to Structure an atlas.json. For dependency management, it's only important to reference certain elements in <code>atlas.json</code>:</p> <ul> <li>repositories: an array of repository objects. The repository contains three properties:<ul> <li>id: used to cross-reference with the atlas-settings.json.</li> <li>type: currently only \"github\" and \"webserver\" are supported.</li> <li>url: base URL for API calls to the repository. See below for more details how this is used.</li> </ul> </li> <li>dependencies: an array of dependency objects mapping to VoltScript files to use. The dependency contains three properties:<ul> <li>library: the group under which the .vss files and their own atlas.json are grouped.</li> <li>version: an explicit version number mapping to a release, or \"latest\" to also retrieve the most recent.</li> <li>module: the specific file to be incorporated.</li> <li>repository: an optional property mapping to a repository ID. If used, Archipelago will look in that repository first.</li> </ul> </li> <li>vseDependencies: an object of extension dependency objects mapping to extensions to use. The extension dependency is a JSON object whose label is the name you intend to use in the <code>UseVSE</code> statement, and which has three properties:<ul> <li>library: the group under which the VoltScript Extension(s) are grouped. For Volt MX Marketplace, this is the title of the asset as found in the breadcrumbs when manually navigating to the extension on Volt MX Marketplace. For HCL extensions, this will be the VSE name followed by \" VoltScript Extension\", e.g. \"JsonVSE VoltScript Extension\".</li> <li>version: a human-readable version number mapping to the asset version, e.g. \"1.0.1\". \"latest\" is not relevant for Volt MX Marketplace.</li> <li>module: the specific file to be downloaded. For Volt MX Marketplace, this is the VSE name in lowercase, e.g. \"jsonvse\". NOTE: This will no longer change with every release.</li> <li>repository: an optional property mapping to a repository ID. If used, Archipelago will look in that repository first.</li> </ul> </li> <li>sourceDir: the directory name, relative to the root of the project, in which to store VoltScript files for main execution.</li> <li>testDir: the directory name, relative to the root of the project, in which to store VoltScript files for running unit and integration tests.</li> <li>vsesDir: the directory name, relative to the root of the project, in which to store VoltScript Extensions. If omitted, extensions are put in the root of the project.</li> <li>libsDir: the directory name, relative to the root of the project, in which to store the VoltScript Library dependencies. If omitted, the VoltScript files are put in the root of the project.</li> <li>mainScripts: an array of files that are main runnable scripts.</li> <li>unitTestScript: an array of files that are unit test runnable scripts.</li> <li>integrationTestScripts: an array of files that are integration test runnable scripts.</li> <li>runtimePlatforms: an array of platforms for which to add VSEs to your project.</li> </ul> <p>Note</p> <p>A starter atlas.json with all options annotated can be accessed by typing <code>atlas</code> in an atlas.json. A starter atlas.json specific to Volt Foundry development can be accessed by typing <code>foundry-atlas</code> in an atlas.json. For more details, see Volt Foundry atlas.json. If you are comfortablke structuring your atlas.json, you can create uncommented minimal starters with <code>minimal-atlas</code> or <code>minimal-foundry-atlas</code>.</p>"},{"location":"howto/archipelago/atlas.html#vse-extensions","title":"VSE Extensions","text":"<p>The library is the asset title, e.g. \"JsonVSE VoltScript Extension\". The module is the asset filename when downloaded, minus the file suffix, e.g. \"jsonvse\". The Volt MX Marketplace repository URL is \"https://community.demo-hclvoltmx.com/marketplace\".</p> <p>Info</p> <p>By default, VSE files for all platforms (Windows, Linux, MacOS) will be copied into the project. You can use <code>runtimePlatforms</code> property to restrict which platforms' VSEs are copied in. For more details, see How to Structure an atlas.json.</p>"},{"location":"howto/archipelago/atlas.html#vss-directory","title":".vss Directory","text":"<p>Dependencies will be stored centrally in a <code>.vss</code> directory in the user's directory. This automatically gets created by the VS Code extension. They are divided into a subdirectory for the library, a subdirectory for the version, and the relevant module files. If the version is \"latest\", they are also copied to a sub-directory with the actual version number. So for VoltScript Testing Framework, this might be:</p> <p>.vss \u00a0\u00a0\u00a0\u00a0voltscript-testing \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0latest \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0VoltScriptTesting.vss \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0version.txt \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0.0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0VoltScvriptTesting.vss</p> <p>For Volt MX Marketplace, the module downloads a specific version. There is no option for \"latest\". It downloads a main zip and extracts as platform-specific zips. For the jsonvse example earlier, the directory structure would be:</p> <p>.vss \u00a0\u00a0\u00a0\u00a0JsonVSE VoltScript Extension \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0.0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0JsonVSE.zip \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0JsonVSE-windows-amd64.zip \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jsonvse-linux-x86_64.zip \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jsonvse-darwin-arm64.zip</p> <p>These directories are used to avoid downloading dependencies from the internet every time.</p>"},{"location":"howto/archipelago/running.html","title":"Running functions","text":""},{"location":"howto/archipelago/running.html#installing-dependencies","title":"Installing dependencies","text":"<p>Running dependency management is done using <code>VoltScript_Archipelago installDeps</code>, the Visual Studio Code command \"VoltScript: Install Dependencies\" or the icon at the top of the atlas.json's editor. It prompts for four parameters:</p> <ul> <li>root directory of the project to add dependencies to</li> <li>location of the <code>atlas-settings.json</code></li> <li>location of <code>atlas.json</code> to run against, which typically is in the root of the project, but could be elsewhere</li> <li> <p>true/false to force download from remote repositories</p> <p>If false, dependencies will be copied from local <code>.vss</code> directory, if available. If true, the relevant dependencies in the <code>.vss</code> directory will be re-downloaded.</p> </li> </ul> <p>Dependency management will:</p> <ul> <li>Check for and, if required, create the <code>.vss</code> directory.</li> <li>Create directories for sourceDir, testDir, libsDir and vsesDir properties.</li> <li>If not found locally or force is set to <code>true</code>, download VoltScript module dependencies in dependencies and their <code>atlas.json</code> files, if they exist, to the relevant file structure under the user's <code>.vss</code> directory.</li> <li>If not found locally or force is set to <code>true</code>, download VoltScript extensions in VSEDependencies to the relevant file structure under the user's <code>.vss</code> directory.</li> <li>If not found locally or force is set to <code>true</code>, download any required downstream dependencies.</li> <li>Copy the dependencies to the relevant libsDir or vsesDir.<ul> <li>If runtimePlatforms is defined, only the VSE files for the relevant platforms will be copied into vsesDir.</li> </ul> </li> <li> <p>If <code>seti.ini</code> does not exist or force is set to <code>true</code>, a <code>seti.ini</code> will be created for any VoltScript extensions.</p> <p>Note</p> <p>If you add new VoltScript Extensions, delete the <code>seti.ini</code> before running dependency management or run with force as <code>true</code> to automatically update the <code>seti.ini</code>.</p> </li> <li> <p>If no libsDir is set, sync between sourceDir and testDir, any <code>.vss</code> files not included in mainScripts, unitTestScript and integrationTestScripts. However, best practice is to put shared <code>.vss</code> libraries into the libsDir.</p> </li> <li> <p>Create an effective-atlas.json with verbose details of actual versions, actual locations, and actual repositories used. This can be used to troubleshoot unexpected behavior.</p> <p>Note</p> <p>effective-atlas.json should be excluded in your .gitignore.</p> </li> </ul> <p>Troubleshooting</p> <p>If the VoltScript Dependency Manager fails, review the information printed to the console. An atlas-settings.json will be required for dependencies pulled from GitHub or from a web server that requires authentication. The dependencies will be downloaded to the .vss directory in the user's home before being copied to the project. If using a dev container, this will be the user's home in the container.</p>"},{"location":"howto/archipelago/running.html#list-dependencies","title":"List dependencies","text":"<p>Listing dependencies performs similar to running dependency management, but doesn't add anything to the project. It can be done to understand where dependencies come from and version conflicts. It is done using <code>VoltScript_Archipelago listDeps</code> or the Visual Studio Code command \"VoltScript: List Dependencies\". It prompts for four parameters:</p> <ul> <li>root directory of the project to add dependencies to</li> <li>location of the <code>atlas-settings.json</code></li> <li>location of <code>atlas.json</code> to run against, which typically is in the root of the project, but could be elsewhere</li> </ul> <p>Listing dependencies will:</p> <ul> <li>Identifies VoltScript module dependencies in dependencies and their <code>atlas.json</code> files.</li> <li>If not found locally, download VoltScript libraries in dependencies and their atlas.json files to the relevant file structure under the user's <code>.vss</code> directory.</li> <li>If not found locally, download any required downstream dependencies.</li> <li>Print out dependencies and their versions.</li> </ul>"},{"location":"howto/archipelago/running.html#package-for-volt-foundry","title":"Package for Volt Foundry","text":"<p>If you are deploying an integration service to Volt Foundry, you can package up the code with the build management extension. For more details see Package for Volt Foundry.</p>"},{"location":"howto/archipelago/settings.html","title":"atlas-settings.json","text":"<p>The <code>atlas-settings.json</code> should be in the <code>.vss</code> directory and contains a JSON object of repositories and the credentials to use. If the credentials begin with <code>${env</code> and end with <code>}</code>, VoltScript Build Manager  retrieves the value from the relevant environment variable. For example, \"${env.TOKEN}\" would tell the code to retrieve an environment variable called TOKEN.</p> <p>Each repository element has a label, which matches what's defined in the <code>atlas.json</code>. It has a type, either \"github\", \"webserver\" or \"marketplace.</p> <p>Tip</p> <p>If this is your first time building a VoltScript project with an atlas.json on this device, you may need to run <code>VoltScript_Archipelago setup</code> or use the Visual Studio Code command \"VoltScript: Run Dependency Setup\" from an atlas.json to create your <code>.vss</code> directory.</p>"},{"location":"howto/archipelago/settings.html#github-personal-access-token","title":"GitHub Personal Access Token","text":"<p>If the type is \"github\", it should also include \"token\". Follow GitHub's documentation for creating a GitHub Person Access Token. The value will begin \"ghp_\". This is required for API access, regardless of whether the GitHub repository is private or public.</p> <p>If you are connecting to a GitHub Enterprise instance specific for your organization, check the relevant GitHub documentation. Fine-grained Personal Access Tokens may not be available, depending on version installed.</p> <p>Tip</p> <p>The minimum permissions required are:</p> Token Type Purpose Access Setting Tokens (classic) If you need to download releases from public repos only public_repo Tokens (classic) If you need to download from private or public repos repo Fine-grained tokens If you need to download releases from public repos only Public Repositories (read-only) Fine-grained tokens If you need to download releases from public and private repos Repository permissions &gt; Contents &gt; Access: Read-only"},{"location":"howto/archipelago/settings.html#web-server-credentials","title":"Web server credentials","text":"<p>If the type is \"webserver\" and requires authentication, it should also include \"credentials\", which maps to Base64 basic auth credentials. This is a Base64-encoded string of the username + \":\" + password. \"Basic \" will be automatically prepended by Archipelago when passing the credentials.</p> <p>If the web server doesn't require authentication, the credentials aren't needed or should be an empty string.</p>"},{"location":"howto/archipelago/settings.html#volt-mx-marketplace-credentials","title":"Volt MX Marketplace credentials","text":"<p>If the type is \"marketplace\", it should include \"username\", \"password\" and \"authUrl\". The authUrl for the main Volt MX Marketplace is \"https://accounts.auth.demo-hclvoltmx.net/login\".</p> <p>You will need a login for the Volt MX Marketplace. Make sure you've tested successfully logging into the web interface before using it for dependency management.</p> <p>Note</p> <p>You will be prompted to change your password periodically. Make sure you do so, or your account will expire.</p>"},{"location":"howto/archipelago/settings.html#sample","title":"Sample","text":"<p>A sample atlas-settings file sould look something like this:</p> <pre><code>{\n    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    },\n    \"my-web-server\": {\n        \"type\": \"webserver\",\n        \"credentials\": \"${env.CRED}\"\n    },\n    \"volt-mx-marketplace\": {\n        \"type\": \"marketplace\",\n        \"username\": \"${env.USERNAME}\",\n        \"password\": \"${env.PASSWORD}\",\n        \"authUrl\": \"https://accounts.auth.demo-hclvoltmx.net/login\"\n    }\n}\n</code></pre> <p>Tip</p> <p>There are two snippets available:</p> <pre><code>- A complete commented sample, with two JSON objects each for \"github\", \"webserver\", and \"marketplace\". For each repository type, one sample shows using explicit credentials and the other shows using environment variables.\n- A minimal sample, without comments and with JSON objects for \"github\" and \"marketplace\".\n</code></pre> <p>When you are comfortable with the syntax and values for the atlas-settings.json, you can use the second sample to keep your atlas-settings.json clean.</p>"},{"location":"howto/extensions/index.html","title":"VoltScript Extensions","text":"<p>This section covers how-to queries about VoltScript extensions.</p> <ul> <li>Generate a new VoltScript Extension with VoltScript Interface Designer</li> <li>Receive input</li> <li>Access platform and environment variables</li> <li>Find files and managing directories</li> <li>Read and write files</li> <li>Build JSON</li> <li>JSON parsing</li> <li>Build XML</li> <li>XML Parsing</li> <li>Make HTTP REST JSON Requests</li> <li>Process ISO 8601 and other dates</li> <li>Download files</li> <li>Process zip files</li> <li>Encode and hash content</li> <li>AES encryption</li> <li>Make Requests to Domino REST API</li> <li>Make Requests to CouchDB</li> </ul>"},{"location":"howto/extensions/index.html#dependency-management","title":"Dependency management","text":"<p>Dependency management is available in the documentation for each project, but also aggregated in references.</p>"},{"location":"howto/extensions/buildingjson.html","title":"Build JSON","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/buildingjson.html#introduction","title":"Introduction","text":"<p>JSON can be constructed manually as a string. But this is an onerous and accident-prone way of generating output. JsonVSE was designed to improve the developer experience for both reading and writing JSON. In this tutorial, we will focus on writing JSON.</p>"},{"location":"howto/extensions/buildingjson.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating JsonVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>\"JsonVSE\": {\n    \"library\": \"JsonVSE VoltScript Extension\",\n    \"version\": \"1.0.4\",\n    \"module\": \"jsonvse\",\n    \"repository\":\"volt-mx-marketplace\"\n}\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*JsonVSE\"</code>.</p>"},{"location":"howto/extensions/buildingjson.html#jsonobject-class","title":"JsonObject class","text":""},{"location":"howto/extensions/buildingjson.html#construct-json-objects-and-arrays","title":"Construct JSON objects and arrays","text":"<p>The JsonObject class is used for both JSON objects and JSON arrays. The JsonObject class can be instantiated without an argument, using just <code>Dim jsonObj as New JsonObject()</code>. If done this way, the object created can be used for JSON objects or arrays.</p> <pre><code>Function buildJsonObj() as JsonObject\n    Dim jsonObj as New JsonObject(False)\n\n    Call jsonObj.insertValue(\"String\", \"One\")\n    Call jsonObj.insertValue(\"Number\", 2)\n\n    Return jsonObj\nEnd Function</code></pre> <p>If intended just as a JSON object, use <code>new JsonObject(False)</code>. The method <code>insertValue()</code> is used to build a JSON object. The first parameter is the label, the second parameter is the value.</p> <pre><code>Function buildJsonArr() as JsonObject\n    Dim jsonArr as New JsonObject(True)\n\n    Call jsonArr.appendToJsonArray(\"One\")\n    Call jsonArr.appendToJsonArray(\"Two\")\n    Call jsonArr.appendToJsonArray(2)\n\n    Return jsonArr\nEnd Function</code></pre> <p>If the instance should only be a JSON array, best practice is to instantiate it with the argument <code>True</code>. When instantiated this way, the resulting object can only be used to add array elements - using <code>insertValue()</code> will throw an error.</p> <p>The method <code>appendToJsonArray()</code> is used to build a JSON array. Because the JSON array only contains values, there is only one parameter to pass. Because a JSON array can contain mixed value types, subsequent calls to <code>appendToJsonArray()</code> don't need to pass the same parameter type.</p>"},{"location":"howto/extensions/buildingjson.html#fluent-methods","title":"Fluent Methods","text":"<p>Methods for inserting values and appending arrays are fluent. So method calls can be chained for shorter code:</p> <pre><code>    Set jsonObj = new JsonObject(False)\n    Call testSuite.describe(\"Test fluent method on object building\")\n    Call jsonObj.insertValue(\"key1\", \"one\").insertValue(\"key2\", \"two\")\n    Call testSuite.assertEqualsInteger(2, jsonObj.childCount)\n    Set jsonObj = new JsonObject(True)\n    Call testSuite.describe(\"Test fluent method on array building\")\n    Call jsonObj.appendToJsonArray(\"one\").appendToJsonArray(\"two\")\n    Call testSuite.assertEqualsInteger(2, jsonObj.childCount)</code></pre>"},{"location":"howto/extensions/buildingjson.html#add-arrays-to-existing-jsonobject","title":"Add arrays to existing JsonObject","text":"<p>An array can be passed into a JsonObject in two ways. The first is by constructing a VoltScript array and calling the <code>insertValue()</code> method.</p> <pre><code>Sub addVSArrToObj(jsonObj as JsonObject)\n    Dim vals(1) as String\n    vals(0) = \"Hello\"\n    vals(1) = \"World\"\n\n    Call jsonObj.insertValue(\"StringArray\", vals)\nEnd Function</code></pre> <p>Alternatively, a JsonObject that's an array can be loaded, calling either <code>insertValue()</code> or <code>insertObject()</code> methods. If using <code>insertValue()</code>, you need to pass the label as a parameter. The <code>label</code> property of the JsonObject will be ignored. If using <code>insertObject()</code>, the <code>label</code> property of the JsonObject can be leveraged or the label explicitly passed as a parameter.</p> <pre><code>Sub addJsonArrToObject(jsonObj as JsonObject, jsonArr as JsonObject)\n    Call jsonObj.insertValue(\"JSONArray\", jsonArr)\n\n    Call jsonObj.insertObject(jsonArr, \"ObjectArray\") ' (1)\n    jsonArr.label = \"ArrayLabel\"\n    Call jsonObj.insertObject(jsonArr) ' (2)\nEnd Function</code></pre> <ol> <li>\"ObjectArray\" label is used, regardless of the label of the <code>jsonArr</code> object.</li> <li><code>jsonArr.label</code> is used as the label.</li> </ol>"},{"location":"howto/extensions/buildingjson.html#add-jsonobjects-to-a-jsonobject","title":"Add JsonObjects to a JsonObject","text":"<p>A JsonObject can  be loaded calling either <code>insertValue()</code> or <code>insertObject()</code> methods. If using <code>insertValue()</code>, you need to pass the label as a parameter. The <code>label</code> property of the JsonObject will be ignored. If using <code>insertObject()</code>, the <code>label</code> property of the JsonObject can be leveraged or the label explicitly passed as a parameter.</p> <pre><code>Sub addJsonObj(jsonObj as JsonObject)\n    Dim childObj as New JsonObject\n    Call childObj.insertValue(\"hello\",\"world\")\n\n    Call jsonObj.insertValue(\"child1\", childObj)\n    Call jsonObj.insertObject(childObj, \"child2\")\n\n    childObj.label = \"child3\"\n    Call jsonObj.insertObject(childObj)\nEnd Function</code></pre>"},{"location":"howto/extensions/buildingjson.html#by-value-addition","title":"\"By Value\" addition","text":"<p>JsonObjects and JsonArrays loaded by <code>insertValue()</code> or <code>insertObject()</code> are passed by value, not by reference. This means the contents are deep-copied into the new parent. As a result, subsequent changes to the child won't be reflected in the parent.</p> <pre><code>Function modifyChild() as JsonObject\n    Dim parent as JsonObject\n    Dim childObj as JsonObject\n    Call childObj.insertValue(\"elem1\", \"hello world\")\n    childObj.label = \"child\"\n\n    Call parent.insertObject(childObj)\n    Call childObj.insertValue(\"elem2\", 2)\n    Print parent.toString(false) ' (1)\n    Return parent\nEnd Function</code></pre> <ol> <li>This code will print <code>{\"child\":{\"elem1\":\"hello world\"}}</code> because \"elem2\" was added to the child JsonObject after it was copied into the parent.</li> </ol>"},{"location":"howto/extensions/buildingjson.html#removing-elements","title":"Removing elements","text":"<p>Elements can be removed from JsonObjects using the relevant method - <code>removeArrayEntry()</code> for JsonObjects that are arrays and <code>removeChild()</code> for JsonObjects that are not. NOTE: <code>removeChild()</code> will throw an error if used on JsonObjects that are arrays.</p> <pre><code>    Call testSuite.describe(\"Test removeArrayEntry\")\n    Call jsonObj.removeArrayEntry(0)\n    Call testSuite.assertEqualsInteger(1, jsonObj.childCount)\n    Call testSuite.assertEqualsString(\"two\", jsonObj.getChildren()(0).scalarValue, True)\n\n    Set jsonObj = new JsonObject(False)\n    Call jsonObj.insertValue(\"key1\", \"one\").insertValue(\"key2\", \"two\")\n    Call jsonObj.removeChild(\"key1\")\n    Call testSuite.assertEqualsInteger(1, jsonObj.childCount)\n    Call testSuite.assertEqualsString(\"two\", jsonObj.getChildren()(0).scalarValue, True)</code></pre>"},{"location":"howto/extensions/buildingjson.html#return-json","title":"Return JSON","text":"<p>We use <code>toString(false)</code> to return a string of compact JSON.</p> <pre><code>Print parent.toString(false)</code></pre> <p>This will print <code>{\"child\":{\"elem1\":\"hello world\"}}</code>.</p> <p>Use <code>toString(true)</code> to return a string of JSON pretty-printed.</p> <pre><code>Print parent.toString(true)</code></pre> <p>This will print:</p> <pre><code>{\n    \"child\": {\n        \"elem1\": \"hello world\"\n    }\n}\n</code></pre> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/couch.html","title":"Make Requests to Couch","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/couch.html#introduction","title":"Introduction","text":"<p>CouchVSE provides the ability to make REST service calls to CouchDb.</p> <p>Preview Only</p> <p>The schema for CouchVSE has been set up to include design operations. But the version for Early Access is available as preview only. Not all functions may have been implemented, basic CRUD is the main focus. Some functions, for example creating views, will have to be performed via Fauxton, the web interface. Advanced concepts - for example agents, and ACLs - will not be available.</p>"},{"location":"howto/extensions/couch.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating CouchVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"CouchVSE\": {\n            \"library\": \"CouchVSE VoltScript Extension\",\n            \"version\": \"1.0.3\",\n            \"module\": \"couchvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*CouchVSE\"</code>.</p>"},{"location":"howto/extensions/couch.html#couchserver-class","title":"CouchServer class","text":"<p>The <code>Couchserver</code> clas sis the entrypoint for any CouchDb calls. You need to specify the serverUrl, which is the protocol + server name.</p> <p>After adding the <code>serverURL</code> you'll need to call <code>login()</code> passing a username and password. The following code will login to the server, assuming the variables <code>serverName</code>, <code>userName</code> and <code>password</code> have been set.</p> <pre><code>Function loginCouchDbServer(server As CouchServer, user As String, password As String, url As String, certificatepath As String) As Boolean \n\n    Set server = new CouchServer() \n\n    server.User = user\n    server.Password = password\n    server.URL = url\n\n    If (Len(FullTrim(certificatepath)) &gt; 0) Then\n        'Only set certificate path if not blank\n        server.CertificatePath = certificatepath\n    End If\n\n    Call server.Login()\n\n    return True \nEnd Function</code></pre> <p>Info</p> <p>To use HTTPS, the web-based extensions expect a properly verifiable SSL certificate. For well-known sites, these may be loaded by your operating system.</p> <p>In the above code, <code>CouchServer.certificatePath</code> property is passed a path to a specific self-signed certificate. Alternatively, you can set <code>CouchServer.SSLHostValidationOn = False</code>. For more information, see Web SSL Certificate Handling.</p> <p>If the server is successfully connected to the CouchDB, you can check the CouchDB version with <code>CouchServer.CouchVersion</code>.</p> <p>The CouchDB server will have certain features available, and an array of these can be retrieved with <code>CouchServer.features</code>. The following code will print the features out, converting the :</p> <pre><code>Function getCouchDbFeatures(server As CouchServer) As Variant \n    Dim result As Variant \n    Dim i As Integer \n\n    result = server.Features\n    If IsArray(result) Then i = Ubound(result) + 1\n    Print \"There are \" &amp; i &amp; \" Features: \", join(result, |, |)\n\n    Return result \nEnd Function </code></pre>"},{"location":"howto/extensions/couch.html#couchdatabase-class","title":"CouchDatabase class","text":"<p>To interact with data on the CouchDB server, you'll need to get a database. <code>CouchServer.databaseNames</code> will give an array of the database names available for connection. Once you know the name, the following code will get or create the database:</p> <pre><code>Function getOrCreateCouchDbDatabase(server As CouchServer, dbName As String) As CouchDatabase \n    If server.IsDatabase(dbName) Then\n        return server.GetDb(dbName)\n    Else\n        Return server.CreateDb(dbName)\n    End If\nEnd Function</code></pre>"},{"location":"howto/extensions/couch.html#basic-crud-operations","title":"Basic CRUD operations","text":""},{"location":"howto/extensions/couch.html#create-document","title":"Create document","text":"<p>The <code>CouchDatabase.createDocument()</code> function does not update the CouchDB database, it merely creates an in-memory CouchDocument ready to be saved into the database. The following code can create a document and save it to the database:</p> <pre><code>Function createDocument(server as CouchServer, dbName as String) as CouchDocument\n\n    Dim db as CouchDatabase\n    Dim doc as CouchDocument\n\n    Set db = getOrCreateCouchDbDatabase(server, \"demo\")\n    Set doc = db.createDocument(\"\", |{\"firstName\":\"John\",\"lastName\":\"Doe\",\"email\":\"jdoe@acme.com\"}|)\n    Call doc.save()\n    Return doc\n\nEnd Function</code></pre> <p>Info</p> <p>It is possible to create a document with a specific ID, but it's best to allow CouchDB to set the ID itself.</p> <p>Once the document is saved, metadata, including the ID, will be populated.</p>"},{"location":"howto/extensions/couch.html#retrieval","title":"Retrieval","text":"<p>Retrieving a document is done using <code>CouchDatabase.getDocumentByID()</code>. This takes two parameters, the ID and whether to include documents deleted in CouchDB. If the document was deleted with <code>preserve</code> set to False or through some other means than CouchVSE, the returned document will only have minimal information, id and last revision code.</p> <p>Retrieving a document that doesn't exist will throw an error, so you'll need to wrap the retrieval code in either a <code>Try...catch</code> block or check <code>CouchDatabase.isDocument()</code> first. The following code shows the latter option:</p> <pre><code>Function getDocument(db as CouchDatabase, id as String) as CouchDocument\n\n    If db.isDocument(ID) Then Return db.GetDocumentByID(ID)\n\nEnd Function</code></pre>"},{"location":"howto/extensions/couch.html#update","title":"Update","text":"<p>CouchDB is a schemaless NoSQL database, so it allows any updates to any items in the document. It is the responsibility of the person posting data to ensure it will not cause issues with applications consuming that data downstream.</p> <p>Items can be added a scalar values or as nested JSON. The following code will retrieve and update a document, adding a \"Pet\" and a \"Color\" object that comprises a Name and a HexCode.</p> <pre><code>Function updateDocument(db as CouchDatabase, id as String) as CouchDocument\n\n    Dim doc as CouchDocument\n    If db.isDocument(ID) Then\n        Set doc = db.GetDocumentByID(ID)\n        Call doc.addItem(\"Pet\", \"Squirrel\")\n        Call doc.addItemToJsonObject(\"Name\", \"Color\", \"Blue\")\n        Call doc.addItemToJsonObject(\"HexCode\", \"Color\", \"0000FF\")\n        Call doc.save()\n        Return doc\n    End If\n\nEnd Function</code></pre>"},{"location":"howto/extensions/couch.html#deletion","title":"Deletion","text":"<p>Deletion can be done by passing an ID or a CouchDocument. When a document is deleted, it is removed from all queries, with a <code>{\"_deleted\":true}</code> item set.</p> <p>CouchVSE extends CouchDB deletion, by adding an easy \"soft deletion\" functionality. This is done with a second parameter on <code>CouchDatabase.deleteDocumentByID()</code> and <code>CouchDatabase.deleteDocument()</code>. If the parameter is set to false, the document will be deleted in the normal CouchDB way, all data on the tombstone stub will be removed. If the parameter is set to true, it will perform a \"soft deletion\", setting <code>_deleted</code> to remove it from all queries but retaining the data.</p> <p>The following code will delete a document in the normal CouchDB way:</p> <pre><code>Function deleteDocument(db as CouchDatabase, id as String) as Boolean\n\n    If db.isDocument(ID) Then\n        Return db.deleteDocumentByID(ID, False)\n    End If\n\nEnd Function</code></pre>"},{"location":"howto/extensions/couch.html#views","title":"Views","text":"<p>Info</p> <p>In EA1, views are expected to be created via the Fauxton web interface. For more information on creating views, see CouchDB Views documentation.</p> <p>The following code will get the first two entries in a view called \"names\":</p> <pre><code>Function getEntriesFromView(db as CouchDatabase) as String\n\n    Dim view as CouchView\n\n    Set view = db.getViewByID(\"names\")\n    Print view.getSomeRows(0, 2)\n\nEnd Function</code></pre>"},{"location":"howto/extensions/couch.html#attachments","title":"Attachments","text":""},{"location":"howto/extensions/couch.html#add-an-attachment","title":"Add an attachment","text":"<p>Attachments can be added to a CouchDocument once it has been saved. When uploading, the parent CouchDocument object is not automatically reacquired from the CouchDatabase to update the \"_attachments\" metadata. If you wish to retrieve the latest changes to the underlying CouchDocument, you will need to use <code>getDocumentByID()</code> again. The following code saves an attachment and reacquires the document:</p> <pre><code>Sub addAttachment(db as CouchDatabase, doc as CouchDocument, filePath as String)\n    Dim attach as CouchAttachment\n    Set attach = doc.createAttachment(\"attach\", filePath, \"text/plain\")\n    Call attach.upload\n\n    ' Need to re-acquire document to update CouchDocument fields\n    Set doc = db.GetDocumentByID(doc.ID, False)\nEnd Sub</code></pre>"},{"location":"howto/extensions/couch.html#download-an-attachment","title":"Download an attachment","text":"<p>The attachment can also be downloaded to a specified file location. The following code will perform this download:</p> <pre><code>Sub downloadAttachment(doc as CouchDocument, attachName as String, filePath as String)\n\n    Dim attach as CouchAttachment\n    Set attach = doc.getAttachmentInfo(attachName)\n    Call attach.download(filePath, True)\n    Call attach.upload\n\nEnd Sub</code></pre> <p>CouchDB stores an MD5 hash of the file in the document metadata. <code>CouchDocument.MD5Hash</code> provides access to this hash value, which can be used to verify the downloaded file if required. See Hash files for more information.</p>"},{"location":"howto/extensions/drapi.html","title":"Make Requests to Domino","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/drapi.html#introduction","title":"Introduction","text":"<p>When coding LotusScript, Domino access is expected and set up automatically via <code>NotesSession</code> object and specific user access automatically applied. VoltScript is middleware and may or may not require access to Domino data to perform its middleware functions. So the relevant VoltScript Extension, DrapiVSE, needs to be added, as for any other VoltScript extension. DrapiVSE allows you to easily work with the Domino Rest API, and the classes and methods it uses map to corresponding endpoints in the Domino Rest API.</p>"},{"location":"howto/extensions/drapi.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating DrapiVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"DrapiVSE\": {\n            \"library\": \"DrapiVSE VoltScript Extension\",\n            \"version\": \"1.0.0\",\n            \"module\": \"drapivse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*DrapiVSE\"</code>.</p> <p>You will probably also want to incorporate JsonVSE.</p>"},{"location":"howto/extensions/drapi.html#domino-rest-api","title":"Domino REST API","text":"<p>DrapiVSE is designed to access Domino REST API. The VoltScript Extension is only designed for data access, not database or user management. So only the data APIs are exposed in DrapiVSE. Of course, this doesn't preclude you making REST calls via WebVSE to other Domino REST API endpoints.</p> <p>Info</p> <p>This how-to guide assumes familiarity with Domino REST API terminology. For more information on the Domino REST API terminology, see the Domino REST API documentation</p> <p>It's important to bear in mind performance because the VoltScript code will be running as middleware, making individual REST service calls for most APIs. The following diagrams demonstrate REST service calls for creating a document and updating an existing document:</p>"},{"location":"howto/extensions/drapi.html#drapivse-and-domino-rest-api-create-document","title":"DrapiVSE and Domino REST API: Create Document","text":"<pre><code>sequenceDiagram\nparticipant DrapiVSE\nparticipant DRAPI as Domino REST API\nDrapiVSE -&gt;&gt; DRAPI: DrapiServer.login()\nDRAPI -&gt;&gt; DrapiVSE: Bearer token, server info, etc\nDrapiVSE -&gt;&gt; DrapiVSE: DrapiServer.createRequest(\"demo\")\nDrapiVSE -&gt;&gt; DrapiVSE: DrapiRequest.createDocument()\nDRAPI -&gt;&gt; DrapiVSE: DrapiResponse object or error\n</code></pre>"},{"location":"howto/extensions/drapi.html#drapivse-and-domino-rest-api-update-document","title":"DrapiVSE and Domino REST API: Update Document","text":"<pre><code>sequenceDiagram\nparticipant DrapiVSE\nparticipant DRAPI as Domino REST API\nDrapiVSE -&gt;&gt; DRAPI: DrapiServer.login()\nDRAPI -&gt;&gt; DrapiVSE: Bearer token, server info, etc\nDrapiVSE -&gt;&gt; DrapiVSE: DrapiServer.createRequest(\"demo\")\nDrapiVSE -&gt;&gt; DRAPI: DrapiRequest.putDocument() / &lt;br/&gt;DrapiRequest.patchDocument()\nDRAPI -&gt;&gt; DrapiVSE: DrapiResponse / DrapiDocument object or error</code></pre> <p>Tip</p> <p>A good understanding of Domino REST API is important to use DrapiVSE at its best. Coding using DrapiVSE in the same you would code using Notes classes will be difficult, as DrapiVSE closely corresponds with the DRAPI endpoints, and you will not get an optimal outcome. Think of it as working with a Rest API, not with the Domino API.</p>"},{"location":"howto/extensions/drapi.html#drapiserver-class","title":"DrapiServer class","text":"<p>The <code>DrapiServer</code> class is the entrypoint for any Domino REST API calls. You need to specify the <code>serverURL</code>, which is protocol + server name + \"api/v1\". This is the same URL that appears under \"Servers\" on the Swagger REST API:</p> <p></p> <p>After adding the <code>serverURL</code> you will need to call <code>login()</code> passing a username and password. The following code will login to the server, assuming the variables <code>serverName</code>, <code>userName</code> and <code>password</code> have been set.</p> <pre><code>Function login(server as DrapiServer, userName as String, password as String)\n    server.serverURL = SERVER_NAME\n    Call server.login(userName, password)\nEnd Function</code></pre> <p>This will give a logged in session to the Domino REST API as the passed user, which can be verified with <code>server.connected</code> or by retrieving the token with <code>server.JWTToken</code>.</p>"},{"location":"howto/extensions/drapi.html#passing-an-existing-token","title":"Passing an Existing Token","text":"<p>Best practice is to log in once and re-use a valid JWT token for subsequent requests, serialized by whatever is calling the VoltScript code. DrapiServer supports the ability to pass an existing token, <code>server.JWTToken</code> is read-write, not read-only, so can be set. When doing so, you do not need to run <code>Call server.login()</code> again, the valid token will just be passed with the relevant DrapiRequest. However, <code>server.connected</code> will be false - this is only set when calling <code>.login()</code>.</p> <p>Warning</p> <p>You will need to ensure you handle a token that has expired. This may require recreating the DrapiRequest after updating the DrapiServer instance.</p> <p>Tip</p> <p>If you are not storing the token for future use, you can logout at the end of the code. This will invalidate the JWT token and prevent it being re-used. This can be done with Try/Catch/Finally:</p> <pre><code>    Try\n        'Login and run your code\n    Catch\n        Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n    Finally\n        If (Not server is Nothing &amp;&amp; server.connected) Then server.logout\n    End Try</code></pre>"},{"location":"howto/extensions/drapi.html#drapirequest-class","title":"DrapiRequest class","text":"<p>The <code>DrapiRequest</code> class is the entrypoint for data operations on a specific Domino REST API scope, including accessing list (view) and document data, and performing DQL queries. All requests except <code>getServerInfo()</code> require you to pass the relevant scope when creating the request.</p> <p>Once you have a <code>DrapiRequest</code> object then any method called against it will return a <code>DrapiResponse</code> object. You use <code>DrapiRequest</code> to work with objects such as lists (i.e. Domino views and folders), documents, profiles, and so on.</p> <p>You can use <code>DrapiResponse.ResponseCode</code> to determine if the request was processed correctly (it will have a ResponseCode of 200). Then you can use <code>DrapiResponse.ContentBody</code> to access the JSON response content of your request.</p> <p>Note</p> <p>You will probably want to use JsonVSE to more easily parse the JSON content from Domino REST API.</p> <p>Tip</p> <p>When creating a DrapiRequest, calls can be chained, for example <code>Set serverInfo = server.createRequest(\"\").getServerInfo()</code>.</p>"},{"location":"howto/extensions/drapi.html#accessing-list-view-data","title":"Accessing list / view data","text":"<p>One of the primary entrypoints to document data is Domino views, or in the Domino REST API terminology \"lists\". DrapiVSE retains Domino REST API's terminology. Typically the developer will know the name of the list to use, but if not then the developer can use <code>DrapiRequest.getLists()</code> to get a list of available/configured lists, or a subset thereof.</p> <p>There are two functions available for accessing view data:</p> <ul> <li><code>getListEntries()</code> for accessing view entries or documents based on view entries. This is also used to get a subset of entries/documents based on one or more key(s), like getViewEntriesByKey().</li> <li><code>getListPivot()</code> for retrieving view data as a pivot table. Computes min, max, count, total of retrieved view entries.</li> </ul> <p>Since the <code>getListEntries()</code> method is capable of retrieving subsets of documents based on a variety of parameters, a special arguments object is needed to contain all of the parameters passed to <code>getListEntries()</code>. This object is based on the GetListEntriesArgs class.</p> <p>The following code will get the first 5 entries from a view. It is assumed that the DrapiServer is already logged in:</p> <pre><code>Function getEntries(server as DrapiServer, scopeName as String, viewName as String) as JsonObject\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim entryArgs as New GetListEntriesArgs\n    Dim parser as New JsonParser, jobj as JsonObject\n\n    Set request = server.createRequest(scopeName)\n\n    entryArgs.mode = \"default\"\n    entryArgs.RichTextAs = \"html\"\n    entryArgs.Count = 5\n\n    Set response = request.getListEntries(viewName, entryArgs)\n\n    If response.ResponseCode = 200 Then\n        Call parser.loadFromJSON(response.ContentBody)\n        Set jobj = parser.getRootObject\n    End If\n\n    return jobj\nEnd Function</code></pre> <p>Tip</p> <p>CRUD in web and mobile applications work best when providing targeted access to a small set of data. For this reason, DQL is a good approach when building your user experience.</p>"},{"location":"howto/extensions/drapi.html#basic-crud-operations","title":"Basic CRUD Operations","text":""},{"location":"howto/extensions/drapi.html#creation","title":"Creation","text":"<p>Creating a document requires knowing that a form is exposed and the the items expected for the \"default\" mode, which is the mode used when creating a document. The developer should know this, it is available by checking the schema for the specific application. The following code will create a document and save it to Domino REST API:</p> <p>Note</p> <p><code>DrapiDocument</code> is an extension of <code>DrapiResponse</code>, which means properties such as ResponseCode, ContentBody, and so on are available as well as the <code>DrapiDocument</code> properties and methods.</p> <pre><code>Function createCustomer(server as DrapiServer, scopeName as String) as DrapiDocument\n    Dim request as DrapiRequest, cdoc as DrapiDocument\n    Dim jobj as New JsonObject\n\n    Set request = server.createRequest(scopeName)\n    Call jobj.insertValue(\"Form\", \"Customer\")\n    Call jobj.insertValue(\"Color\", \"Red\")\n    Call jobj.insertValue(\"first_name\", \"John\")\n    Call jobj.insertValue(\"last_name\", \"Doe\")\n    Call jobj.insertValue(\"gender\", \"Male\")\n    Call jobj.insertValue(\"Pet\", \"Cockapoo\")\n    Set cdoc = request.createDocument(jobj.toString(False))\n\n    If cdoc.ResponseCode = 200 Then\n        Print \"Customer created with ID: \" &amp; cdoc.UNID\n    Else\n        Print \"Error creating customer: code: \" &amp; cdoc.ResponseCode &amp; \", message: \" &amp; cdoc.ErrorMessage\n    End If\n\n    return cdoc\nEnd Function</code></pre> <p>Note</p> <p><code>DrapiRequest.createDocument()</code> can take two additional arguments, a rich text format (default is html) and a parent UNID. When creating a new document, if you provide a parent UNID, the document will be created as a response to the given parent document.</p> <p>You can also create multiple documents at once, in bulk, using <code>DrapiRequest.bulkCreateDocuments()</code>. The example below assumes that docsjson is a String containing an array of json objects representing the documents to be created.</p> <pre><code>Sub createCustomers(server as DrapiServer, scopeName as String, docsjson as String)\n    Dim request as DrapiRequest, response as DrapiResponse\n\n    Set request = server.createRequest(scopeName)\n    Set response = request.bulkCreateDocuments(docsjson)\n    If response.ResponseCode = 200 Then\n        Print \"Customers created successfully.\"\n    Else\n        Print \"Error creating customers: code: \" &amp; response.ResponseCode &amp; \", message: \" &amp; response.ErrorMessage\n    End If\nEnd Sub</code></pre>"},{"location":"howto/extensions/drapi.html#form-access-modes","title":"Form Access Modes","text":"<p>Domino REST API uses different Form Access Modes for managing what fields are available for read / update at particular stages in the workflow. Consequently, it's important to know the Form Access Modes available and you will need to specify the required Form Access Mode when updating the document. <code>DrapiRequest.GetDocumentModes()</code> will provide the Form Access Modes and fields that can be edited when passing an UNID:</p> <pre><code>Function getDocModes(server as DrapiServer, scopeName as String, unid as String) as JsonObject\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim parser as New JsonParser, jobj as JsonObject\n    Set request = server.createRequest(scopeName)\n    Set response = request.getDocumentModes(unid)\n    If response.ResponseCode = 200 Then\n        Call parser.loadFromJSON(response.ContentBody)\n        Set jobj = parser.getRootObject\n    End If\n    return jobj\nEnd Function</code></pre>"},{"location":"howto/extensions/drapi.html#retrieval","title":"Retrieval","text":"<p>Retrieving a document is done using <code>DrapiRequest.getDocument()</code>, which returns a <code>DrapiDocument</code> object. The third parameter is the form access mode.</p> <pre><code>Function getDoc(server as DrapiServer, scopeName as String, docID as String) as DrapiDocument\n    Dim request as DrapiRequest, doc as DrapiDocument\n    Set request = server.createRequest(scopeName)\n    Set doc = request.getDocument(docID, \"html\", \"default\")\n    Return doc\nEnd Function</code></pre> <p>Warning</p> <p>Exposing rich text content to editing outside Notes Client can be risky. Different rich-text editors have different abilities to accept / output richly-formatted content. So even with no changes, there are no guarantees the user interface will faithfully round-trip the content outputted. Outputting as HTML means the code retains whatever styling used when creating the content. This may mean the outputted style does not fit naturally with the rest of the web application.</p>"},{"location":"howto/extensions/drapi.html#update","title":"Update","text":"<p>To update the document, you can use a variety of methods, including:</p> <ul> <li>You could get the document in a <code>DrapiDocument</code> object, replace the JSON in <code>DrapiDocument.JSONValue</code> and then call <code>DrapiDocument.put()</code>, with the relevant Form Access Mode.</li> <li>You could use <code>DrapiRequest.putDocument()</code> to replace all of the document JSON content.</li> <li>You could use <code>DrapiRequest.patchDocument()</code> to just replace one or more field values in the given document.</li> </ul> <p>The example below uses <code>DrapiRequest.patchDocument()</code> to update the Color to Red, and then returns the document's contents as a <code>DrapiDocument</code>.</p> <pre><code>Function updateDoc(server as DrapiServer, scopeName as String, unid as String) as DrapiDocument\n    Dim request as DrapiRequest, doc as DrapiDocument\n    Dim jobj as New JsonObject\n    Set request = server.createRequest(scopeName)\n    Call jobj.insertValue(\"Color\", \"Red\")\n    Set doc = request.patchDocument(unid, jobj.toString(False), \"html\", \"default\")\n    Return doc\nEnd Function</code></pre>"},{"location":"howto/extensions/drapi.html#delete","title":"Delete","text":"<p>Deleting a document can be done by passing either the unid to <code>DrapiRequest.deleteDocument</code> or by getting a <code>DrapiDocument</code> object and calling <code>DrapiDocument.Delete()</code>. Both require passing a Form Access Mode name in which the current user has permissions to delete documents.</p> <p>Warning</p> <p>If the deletion isn't successful, a 400 error will be returned in the ResponseCode, with further details in the ErrorMessage.</p> <p>The following code will delete a document using just its UNID:</p> <pre><code>Sub deleteDocumentByUNID(server as DrapiServer, scopeName as String, unid as String)\n    Dim request as DrapiRequest, response as DrapiResponse\n    Set request = server.createRequest(scopeName)\n    Set response = request.deleteDocument(unid, \"default\")\n    If response.ResponseCode = 200 Then\n        Print \"Document with UNID \" &amp; unid &amp; \" deleted successfully.\"\n    Else\n        Print \"Error deleting document: code: \" &amp; response.ResponseCode &amp; \", message: \" &amp; response.ErrorMessage\n    End If\nEnd Sub</code></pre> <p>There may be occasions where you want to act upon a document first, either checking item values or copying it somewhere, for example to an archive. The following code will retrieve a document, create a copy, delete the original, and return the new document:</p> <pre><code>Function copyAndDeleteDocument(server as DrapiServer, scopeName as String, unid as String) as DrapiDocument\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim doc as DrapiDocument, newdoc as DrapiDocument\n    Set request = server.createRequest(scopeName)\n    Set doc = request.getDocument(unid, \"default\")\n    If doc.ResponseCode = 200 Then\n        Set newdoc = request.createDocument(doc.JsonValue)\n        If newdoc.ResponseCode = 200 Then\n            Set response = request.deleteDocument(unid, \"default\")\n        End If\n    End If\n    return newdoc\nEnd Function</code></pre>"},{"location":"howto/extensions/drapi.html#bulk-crud-operations-and-dql","title":"Bulk CRUD operations and DQL","text":"<p>Bulk operations are done from <code>DrapiRequest</code>, which returns a <code>DrapiResponse</code> object. You can then access the <code>DrapiResponse.ResponseCode</code> to check on the success of your call (returns a 200 if successful), <code>.ContentBody</code> to access the actual JSON content returned, or <code>.ErrorMessage</code> if there was a problem.</p> <p>Overall, bulk operations are more efficient because it will make a single REST service call to Domino REST API instead of one REST service call for each document.</p> <p>There are five Bulk operations available in <code>DrapiRequest</code>:</p> <ul> <li>BulkGetDocuments - retrieves one or more documents based on the UNIDs provided in a String Array</li> <li>BulkCreateDocuments - creates one or more documents from the JSON array provided as a String</li> <li>BulkFolderDocuments - adds or removes one or more documents based on the UNIDs provided in a String Array</li> <li>BulkPatchDocuments - updates one or more field values provided in a serialized JSON array, based on the documents identified by the provided DQLQuery</li> <li>BulkDeleteDocuments - deletes one or more documents based on the UNIDs provided in a String Array</li> </ul>"},{"location":"howto/extensions/drapi.html#retrieval-by-unids","title":"Retrieval by UNIDs","text":"<p>If you have a list of UNIDs for documents, you can use <code>DrapiRequest.bulkGetDocuments()</code> to retrieve them. The following code will take an array of UNID strings and return an array of JSON objects, where each string corresponds to the document JSON.</p> <pre><code>Function getDocuments(server as DrapiServer, scopeName as String, unids() as String) as JsonObject\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim parser as New JsonParser, jobj as JsonObject\n    Set request = server.createRequest(scopeName)\n    Set response = request.bulkGetDocuments(unids, \"html\", \"default\", True)\n    If response.ResponseCode = 200 Then\n        Call parser.loadFromJSON(response.ContentBody)\n        Set jobj = parser.getRootObject\n    End If\n    return jobj\nEnd Function</code></pre>"},{"location":"howto/extensions/drapi.html#retrieval-via-dql","title":"Retrieval via DQL","text":"<p>DQL provides the ability to return documents based on a query. The following code would return the first five Customer documents where the color is \"Blue\":</p> <pre><code>Function performDqlQuery(server as DrapiServer, scopeName as String) as JsonObject\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim parser as New JsonParser(), jsonObj as JsonObject\n    Dim query as New JsonObject\n    Dim vars as New JsonObject\n\n    Set request = server.CreateRequest(scopeName)\n\n    Call query.insertValue(\"maxScanDocs\", 5000)\n    Call query.insertValue(\"maxScanEntries\", 2000)\n    Call query.insertValue(\"mode\", \"default\")\n    Call query.insertValue(\"noViews\", False)\n    Call query.insertValue(\"timeoutSecs\", 300)\n    Call query.insertValue(\"query\", \"form = 'Customer' and Color = ?Color\")\n    Call query.insertValue(\"viewRefresh\", False)\n    Set vars = new JsonObject()\n    vars.label = \"variables\"\n    Call vars.insertValue(\"Color\", \"Blue\")\n    Call query.insertObject(vars)\n\n    Set response = request.dqlQuery(query.toString(True), \"execute\", 5)\n    If response.ResponseCode = 200 Then\n        Call parser.loadFromJSON(response.ContentBody)\n        Set jsonObj = parser.getRootObject()\n    Else\n        Print \"Error performing DQL query: \" &amp; response.ResponseCode &amp; \" - \" &amp; response.ErrorMessage\n    End If\n    Return jsonObj\nEnd Function</code></pre> <p>Tip</p> <p>Use JsonVSE to build the query rather than trying to build it as a String. If you get an error message for invalid JSON, print out the JSON and cross-reference it with / try it in Swagger on the relevant server.</p> <p>Note</p> <p><code>DrapiRequest.DQLQuery()</code> can also be used to perform other DQL verbs - \"query\" and \"explain\".</p>"},{"location":"howto/extensions/drapi.html#update-via-dql","title":"Update via DQL","text":"<p>Bulk update is performed via a DQL query, a list of items to update and a Form Access Mode with which to perform the update. The <code>DrapiRequest.bulkPatchDocuments()</code> method can either return the full JSON of the documents at the relevant mode, or a JSON object that contains a summary of the documents updated. The following code will update Customers where Color is \"Red\", changing the color to \"Maroon\". It will return all values from the underlying documents.</p> <pre><code>Function updateDocuments(server as DrapiServer, scopeName as String) as String\n    Dim request as DrapiRequest, response as DrapiResponse\n    dim query as String\n    Dim replaceItems as New JsonObject()\n\n    Set request = server.CreateRequest(scopeName)\n\n    Call replaceItems.insertValue(\"Color\", \"Maroon\")\n    query = \"form = 'Customer' and Color = 'Red'\"\n\n    Set response = request.bulkPatchDocuments(query, replaceItems.toString(False), \"html\", \"default\", 5000, True, True)\n\n    If response.ResponseCode = 200 Then\n        Return response.ContentBody\n    Else\n        Print \"Error updating documents: \" &amp; response.ResponseCode &amp; \" - \" &amp; response.ErrorMessage\n        Return \"\"\n    End If\nEnd Function</code></pre> <p>If <code>False</code> had been passed as the last parameter of <code>DrapiRequest.bulkPatchDocuments()</code> the result would have looked something like this:</p> <pre><code>[\n{\"statusText\":\"OK\",\"status\":200,\"message\":\"Document 2B057308D23ED5AD00258A210046664B updated\",\"unid\":\"2B057308D23ED5AD00258A210046664B\"},\n{\"statusText\":\"OK\",\"status\":200,\"message\":\"Document A1057308D23ED5AD00258A210046527F updated\",\"unid\":\"A1057308D23ED5AD00258A210046527F\"}\n]\n</code></pre>"},{"location":"howto/extensions/drapi.html#deletion-by-unids","title":"Deletion by UNIDs","text":"<p>Just like <code>DrapiRequest.bulkGetDocuments()</code>, you can use an array of UNIDs to delete multiple documents at once.</p> <p>The following example will delete the documents indicated in the UNID string array, and return a status message for each document:</p> <pre><code>Function deleteDocuments(server as DrapiServer, scopeName as String, unids() as String) as JsonObject\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim parser as New JsonParser, jobj as JsonObject\n    Set request = server.createRequest(scopeName)\n    Set response = request.bulkDeleteDocuments(unids, \"default\")\n    If response.ResponseCode = 200 Then\n        Call parser.loadFromJSON(response.ContentBody)\n        Set jobj = parser.getRootObject\n    End If\n    return jobj\nEnd Function</code></pre>"},{"location":"howto/extensions/drapi.html#attachments","title":"Attachments","text":""},{"location":"howto/extensions/drapi.html#add-an-attachment","title":"Add an attachment","text":"<p>Adding an attachment is done by using <code>DrapiRequest.createAttachment()</code>. You need to pass the filepath of the attachment to add and an optional name of a field in which to place the attachment.</p> <p>The following code will create an attachment in a field called \"RichText\" in the provided <code>DrapiDocument</code>:</p> <p>Note</p> <p>You could bypass <code>DrapiDocument</code> altogether if you already know the UNID of the target document by simply calling <code>DrapiRequest.createAttachment()</code> directly.</p> <pre><code>Function addAttachment(doc as DrapiDocument, filePath as String) as String\n    Dim request as DrapiRequest, response as DrapiResponse\n    Set request = doc.ParentRequest\n    If filepath = \"\" Then\n        filePath = CurDir() &amp; \"/libs/functions.vss\"\n    End If\n    Set response = request.createAttachment(doc.Unid, filePath, \"RichText\")\n    If response.ResponseCode = 200 Then\n        Return response.ContentBody\n    Else\n        Print \"Error creating attachment: \" &amp; response.ResponseCode &amp; \" - \" &amp; response.ErrorMessage\n        Return \"\"\n    End If\nEnd Function</code></pre>"},{"location":"howto/extensions/drapi.html#download-an-attachment","title":"Download an attachment","text":"<p>Downloading an attachment requires knowledge of the attachment name to download. The following code will download the indicated attachment in the provided document to the indicated targetpath, assuming the Form Access Mode is configured correctly:</p> <pre><code>Sub getAttachment(doc as DrapiDocument, attachName as String, targetPath as String)\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim parser as New JsonParser, jobj as JsonObject\n    Set request = doc.ParentRequest\n    Set response = request.getAttachment(doc.UNID, attachName, targetPath)\n    If response.ResponseCode = 200 Then\n        Print \"Attachment downloaded successfully to \" &amp; targetPath\n    Else\n        Print \"Error downloading attachment: \" &amp; response.ResponseCode &amp; \", see target file for error\"\n    End If\n    return jobj\nEnd Sub</code></pre>"},{"location":"howto/extensions/drapi.html#delete-an-attachment","title":"Delete an Attachment","text":"<p>Similar to downloading an attachment, deleting an attachment requires knowledge of the attachment name to be deleted. The FieldName parameter indicates the name of the field in which the attachment resides. You should pass this to remove the hotspot for the attachment from that rich text field, otherwise the hotspot will remain. If the attachment is attached directly to the document, not a field, there is not need to provide this parameter.</p> <pre><code>Function deleteAttachment(doc as DrapiDocument, attachName as String, fieldName as String) as JsonObject\n    Dim request as DrapiRequest, response as DrapiResponse\n    Dim parser as New JsonParser, jobj as JsonObject\n    Set request = doc.ParentRequest\n    Set response = request.deleteAttachment(doc.UNID, attachName, fieldName)\n    If response.ResponseCode = 200 Then\n        Call parser.loadFromJSON(response.ContentBody)\n        Set jobj = parser.getRootObject\n    End If\n    return jobj\nEnd Function</code></pre>"},{"location":"howto/extensions/drapi.html#investigate-apis-for-more","title":"Investigate APIs for more","text":"<p>Other APIs are available for more various other Domino REST API functions, like folder manipulation, profile document handling, agent processing, and use of QRP views. See the API documentation for more details.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/encrypt.html","title":"Encryption","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/encrypt.html#introduction","title":"Introduction","text":"<p>Advanced Encryption Standard (AES) is a standard encryption algorithm using symmetric keys. This means it uses the same keys for both encryption and decryption. VoltScript provides both 128-bit and 256-bit cryptographic keys. It also provides the ability to generate the initialization vector, a randomized starting point for the encryption.</p>"},{"location":"howto/extensions/encrypt.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating HashVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"HashVSE\": {\n            \"library\": \"HashVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"hashvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*HashVSE\"</code>.</p>"},{"location":"howto/extensions/encrypt.html#aes-encryption","title":"AES Encryption","text":""},{"location":"howto/extensions/encrypt.html#initialization-vector-and-keys","title":"Initialization vector and keys","text":"<p>For AES encryption, you will need an initialization vector and either a 128-bit or 256-bit key, stored as a byte array. The following code shows how to initialize all:</p> <pre><code>Sub initializeForAES(iv as Variant, key128 as Variant, key256 as Variant)\n    Dim cu as New CryptoUtilities()\n    iv = cu.createAESIV()\n    key128 = cu.createAES128Key()\n    key256 = cu.createAES256Key()\nEnd Sub</code></pre>"},{"location":"howto/extensions/encrypt.html#encrypting-a-file","title":"Encrypting a file","text":"<p>The following code will encrypt the file:</p> <pre><code>Function encryptFile(iv as Variant, key as Variant, sourceFile as String, targetFile as String)\n    Dim cu as New CryptoUtilities()\n    Call cu.fileEncryptAES(sourceFile, targetFile, iv, key, True)\nEnd Function</code></pre> <p>The same function is used for encrypting with a 128-bit key or a 256-bit key. You just pass the relevant key.</p>"},{"location":"howto/extensions/encrypt.html#decrypting-a-file","title":"Decrypting a file","text":"<p>Decrypting a file will require the same initialization vector and key used to encrypt it, both as byte arrays. This will probably not be shared as a byte array, but a string. HashUtilities provides an option to convert the string to a byte array, as shown in the Hash how-to.</p> <p>Decrypting the file with the keys, as byte arrays, can be done with the following code:</p> <pre><code>Function decryptFile(sourceFile as String, targetFile as String, iv as Variant, key as Variant)\n    Dim cu as New CryptoUtilities()\n    Call cu.fileDecryptAES(sourceFile, targetFile, iv, key, True)\nEnd Function</code></pre>"},{"location":"howto/extensions/encrypt.html#rsa-pkcs-encryption","title":"RSA PKCS Encryption","text":"<p>HashVSE supports key generation, encryption, and decryption of files and data using RSAES-OAEP, following the PKCS #1 version 2.2 standards.</p> <p>Currently, signing messages with private keys and verifying signatures with public keys are not supported.</p>"},{"location":"howto/extensions/encrypt.html#creating-the-private-public-keys","title":"Creating the private / public keys","text":"<p>RSA encryption uses a private / public key pair. This can be used to encrypt / decrypt both files and byte arrays. You may already have those files generated and saved. But VoltScript also provides functions to generate the files.</p> <pre><code>Sub createRSAKeys()\n    Dim cu as New CryptoUtilities()\n    result = cu.createRSAKeyPair(CurDir &amp; \"user-id\", CurDir &amp; \"user-id.pub\")\nEnd Sub</code></pre> <p>There are additional parameters for using a password to generate the private key file with and the number of bits. You should use a password and always keep it safe.</p>"},{"location":"howto/extensions/encrypt.html#encrypting-a-file_1","title":"Encrypting a file","text":"<p>The following code will encrypt the file:</p> <pre><code>Sub encryptFilePKCS(privateKeyFile as String, plainFile as String, encryptedFile as String)\n    Dim cu as New CryptoUtilities()\n    Call cu.PKCSEncryptFile(privateKeyFile, True, sourceFile, targetFile, True)  ' Assumes no password on file\nEnd Sub</code></pre>"},{"location":"howto/extensions/encrypt.html#decrypting-a-file_1","title":"Decrypting a file","text":"<p>Decrypting a file will require the same initialization vector and key used to encrypt it, both as byte arrays. This will probably not be shared as a byte array, but a string. HashUtilities provides an option to convert the string to a byte array, as shown in the Hash how-to.</p> <p>Decrypting the file with the keys, as byte arrays, can be done with the following code:</p> <pre><code>Sub decryptFilePKCS(privateKeyFile as String, encryptedFile as String, plainFile as String)\n    Dim cu as New CryptoUtilities()\n    Call cu.PKCSDecryptFile(privateKeyFile, encryptedFile, plainFile, True)  ' Assumes no password on file\nEnd Sub</code></pre>"},{"location":"howto/extensions/encrypt.html#encrypting-a-string","title":"Encrypting a string","text":"<p>To encrypt a string, it first needs to be converted to a byte array. Encrypting the byte array is similar to encrypting a file.</p> <pre><code>Function encryptBufferPKCS(rivateKeyFile as String, stringToEncrypt) as String\n    Dim cu as New CryptoUtilities()\n    Dim publicKeyBytes as Variant\n    Dim clearBytes as Variant\n    Dim encryptedBytes as Variant\n    publicKeyBytes = cu.PKCSReadPrivateKeyFile(privateKeyFile)  ' Assumes no password on file\n    clearBytes = cu.textToBytes(stringToEncrypt)\n    encryptedBytes = cu.PKCSEncryptBuffer(publicKeyBytes, false, clearBytes)\n    Return cu.bytesToText(encryptedBytes)\nEnd Function</code></pre>"},{"location":"howto/extensions/encrypt.html#decrypting-a-string","title":"Decrypting a string","text":"<p>Decrypting a string will be very similar:</p> <pre><code>Function decryptBufferPKCS(rivateKeyFile as String, encryptedString) as String\n    Dim cu as New CryptoUtilities()\n    Dim publicKeyBytes as Variant\n    Dim clearBytes as Variant\n    Dim encryptedBytes as Variant\n    publicKeyBytes = cu.PKCSReadPrivateKeyFile(privateKeyFile)  ' Assumes no password on file\n    encryptedBytes = cu.textToBytes(encryptedString)\n    clearBytes = cu.PKCSDecryptBuffer(publicKeyBytes, encryptedBytes)\n    Return cu.bytesToText(encryptedBytes)\nEnd Function</code></pre> <p>Warning</p> <p><code>bytesToText()</code> and <code>textToBytes()</code> will be renamed after EA4 to <code>bytesToString()</code> and <code>stringToBytes()</code>, for consistency with HashUtilities class.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/env-vars.html","title":"Access platform and environment variables","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/env-vars.html#environ-function","title":"<code>Environ()</code> Function","text":"<p>The <code>Environ()</code> function has always been available in LotusScript, and is also available in VoltScript. However, it only allows reading previously set environment variables. Nonetheless, it's useful if read-only access is sufficient, if you aren't already including the OSUtils VoltScript Extension in your project and would prefer not to.</p>"},{"location":"howto/extensions/env-vars.html#retrieve-home-directory-with-getthreadinfo-and-environ","title":"Retrieve home directory with GetThreadInfo() and Environ()","text":"<p>On Windows, the environment variable for the user's directory is \"USERPROFILE\". On Linux, it is \"HOME\". <code>GetThreadInfo</code> provides access to the current platform at index 13.</p> <pre><code>Function getHomeDirTraditional() as String\n    Dim platform as String\n    Dim envVar as String\n    Dim homeDir as String\n\n    platform = GetThreadInfo(13)\n    Select Case platform\n    Case \"WIN64\":\n        envVar = \"USERPROFILE\"\n    Case \"LINUX64\":\n        envVar = \"HOME\"\n    Case Else\n        Error 1001, \"Unexpected platform - \" &amp; platform\n    End Select\n\n    Return Environ$(envVar)\nEnd Function</code></pre>"},{"location":"howto/extensions/env-vars.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating OSUtilsVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"OSUtilsVSE\": {\n            \"library\": \"OSUtilsVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"osutilsvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*OSUtilsVSE\"</code>.</p>"},{"location":"howto/extensions/env-vars.html#retrieve-home-directory-with-osutils-and-environ","title":"Retrieve home directory with OSUtils and Environ()","text":"<p>OSUtils allows the developer to reproduce the same functionality.</p> <pre><code>\nFunction getHomeDirOS() as String\n    Dim OSUtils as New OSUtils()\n    Dim platform as String\n    Dim envVar as String\n    Dim homeDir as String\n\n    platform = OSUtils.platform\n    Select Case platform\n    Case \"Windows64\":\n        envVar = \"USERPROFILE\"\n    Case \"LINUX\":\n        envVar = \"HOME\"\n    Case Else\n        Error 1001, \"Unexpected platform - \" &amp; platform\n    End Select\n\n    Return OSUtils.getEnvironment(envVar)\nEnd Function</code></pre> <p>Info</p> <p>OSUtils VoltScript Extension and the VoltScript runtime each take a separate snapshot of environment variables at the start of execution. This means an environment variable set with <code>OSUtils.setEnvironment()</code> will be available to <code>OSUtils.getEnvironment()</code> but not to <code>Environ$()</code>.</p>"},{"location":"howto/extensions/env-vars.html#retrieve-home-directory-with-osutilshomedir","title":"Retrieve home directory with OSUtils.HomeDir","text":"<p>Alternatively, the user's directory can be retrieved from OSUtils, without needing to check the platform or environment variables.</p> <pre><code>Function getHomeDirOSProperty() as String\n    Dim OSUtils as New OSUtils()\n\n    Return OSUtils.homeDir\nEnd Function</code></pre>"},{"location":"howto/extensions/env-vars.html#retrieve-temp-dir","title":"Retrieve temp dir","text":"<p>Retrieving the temp directory via environment variables across platforms using <code>Environ$()</code> is less straightforward. But OSUtils offers an easy property to get the temp directory.</p> <pre><code>Function getTempDir() as String\n    Dim OSUtils as New OSUtils()\n\n    Return OSUtils.tempDir\nEnd Function</code></pre>"},{"location":"howto/extensions/env-vars.html#set-environment-variables","title":"Set environment variables","text":"<p>Note</p> <p>Environment variables set via VoltScript won't persist outside the current process call.</p> <p>Warning</p> <p>You should be careful to only set environment variables that won't have deleterious impacts.</p> <pre><code>Sub setEnvironmentVariable()\n    Dim OSUtils as New OSUtils()\n\n    Call OSUtils.setEnvironment(\"VOLTSCRIPT_HELLO\",\"Hello World\")\nEnd Sub</code></pre> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/file-download.html","title":"Download files","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p> <p>Note</p> <p>For specific details of APIs, see API Docs</p>"},{"location":"howto/extensions/file-download.html#introduction","title":"Introduction","text":"<p>Although REST doesn't have to be over HTTP or transfer content as JSON, typically this is the case. This how-to covers this typical use case and requires the use of two VoltScript Extensions, which are WebVSE and JsonVSE.</p>"},{"location":"howto/extensions/file-download.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating JsonVSE and WebVSE is straightforward. You just need to add the following JSON objects to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"WebVSE\": {\n            \"library\": \"WebVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"webvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*JsonVSE\"</code> and <code>UseVSE \"*WebVSE\"</code>.</p>"},{"location":"howto/extensions/file-download.html#download-files_1","title":"Download files","text":"<p>Warning</p> <p>VoltScript runs synchronously, so downloading files should be done with prudent caution. In Volt MX Go this will be running as middleware, requiring VoltScript to download the file to Volt Foundry over HTTP and send it on via HTTP to the device. Best practice, where possible, would be to send the target URL as a string to the device and allow the device to download the file directly.</p> <p>Downloading files is done via a <code>WebRequest</code>. Setting up the <code>WebServer</code> is no different than for any other <code>WebRequest</code>, if you are unfamiliar, refer to WebServer Object How-to.</p>"},{"location":"howto/extensions/file-download.html#synchronous-file-download","title":"Synchronous file download","text":"<p>If downloading a single file you know is small or reasonably-sized over strong bandwidth, synchronous download may be sufficient. The Domino server has standard files that can be used to test against, provided the nhttp task is running. The following code will download a view icon:</p> <pre><code>Sub downloadViewIcon()\n\n    Dim request as WebRequest\n    Dim response as WebResponse\n    Dim path as String\n\n    Try\n        ' Update Domino server details in `getDominoWebServer()`\n        Set request = getDominoWebServer().createRequest()\n        request.target = \"icons/vwicn001.gif\"\n        request.timeoutSeconds = 10\n        path = CurDir &amp; \"/unit-test-reports/vwicon1.gif\"\n        Set response = request.fileDownload(path)\n        If response.responseCode = 200 Then\n            Print \"Successful download, check \" &amp; path\n        End If\n    Catch\n        Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n    End Try\n\nEnd Sub</code></pre>"},{"location":"howto/extensions/file-download.html#asynchronous-file-download","title":"Asynchronous file download","text":"<p>If downloading multiple files, they can be downloaded async in parallel. However, because the <code>WebRequest</code> object is being used to run the download, you need to create a separate instance for each download, otherwise you will receive the error message \"Error Background task is running, use another WebRequest instance\".</p> <p>Whereas <code>fileDownload()</code> returns a <code>WebResponse</code>, the asynchronous version <code>fileDownloadNoWait</code> returns a <code>Completion</code> object. The <code>Completion</code> objects can be polled to identify when all files have been downloaded and subsequent code can be run. The <code>WebResponse</code> is accessed from each <code>Completion</code> object.</p> <p>This code will download multiple view icons from a Domino server. Of course all are small, so the code will not take long to run.</p> <pre><code>Sub downloadViewIconsAsync()\n\n    Dim request as WebRequest\n    Dim arr(2) as Completion\n    Dim response as WebResponse\n    Dim path as String\n\n    Try\n        ' Update Domino server details in `getDominoWebServer()`\n        Set request = getDominoWebServer().createRequest()\n        request.timeoutSeconds = 10\n        request.target = \"icons/vwicn001.gif\"\n        path = CurDir &amp; \"/unit-test-reports/vwicon-async1.gif\"\n        Set arr(0) = request.fileDownloadNoWait(path)\n\n        Set request = getDominoWebServer().createRequest()  ' (1)!\n        request.timeoutSeconds = 10\n        request.target = \"icons/vwicn002.gif\"\n        path = CurDir &amp; \"/unit-test-reports/vwiconasync2.gif\"\n        Set arr(1) = request.fileDownloadNoWait(path)\n\n        Set request = getDominoWebServer().createRequest()\n        request.timeoutSeconds = 10\n        request.target = \"icons/vwicn003.gif\"\n        path = CurDir &amp; \"/unit-test-reports/vwiconasync3.gif\"\n        Set arr(2) = request.fileDownloadNoWait(path)\n\n        Call arr(0).wait()\n        Call arr(1).wait()\n        Call arr(2).wait()\n\n        Dim i as Integer\n        For i = 0 To UBound(arr)\n            Set response = arr(i).response\n            Print response.responseCode\n        Next\n\n        If response.responseCode = 200 Then\n            Print \"Successful download, check \" &amp; path\n        End If\n    Catch\n        Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n    End Try\n\nEnd Sub</code></pre> <ol> <li>This line is crucial for re-initialising the <code>WebRequest</code> and avoiding the error to use another instance.</li> </ol> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/find-files.html","title":"Find files and managing directories","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/find-files.html#introduction","title":"Introduction","text":"<p>There have always been low-level APIs for interacting with the filesystem - <code>Dir</code>, <code>MkDir</code>, <code>RMDir</code>, <code>Open</code> <code>Kill</code> etc. Proper use and error management of these APIs requires careful reading of the APIs and knowledge gleaned over many years. The OSUtils VoltScript Extension is designed to lower the entry level for interacting with the filesystem and minimize the amount of code that needs to bootstrap the specific actions to be performed.</p>"},{"location":"howto/extensions/find-files.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating OSUtilsVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"OSUtilsVSE\": {\n            \"library\": \"OSUtilsVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"osutilsvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*OSUtilsVSE\"</code>.</p>"},{"location":"howto/extensions/find-files.html#directory-and-file-operations","title":"Directory and file operations","text":""},{"location":"howto/extensions/find-files.html#identify-directory","title":"Identify directory","text":"<p>Warning</p> <p>The unwary developer may assume <code>CurDir()</code> function returns the directory containing the script currently being edited, but this is a misconception. The VoltScript <code>CurDir()</code> functions works the same way it does in LotusScript, returning the current directory where the program is being run. Typically this will be the project directory.</p> <p><code>OSUtils.isDirectory()</code> provides an API to just return a boolean for whether there is a directory at the path passed, without the need for any error handling.</p> <pre><code>Function checkIsDir(filePath as String)\n    Dim OSUtils as New OSUtils()\n    Return OSUtils.isDirectory(filePath)\nEnd Function</code></pre>"},{"location":"howto/extensions/find-files.html#build-paths","title":"Build paths","text":"<p>You can build the path manually. If so, a forward-slash is recommended as the separator. This is now accepted by Windows operating systems and is standard for UNIX operating systems.</p> <p>However, PathUtils provides a helper class for building paths without worrying about the separator, as is common for many other languages. <code>toString()</code> can be used to return the string, for directory operations.</p> <pre><code>Function buildFooBarPath() as String\n    Dim OSUtils as New OSUtils()\n    Dim pathUtils as New PathUtils()\n\n    Call pathUtils.addToPath(OSUtils.tempDir)\n    Call pathUtils.addToPath(\"foo\")\n    Call pathUtils.addToPath(\"bar\")\n    Return pathUtils.toString\nEnd Function</code></pre> <p>At this point, you are only building an object that has a potential directory structure. No checks against or modification of the operating system are performed.</p> <p>We know \"foo\" doesn't exist, so the full path can't possibly exist. But checking <code>OSUtils.isDirectory()</code> against this path will just return <code>false</code>, as expected, it won't throw an error. There is no need to perform a check with <code>isDirectory()</code> against each level of the directory hierarchy.</p>"},{"location":"howto/extensions/find-files.html#33-identify-file","title":"3.3 Identify file","text":"<p>The corresponding API for checking whether a file exists at a given path is, not surprisingly, <code>isFile()</code>.</p> <pre><code>Function checkIsFile(fileName as String) as Boolean\n    Dim OSUtils as New OSUtils()\n    Return OSUtils.isFile(fileName)\nEnd Function</code></pre> <p><code>PathUtils</code> can be used to build a path to a file as well as to a directory.</p> <pre><code>Function buildFooTestFilePath() as String\n    Dim OSUtils as New OSUtils()\n    Dim pathUtils as New PathUtils()\n\n    Call pathUtils.addToPath(OSUtils.tempDir)\n    Call pathUtils.addToPath(\"foo\")\n    Call pathUtils.addToPath(\"test.txt\")\n    Return pathUtils.toString\nEnd Function</code></pre>"},{"location":"howto/extensions/find-files.html#retrieve-files-in-a-directory","title":"Retrieve files in a directory","text":"<p>Rather than making an API call to get the next file in a directory, OSUtils has an API to return a string array of all files in a directory.</p> <pre><code>Function getFiles(filePath as String) as Variant\n    Dim OSUtils as New OSUtils()\n    Return OSUtils.getFilesInDir(filePath)\nEnd Function</code></pre>"},{"location":"howto/extensions/find-files.html#create-and-removing-directories","title":"Create and removing directories","text":""},{"location":"howto/extensions/find-files.html#create-directories","title":"Create directories","text":"<p>Creating directories is done using <code>makeDirectories()</code>. This assumes that, if you want to create the directory, you want to create all parent directories on the path.</p> <pre><code>Function makeDirectories(filePath as String) as Boolean\n    Dim OSUtils as New OSUtils()\n    Return osUtils.makeDirectories(filePath)\nEnd Function</code></pre> <p>If the directory already exists, <code>makeDirectories</code> won't throw an error but still return true.</p>"},{"location":"howto/extensions/find-files.html#remove-directories","title":"Remove directories","text":"<p>Removing directories, however, allows the developer to decide whether or not to force deletion of any files and subdirectories in the directory. This is the boolean parameter passed as the second argument.</p> <pre><code>Function removeDirectories(filePath as String) as Boolean\n    Dim OSUtils as New OSUtils()\n    Return OSUtils.removeDir(filePath, true)\nEnd Function</code></pre> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/generate.html","title":"Generate a new VoltScript Extension using VoltScript Interface Designer","text":""},{"location":"howto/extensions/generate.html#introduction","title":"Introduction","text":"<p>VoltScript Extensions (VSEs) are native libraries for the VoltScript runtime using the same well-known interface as earlier LotusScript Extensions (LSXs). As native code, they provide a way to write new classes and objects with more complex functionality or that use an existing third-party library. VoltScript Interface Designer (VSID) provides a way to describe the classes, properties, and methods of a VSE, and then generates C++ skeleton code based on the interface. This code uses modern CMake as its build system, allowing a developer to use a text editor or IDE of their choice to implement the design.</p>"},{"location":"howto/extensions/generate.html#voltscript-interface-designer","title":"VoltScript Interface Designer","text":"<p>VSID is distributed as a .ntf template and a .dll LSX for the Windows version of HCL Notes\u00ae 14.0. The template provides a form for designing a VSE or VoltScript library, while the .dll handles the C++ code generation. You must register the LSX first so that it can be loaded by Notes.</p> <p>To start designing your own VSE:</p> <ol> <li> <p>Extract the VSID template and .dll to a directory of your choice. As an example, you can use the path <code>C:\\VSE\\</code>.</p> </li> <li> <p>Close Notes 14.0 if it's open.</p> </li> <li> <p>Register <code>vsidwizard.dll</code> in the Windows Registry.</p> <p>A value needs to be added to the key <code>Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Lotus\\Components\\LotusScriptExtensions\\2.0</code>. Notes 14.0 creates this key when it's installed, along with a string value named <code>Notes</code>.</p> <p>VSID requires a string value of <code>lsxwizard</code> with its data as the full path to <code>vsidwizard.dll</code>.</p> <p>You can add the value yourself using the Registry Editor, or by running this command in an elevated command prompt, replacing <code>C:\\VSE\\vsidwizard.dll</code> with the full path to the DLL on your system:</p> <pre><code>REG ADD HKLM\\Software\\Lotus\\Components\\LotusScriptExtensions\\2.0 /v lsxwizard /t REG_SZ /d \"C:\\VSE\\vsidwizard.dll\" /f\n</code></pre> </li> <li> <p>Import the VSID template (<code>vsid.ntf</code>) into your Notes 14.0 client. An easy way is copying it into your Notes data directory.</p> </li> <li> <p>Open Notes 14.0 and create a new database using \"VoltScript Interface Designer 1.0.0\" as the template.</p> <p>As an example, you can use the name \"My First VSE\". The new database is automatically opened to the \"Script Extension Projects\" view.</p> </li> <li> <p>Set the paths VSID will use when generating the VSE.</p> <ol> <li> <p>Click Setup located at the top right corner of the view to open the VoltScript Interface Designer Setup dialog.</p> <p></p> </li> <li> <p>In the VoltScript Interface Designer Setup dialog, set the VSE Target Directory to your preferred directory by either using the folder icon to select the directory or directly entering the directory path in the text field. As an example, you can use <code>C:\\VSE\\MyFirstVSE\\</code>.</p> <p>Note</p> <p>The selected VSE Target Directory is the directory where the generated VSE files will be written to.  </p> <p></p> </li> </ol> </li> </ol>"},{"location":"howto/extensions/generate.html#design-and-generate-a-new-vse","title":"Design and generate a new VSE","text":"<p>VSID provides an interface for creating and modifying the programming interface for a VSE, such as the names and data types of properties and functions. You'll use it to create a simple VSE.</p> <ol> <li> <p>Make sure \"Script Extension Projects\" is selected from the left hand pane in VSID.</p> </li> <li> <p>Create a project.</p> <ol> <li>Along the top black bar of VSID, click Project to create and open a new project document.</li> <li> <p>Fill in the fields, such as for the name and description, as needed.</p> <p>The Name is the name of the VSE and will be referenced by any scripts that use it. As an example, you can set the name to \"MyFirstVSE\".</p> </li> <li> <p>Click Save &amp; Close at the top left of the document to save your changes and return to VSID.</p> </li> </ol> </li> <li> <p>Create a class.</p> <ol> <li>With the project selected, click Class from the top of the VSID to create and open a new class document in that project.</li> <li> <p>Fill in the name field.</p> <p>The enetered name will be used as the name of the class in the scripts. As an example, you can set the name to \"MyFirstClass\".</p> </li> <li> <p>Click Save &amp; Close at the top left of the document to save your changes and return to VSID.</p> </li> </ol> </li> <li> <p>Give the class a property.</p> <ol> <li> <p>With the class selected, click Property to create a new property.</p> <p>Tip</p> <p>Properties are available to both VoltScript and C++, and can be used to expose data or provide a control.</p> </li> <li> <p>Set the Name of the property, as well as its Data Type and optionally its Initial Value when an instance of this class is created. As an example, you can create a property having the name \"MyFirstProperty\", the data type \"Integer-Signed\", and the initial value \"123\".</p> <p></p> </li> <li> <p>Click Save &amp; Close at the top left of the document to save your changes and return to VSID.</p> </li> </ol> </li> <li> <p>Give the class a method.</p> <ol> <li>With the class selected, click Method to create a new method.</li> <li> <p>Enter a Name and select the Type and Return Type of the method.</p> <p>Tip</p> <p>Methods can be called by VoltScript and are generated as C++ methods. A method can be a function, which has a return value, or a sub, which has no return value, and can optionally have a number of arguments with default values.</p> <p>As an example, you can create a method with the name \"TestMethod\", the type \"Function\", and the return type \"Integer-Signed\". The default return value for this data type is 0.</p> <p></p> </li> <li> <p>Click Save &amp; Close at the top left of the document to save your changes and return to VSID.</p> </li> </ol> </li> <li> <p>Click Generate Extension Files.</p> <p>Note</p> <p>You will need to have a document in the \"Script Extension Projects\" selected to be able to run this.</p> </li> <li> <p>In the VSE Output Directory dialog, check the VSE Target Directory path, change it if needed, and the click OK to generate the files, along with the needed common header and source files.</p> <p>Note</p> <p>The defined VSE Target Directory path in the VSE Output Directory dialog is by default the same as the VSE Target Directory path defined in the VoltScript Interface Designer Setup dialog.</p> <p></p> </li> </ol> <p>You can edit any document in VSID by double-clicking it to open. Comment and Code Sample fields can be left empty, but will be referenced when the documentation is generated.</p>"},{"location":"howto/extensions/generate.html#build-and-test-a-new-vse","title":"Build and test a new VSE","text":"<p>After generating the C++ code, you can begin development. You'll start by building and testing the freshly generated VSE. All methods and functions will be given placeholder values to allow the code to be compiled and loaded by VoltScript without editing any source first.</p> <ol> <li> <p>Build the VSE by either using the generated build script or another tool like Visual Studio Code.</p> <p>You will need a build environment with the 64-bit MSVC compiler and CMake available. If you have Visual Studio installed, a command prompt with the needed tools is in your start menu. Search for \"x64 Native Tools Command Prompt for VS\". Navigate this command prompt to your generated VSE and run the generated build script: <code>build.bat --debug</code>. You can get help on using this script by running <code>build.bat --help</code>.</p> </li> <li> <p>Write a test VoltScript file that loads the VSE and interacts with it.</p> <p>As an example, here is a test script that interacts with our project, class, property, and method:</p> <pre><code>Option Public\nOption Declare\n\nUseVSE \"*MyFirstVSE\"\n\nSub Initialize\n\n    Dim hello as New MyFirstClass\n\n    Print \"Testing reading a VSE property:\"\n    Print hello.MyFirstProperty\n\n    Print \"Testing calling a VSE method:\"\n    Print hello.TestMethod()\n\nEnd Sub</code></pre> <p>For this example, this file will be located at <code>C:\\VSE\\MyFirstVSE\\hello.vss</code>.</p> </li> <li> <p>Run the script using VoltScript.</p> <p>You need to provide VoltScript with the path to the newly built VSE through <code>seti.ini</code>. The CMake build system automatically generates a sample <code>seti.ini</code> with the path the built .dll in <code>bin/w64/</code>, as <code>seti-D.ini</code> for \"debug\" builds and <code>seti.ini</code> for \"release\" builds. You can pass the path to this <code>seti.ini</code> to VoltScript through the --seti option on the command line.</p> <p>As an example, you can run the test script against your earlier debug build by running VoltScript like this: <code>VoltScript.exe --seti bin\\w64\\seti-D.ini hello.vss</code>.</p> <p>The output of a successful test would look like this:</p> <pre><code>Testing reading a VSE property:\n 123\nTesting calling a VSE method:\n 0\n</code></pre> </li> </ol>"},{"location":"howto/extensions/generate.html#next-steps","title":"Next steps","text":"<p>Now that you have a functional VSE, you can use it as the starting point for further development. A development flow might look like this:</p> <ul> <li> <p>Implement the functionality of the VSE to provide a powerful library to your VoltScript projects. The most important files will be in the <code>src/VSEName</code> folder, where VSEName is the name of the project, like \"MyFirstVSE\". Files named after classes, like \"MyFirstClass.cpp\" and \"MyFirstClass.hpp\", will be populated with stub code for the methods and properties set in VSID.</p> </li> <li> <p>Add more properties or methods and regenerate the VSE. Throughout the generated code are commented tag strings like <code>//{{LSX_AUTHOR_CODE_</code> and <code>//}}</code>. The code generation step will preserve any code between these tags, allowing existing implementations to be kept when the generation is run again.</p> </li> <li> <p>Use a source control tool like git to track changes and share your VSE with other developers.</p> </li> <li> <p>Review the generated <code>CMakeLists.txt</code> file and note how external libraries can be included.</p> </li> <li> <p>Test your VSE on your target platforms, such as the VoltScript Dev Container. The generated build system works on both Windows and Linux.</p> </li> </ul>"},{"location":"howto/extensions/hash.html","title":"Encode and hash content","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/hash.html#introduction","title":"Introduction","text":"<p>Because VoltScript is running as middleware, the need to convert to and from various hashing algorithms is probable. HashVSE is designed to enable this using the <code>HashUtilities</code> class.</p>"},{"location":"howto/extensions/hash.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating HashVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"HashVSE\": {\n            \"library\": \"hashVSE Voltscript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"hashvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*HashVSE\"</code>.</p>"},{"location":"howto/extensions/hash.html#input-and-output-formats","title":"Input and output formats","text":"<p>All the APIs can receive input and output content as VoltScript strings or Byte Arrays. Because there is no data type specifically for Byte Arrays, the VoltScript data type is <code>Variant</code>, containing an array of Byte data types.</p>"},{"location":"howto/extensions/hash.html#converting-a-string-to-a-byte-array","title":"Converting a String to a Byte array","text":"<p>The following code can be used to convert a string to a byte array:</p> <pre><code>Function convertStringToBytes(passedStr as String) as Variant\n    Dim hu as New HashUtilities()\n    Return hu.stringToBytes(passedStr)\nEnd Function</code></pre>"},{"location":"howto/extensions/hash.html#converting-a-byte-array-to-a-string","title":"Converting a Byte array to a String","text":"<p>Converting a byte array to a string is a little more complex. We need to know whether to expect hexadecimals when converting the byte array. This is the second argument passed to the function:</p> <pre><code>Function convertStringToBytes(passedStr as String) as Variant\n    Dim hu as New HashUtilities()\n    Return hu.stringToBytes(passedStr)\nEnd Function</code></pre>"},{"location":"howto/extensions/hash.html#base64","title":"Base64","text":"<p>Some content may be received or need to be posted as Base64. Base64 encoding can be used to convert form data or JSON to a shorter string with restricted URL-safe character set. There are APIs in WebVSE to encode and decode Base64 HTTP data. But HashVSE also provides APIs for Base64 operations.</p>"},{"location":"howto/extensions/hash.html#encoding-to-base64","title":"Encoding to Base64","text":"<p>The following code can be used to convert a string to a Base64 encoded string:</p> <pre><code>Function base64Encode(passedStr as String) as String\n    Dim hu as New HashUtilities()\n    Return hu.base64Encode(passedStr)\nEnd Function</code></pre>"},{"location":"howto/extensions/hash.html#decoding-from-base64","title":"Decoding from Base64","text":"<p>The following code can be used to convert a Base64 encoded string to a string:</p> <pre><code>Function base64Decode(base64Str as String) as String\n    Dim hu as New HashUtilities()\n    Return hu.base64Decode(base64Str)\nEnd Function</code></pre>"},{"location":"howto/extensions/hash.html#encoding-a-byte-array-to-base64","title":"Encoding a Byte array to Base64","text":"<p>To encode a byte array, we first need to convert the string to bytes, which we have already covered. Once we have that, converting to a Base64-encoded string is straightforward:</p> <pre><code>Function base64ByteEncode(tempVal as Variant) as String\n    Dim hu as New HashUtilities()\n    Return hu.base64EncodeB(tempVal)\nEnd Function</code></pre>"},{"location":"howto/extensions/hash.html#decoding-from-base64-to-a-byte-array","title":"Decoding from Base64 to a Byte array","text":"<p>The following code can be used to convert a Base64 encoded string to a byte array:</p> <pre><code>Function base64ByteDecode(base64Str as String) as Variant\n    Dim hu as New HashUtilities()\n    Return hu.base64DecodeB(base64Str)\nEnd Function</code></pre> <p>In our round-tripping example, the starting string was not hexified when converted to Base64, so to convert it back to a string, we can use the function we have already covered.</p>"},{"location":"howto/extensions/hash.html#sha-hashes","title":"SHA hashes","text":""},{"location":"howto/extensions/hash.html#converting-strings-to-sha-hashes","title":"Converting strings to SHA hashes","text":"<p>Converting a string to a SHA-hashed string just requires calling the function for the relevant SHA variant:</p> <pre><code>Sub convertSHA(inputStr as String, output1 as String, output256 as String,_\n    output512 as String)\n    Dim hu as New HashUtilities()\n    output1 = hu.SHA1(inputStr)\n    output256 = hu.SHA256(inputStr)\n    output512 = hu.SHA512(inputStr)\nEnd Sub</code></pre>"},{"location":"howto/extensions/hash.html#converting-byte-arrays-to-sha-hashes","title":"Converting byte arrays to SHA hashes","text":"<p>If you have byte arrays instead of strings, there are functions for converting those too:</p> <pre><code>Sub convertSHABytes(inputStr as Variant, output1 as Variant, output256 as Variant,_\n    output512 as Variant)\n    Dim hu as New HashUtilities()\n    output1 = hu.SHA1B(inputStr)\n    output256 = hu.SHA256B(inputStr)\n    output512 = hu.SHA512B(inputStr)\nEnd Sub</code></pre> <p>Bear in mind that SHA functions generate hexadecimal bytes, so to convert them to a string, you will need to pass <code>True</code> as the second argument, for example <code>hu.bytesToString(output1B, True)</code>.</p>"},{"location":"howto/extensions/hash.html#md5-hashes","title":"MD5 Hashes","text":"<p>When manually downloading files, it's common to compare the MD5 hash of the file to an expected value. <code>HashUtilities</code> provides the ability to generate MD5 hashes of strings, byte arrays or files.</p>"},{"location":"howto/extensions/hash.html#md5-hash-of-string","title":"MD5 hash of string","text":"<p>The following code can be used to generate an MD5 hash of a string:</p> <pre><code>Function convertMD5(inputStr as String) as String\n    Dim hu as New HashUtilities()\n    Return hu.MD5(inputStr)\nEnd Function</code></pre>"},{"location":"howto/extensions/hash.html#md5-hash-of-byte-array","title":"MD5 hash of byte array","text":"<p>The following code can be used to generate an MD5 hash of a byte array:</p> <pre><code>Function convertMD5Bytes(inputBytes as Variant) as Variant\n    Dim hu as New HashUtilities()\n    Return hu.MD5B(inputBytes)\nEnd Function</code></pre> <p>Bear in mind that MD5 hashing generates hexadecimal bytes, so to convert the byte array to a string, you will need to pass <code>True</code> as the second argument, for example <code>hu.bytesToString(returnVal, True)</code>.</p>"},{"location":"howto/extensions/hash.html#md5-hashes-of-files","title":"MD5 hashes of files","text":"<p>The following code can be used to generate an MD5 hash from a file, by passing the filepath:</p> <pre><code>Function convertFileMD5() as String\n    Dim hu as New HashUtilities()\n    Return hu.FileMD5(CurDir &amp; \"/samples/lorem.txt\")\nEnd Function</code></pre> <p>A similar function can be used to return a byte array:</p> <pre><code>Function convertFileMD5Bytes() as Variant\n    Dim hu as New HashUtilities()\n    Return hu.FileMD5B(CurDir &amp; \"/samples/lorem.txt\")\nEnd Function</code></pre> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/input.html","title":"Receive input","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/input.html#introduction","title":"Introduction","text":"<p>There may be common occasions where you need to receive input. This can either be received via the command line <code>--context</code> argument or STDIN. Dependency management uses both of these, passing an argument (\"setup\" or \"installDeps\") for the process to run and prompting the user for parameters to run against. Command line arguments are best for simple, short text. For example, double quotes need escaping and may affect what VoltScript reads. JSON content should only ever be passed via STDIN.</p>"},{"location":"howto/extensions/input.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating StreamVSE and ContextVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"StreamVSE\": {\n            \"library\": \"StreamVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"streamvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        },\n        \"ContextVSE\": {\n            \"library\": \"ContextVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"contextvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>Note</p> <p>For more comprehensive documentation and further details about API parameters, see StreamVSE and ContextVSE documentation.</p>"},{"location":"howto/extensions/input.html#pass-context","title":"Pass Context","text":"<p>The Visual Studio Code \"VoltScript: Save &amp; Run Script\" command always prompts for command line parameters to be passed to the underlying script using an input box. The following code can capture context passed in via the <code>--context</code> command line parameter:</p> <pre><code>Sub Initialize\n\n    Dim ctx as New Context()\n    Print \"Received contextual string: \" &amp; ctx.Context\n\nEnd Sub</code></pre> <p>You can run this script from VS Code by using the \"VoltScript: Save &amp; Run Script\" command and, when prompted, enter, for example <code>--context \"Hello\"</code>. Alternatively, you can run from the terminal in VS Code using <code>VoltScript --context \"Hello World\" src/echoContext.vss</code>.</p> <p>Warning</p> <p>There is limitations passing contextual content via command line. Visual Studio Code cannot accept spaces, on command line double quotes need escaping. For any complex or unpredictable input, StreamVSE is the recommended approach.</p>"},{"location":"howto/extensions/input.html#use-streamvse-and-stdio","title":"Use StreamVSE and STDIO","text":"<p>To receive input from standard input and output (STDIO) via StreamVSE, a stream must be connected to that input stream. This is done by calling <code>.open()</code> with a specific pair of arguments - <code>(\"\", \"STDIO\")</code>. This is understood by the API to read content via standard input (stdin) and write to standard out (stdout).</p> <p>As with streaming files, <code>readText()</code> and <code>writeText()</code> are used to interact with STDIO. When reading input, the second parameter for timeout is important to bear in mind, otherwise the program will hang waiting for input. When input is complete, it is crucial to close the stream to tell StreamVSE not to wait for further input.</p>"},{"location":"howto/extensions/input.html#close-stream-on-specific-input","title":"Close stream on specific input","text":"<p>Identifying when input is completed will depend on the method of interaction. For example, when interacting with a user via command line, you can prompt for a specific input.</p> <pre><code>Sub echoMessagesUntilQuit()\n    Dim pipestream as New Stream()\n    Dim continue as Boolean\n    Dim data as String\n\n    Call pipestream.open(\"\", \"STDIO\")\n    continue = true\n    Call pipeStream.writeText(\"Enter quit or q to end interaction\", EOL_LF)\n    Do While Continue\n        data = pipeStream.readText(true, 4, 5)\n        Select Case data\n        Case \"quit\", \"q\":\n            continue = False\n        Case \"\":\n            Call pipeStream.writeText(\"I didn't head anything\", EOL_LF)\n        Case Else:\n            Call pipeStream.writeText(\"You entered: \" &amp; data, EOL_LF)\n        End Select\n    Loop\n    Call pipeStream.close()\n    Print \"Thank you\"\nEnd Sub</code></pre>"},{"location":"howto/extensions/input.html#close-stream-when-iseos","title":"Close stream when isEOS","text":"<p>The stream does not end with each input, instead it's kept open until explicitly closed. <code>Ctrl + D</code> is the way from the command line to signal to the waiting program that the stream is ended.</p> <pre><code>Sub echoMessagesUntilEOS()\n    Dim pipestream as New Stream()\n    Dim continue as Boolean\n    Dim data as String\n\n    Call pipestream.open(\"\", \"STDIO\")\n    Print \"Press CTRL + Z on Windows, Ctrl + D on everything else to end interaction\"\n    Do While Not pipeStream.isEOS\n        data = pipeStream.readText(true, 4, 5)\n        Select Case data\n        Case \"\":\n            Print \"I didn't head anything\"\n        Case Else:\n            Print \"You entered: \" &amp; data\n        End Select\n    Loop\n    Call pipeStream.close()\n    Print \"Thank you\"\nEnd Sub</code></pre> <p>Note</p> <p><code>Print</code> can also be used to write to standard out. <code>Print</code> automatically appends a line feed after it prints.</p>"},{"location":"howto/extensions/input.html#stdio-from-external-programs","title":"STDIO from external programs","text":"<p>Programs that start an external process can typically programmatically send an \"end of stream\" notification. This is the case with Java with the <code>ProcessBuilder</code> class.</p>"},{"location":"howto/extensions/input.html#java-processbuilder","title":"Java ProcessBuilder","text":"<p>Java has the <code>ProcessBuilder</code> API which allows triggering an external process. This also allows writing to the process's standard output and reading content from the process's standard input. It can also programmatically send an \"end of stream\" message.</p> <pre><code>// Set up variables with path to the VoltScript executable and to the .vss script file to run\n// Your code will also need to handle IOException and InterruptedException\npublic static void runVoltScript(String pathToVoltScript, String scriptFile) throws IOException, InterruptedException {\n    ProcessBuilder procBuilder = new ProcessBuilder(pathToVoltScript, scriptFile);\n    // Optionally set procBuilder.directory() to the working directory to use, i.e. directory for VoltScript\n    procBuilder.redirectErrorStream(true);   // (1)!\n    Process proc = procBuilder.start();\n\n    OutputStream stdin = proc.getOutputStream();\n    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(stdin));\n    writer.write(\"Some text to pass\");   // Repeat for all content to pass\n    writer.flush();\n    writer.close();     // (2)!\n    List&lt;String&gt; errors = readOutput(proc.getErrorStream());\n    int exitCode = proc.waitFor();  // (3)!\n\n    List&lt;String&gt; response = readOutput(proc.getInputStream());\n    // Do something with the response\n}\n\n// Read print statements etc from VoltScript\nprivate static List&lt;String&gt; readOutput(InputStream inputStream) throws IOException {\n    try (BufferedReader output = new BufferedReader(new InputStreamReader(inputStream)))) {\n        return output.lines().collect(Collectors.toList());\n    }\n}\n</code></pre> <ol> <li>To capture errors as STDOUT of the process</li> <li>Will trigger Stream.isEOS</li> <li>Wait for VoltScript to finish</li> </ol> <p>The code uses a <code>ProcessBuilder</code> to run the VoltScript process, effectively running <code>VoltScript _scriptFile_</code>, when the process is started on line 8. The error stream for the VoltScript process is routed to the process (via the <code>ProcessBuilder</code>) on line 7, via which errors can be read on line 14.</p> <p>The Java program's STDOUT (the STDIN into VoltScript) is accessed in lines 9 and 10. Content is written in line 11, the writer flushed in line 12 and closed in line 13 to end the stream.</p> <p>After waiting for the VoltScript process to finish on line 15, the response is read by getting the STDOUT of VoltScript, the Java program's STDIN from the process, on line 17.</p>"},{"location":"howto/extensions/input.html#process-input-in-voltscript","title":"Process input in VoltScript","text":"<p>In the Java example, the stream is explicitly closed. Thus, the content can be captured using:</p> <pre><code>Dim data as String\nDo While Not pipeStream.isEOS\n    data = data &amp; pipestream.readText(true, 4, 5)\nLoop</code></pre> <p>This will exit the loop when <code>writer.close()</code> is called in Java.</p> <p>Best practice for subsequent processing is to pass the <code>data</code> string variable to a subsequent function. This enables the developer to unit test or troubleshoot based on a specific input.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/json.html","title":"JSON Parsing","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/json.html#introduction","title":"Introduction","text":"<p>JsonVSE provides functionality to convert strings or files of JSON into JSON objects, which can then be parsed. VoltScript JSON Converter uses JsonVSE to convert to and from VoltScript objects. In some cases, parsing the JSON objects may be preferable.</p>"},{"location":"howto/extensions/json.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating JsonVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"JsonVSE\": {\n            \"library\": \"JsonVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"jsonvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*JsonVSE\"</code>.</p>"},{"location":"howto/extensions/json.html#jsonparser-class","title":"JsonParser class","text":"<p>The JsonParser class is used to generate a JSON object from a string or file content.</p>"},{"location":"howto/extensions/json.html#parse-json-strings","title":"Parse JSON strings","text":"<p>Parsing JSON strings is done using <code>loadFromJson()</code>:</p> <pre><code>Function parseJsonString(json as String) as JsonObject\n\n    Dim parser as New JsonParser()\n    Call parser.loadFromJson(json)\n    Return parser.getRootObject\n\nEnd Function</code></pre> <p>If a string is passed that is not valid JSON, an error will be returned, error 400. The error message will be \"Must supply a valid JSON string\" followed by the invalid JSON. You canb validate the string before parsing it by using <code>parser.isValidJSON(json)</code>.</p>"},{"location":"howto/extensions/json.html#parse-json-files","title":"Parse JSON files","text":"<p>Parsing JSON files is done with <code>loadFromFile()</code>, passing the path.</p> <pre><code>Function parseJsonFile(fileName as String) as JsonObject\n\n    Dim parser as New JsonParser()\n    Call parser.loadFromFile(CurDir &amp; \"/\" &amp; fileName)\n    Return parser.getRootObject\n\nEnd Function</code></pre> <p>If the file isn't found at the location specified, an error will be returned, error 404. The error message will be \"File could not be opened\" plus the path that was tried.</p> <p>If the file does not contain valid JSON, an error will be returned, error 400. The error message will be \"JSON text is not valid\".</p>"},{"location":"howto/extensions/json.html#parse-json-objects","title":"Parse JSON objects","text":"<p>The <code>JsonObject</code> class is used to hold scalar values, arrays, or other JSON objects, which may contain scalar values, arrays or other JSON objects.</p>"},{"location":"howto/extensions/json.html#capture-types","title":"Capture types","text":"<p>Verifying the type of a JSON object is used with boolean \"is...\" functions or <code>JsonType</code> property, which returns a lower-case string. So the following code can output type and a number corresponding to type.</p> <pre><code>Function checkJsonType(jsonObj as JsonObject, label as String) as String\n    Dim child as jsonObject\n    Dim resp as String\n    Dim count as Integer\n\n    Set child = jsonObj.getChild(label)\n    resp = child.JsonType &amp; \" \"\n    If child.isNumber() Then count += 1\n    If child.isObject() Then count += 2\n    If child.isScalar() Then count += 4\n    If child.isString() Then count += 8\n    If child.isArray() Then count += 16\n    If child.isBoolean() Then count += 32\n    Return resp &amp; count\n\nEnd Function</code></pre> <p>Warning</p> <p><code>.getChild()</code> will throw an error code 404, \"Child JSON not found\" if there is no child matching the passed label.</p>"},{"location":"howto/extensions/json.html#verify-existence","title":"Verify existence","text":"<p>Unless dealing with static JSON, it's always advisable to verify elements can be found before trying to parse them. At a single level, this can be done with <code>isChild()</code>. At lower levels, this can be done in two ways. Firstly by using an array of strings. <code>isDescendant()</code> returns a boolean for existence, <code>findObjectByPath()</code> can return the actual object and returns <code>Nothing</code> if no object can be found at the path.</p> <pre><code>    Call testSuite2.describe(\"Check address is child\").assertTrue(jsonObj.isChild(\"address\"))\n    Dim path(1) as String\n    path(0) = \"address\"\n    path(1) = \"add1\"\n    Call testSuite2.describe(\"Check address/add1 can be found\").assertTrue(jsonObj.isDescendant(path))\n    path(1) = \"add3\"\n    Call testSuite2.describe(\"Check address/add3 can't be found\").assertFalse(jsonObj.isDescendant(path))\n    Call testSuite2.describe(\"Check address/add3 can't be found\").assertFalse(jsonObj.isDescendantPath(\"address/add3\"))\n    Dim actualObj as JsonObject\n    Call testSuite2.describe(\"Find address/add2\").assertTrue(actualObj Is Nothing)\n    Set actualObj = jsonObj.findObjectByPath(path)\n    Call testSuite2.describe(\"Find address/add2\").assertTrue(Not actualObj Is Nothing)</code></pre> <p>Alternatively it can be done with a string and delimiter. <code>isDescendantPath()</code> returns a boolean for existence, <code>getDescendantPath()</code> can return the actual object and returns <code>Nothing</code> if no object can be found at the path.</p> <pre><code>    Call testSuite2.describe(\"Check address/add1 can be found as a string\").assertTrue(jsonObj.isDescendantPath(\"address/add1\"))\n    Call testSuite2.describe(\"Check address/add3 can't be found as a string\").assertFalse(jsonObj.isDescendantPath(\"address/add3\", \"/\"))\n    Set actualObj = jsonObj.getDescendantPath(\"address,add2\", \",\")\n    Call testSuite2.describe(\"Find address/add2 as a string\").assertTrue(Not actualObj Is Nothing)</code></pre> <p>Note</p> <p>The methods take an optional parameter for the delimiter, defaulting to \"/\" if nothing is passed. This is because \"/\" is a valid character in a JSON string literal. This allows your string to use a different character as the delimiter to avoid incorrect splitting.</p> <p>Warning</p> <p>Finding by descendant path as a string will only navigate to a maximum of three levels. This is by design to minimise performance impact. But remember this method is available on any JSON object, not just the root JSON object.</p>"},{"location":"howto/extensions/json.html#return-values","title":"Return values","text":"<p>For JSON objects that are scalars, the value can be returned using <code>scalarValue</code> property.</p> <p><code>getChildren()</code> is preferred to process arrays, as a consistent approach that will work for scalar and object arrays. Each element will be a JsonObject, so <code>scalarValue</code> will be required to get the value. Alternatively, if you are certain they are scalars, <code>valueArray</code> property will return a Variant array.</p>"},{"location":"howto/extensions/json.html#troubleshoot-values","title":"Troubleshoot values","text":"<p>For any JsonObject <code>toString()</code> can be used to return the full JSON object as a string, pretty-printed if the argument passed is <code>True</code>, as compact JSON if <code>False</code>. Alternatively, for swift debugging purposes, the <code>shortValue</code> property will return a maximum 16 characters.</p> <p>Note</p> <p>VoltScript Testing can be used to validate the JSON object before processing. If you set <code>suppressReport = True</code> on the TestSuite, you can check <code>ranSuccessfully()</code> to verify if the JSON object was successfully validated or not.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/memory-stream.html","title":"In-memory streaming","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/memory-stream.html#introduction","title":"Introduction","text":"<p>Reading and writing to files is useful. But in-memory processing is typically quicker because it removes the disk I/O interaction. In-memory streams are designed as a more performant approach than string concatenation.</p>"},{"location":"howto/extensions/memory-stream.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating StreamVSE and ContextVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"StreamVSE\": {\n            \"library\": \"StreamVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"streamvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre>"},{"location":"howto/extensions/memory-stream.html#processing-streams-in-memory","title":"Processing streams in memory","text":"<p>To create an in-memory stream, open the stream with either \"MEMORY\" or \"BUFFER\" as the character set.</p> <pre><code>Dim stream as new Stream()\nCall stream.open(\"\", \"MEMORY\")</code></pre> <p>Note</p> <p>\"MEMORY\" and \"BUFFER\" are provided as keyword synonyms and either can be used. This replaces the character set because in-memory streams are always stored with UTF-16 character set.</p> <p>Writing to the stream is then performed as usual, with either <code>writeBytes()</code> or <code>writeText()</code>.</p>"},{"location":"howto/extensions/memory-stream.html#converting-person-objects-to-csv","title":"Converting person objects to CSV","text":"<p>For example, consider you have an array of Person objects and want to write the details out as a CSV file.</p> <p>If you wish to store the CSV on a filesystem, this could be written directly to disk, but this would require constant file access during the process and multiple disk I/O interactions. Writing to an in-memory stream and outputting the complete stream in a single call may be preferable. And if you wish to send the CSV content as a file from a REST API, in-memory processing removes the need to write to and clean up temp files.</p> <p>The code for writing to the stream will be familiar from other StreamVSE interactions:</p> <pre><code>Sub convertPeopleToCsv(stream as Stream, people As Variant)\n\n    Dim personObj as Person\n    Call stream.writeText(\"Name,Age\", EOL_CRLF)\n\n    ForAll person In people\n        Set personObj = person\n        Call stream.writeText(personObj.getName() &amp; \",\" &amp; personObj.getAge(), EOL_CRLF)\n    End ForAll\n\nEnd Sub</code></pre> <p>The header is written. A <code>Forall</code> loop is used to iterate over the variant array. Because we are calling methods on the object, we need to cast the variant <code>person</code> to an instance of the <code>Person</code> class. Then we write out its properties.</p>"},{"location":"howto/extensions/memory-stream.html#retrieving-content-from-the-stream","title":"Retrieving content from the stream","text":"<p>To print out the contents of the stream, we use the following code:</p> <pre><code>stream.position = 0\nPrint stream.readText()\nCall stream.close()</code></pre> <p>We need to reset the position to the beginning of the stream, character position 0. We can then read out either the full content or sized chunks, either as text or as bytes.</p> <p>Danger</p> <p>If you do not call <code>stream.position = 0</code> before reading the text, you will get no output. This is because you're only reading content after the position at which you finished writing.</p> <p>Note</p> <p>Another use case might be writing activity logs during process. VoltScript logging is intended for building up logs at various log levels and controlling at runtime which logs get written and to where. But if you always want to write out information for auditing purposes, in-memory streams can be a good option. The content can then be written out in the <code>Finally</code> block of your main routine.</p>"},{"location":"howto/extensions/read-files.html","title":"Read and write files","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/read-files.html#introduction","title":"Introduction","text":"<p>There may be common occasions where you need to interact with the filesystem to read or write files and manipulate directories. OSUtilsVSE allows you to interact with the filesystem and StreamVSE allows you to stream data to and from files.</p>"},{"location":"howto/extensions/read-files.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating OSUtilsVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"StreamVSE\": {\n            \"library\": \"StreamVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"streamvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre>"},{"location":"howto/extensions/read-files.html#file-handling","title":"File handling","text":""},{"location":"howto/extensions/read-files.html#open-or-create-a-file","title":"Open or create a file","text":"<p>There is no separate API for creating a file using StreamVSE, the same API is used for creating or opening the file. If the file exists at the filepath, it's opened for appending. If the file doesn't exist, it's created. However, no file is saved unless data is written to it.</p> <p>An error will be generated if the file can't be opened. Typical causes may be creating a file in a directory that doesn't exist, creating a file in a read-only directory, or opening a file you don't have access to.</p> <pre><code>Function createFile(stream as Stream, filePath as String) as Boolean\n    Try\n        Call stream.open(filePath, \"UTF-8\")\n        Return True\n    Catch\n        Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n        Return False\n    Finally\n        If (stream.isOpen) Then\n            Call stream.close()\n        End If\n    End Try\nEnd Function</code></pre> <p>Whenever you open a file, the stream's <code>Position</code> will always be 0 regardless of whether or not the file already had content.</p>"},{"location":"howto/extensions/read-files.html#write-to-a-file","title":"Write to a file","text":"<p>Writing appends to a file and can take bytes or text, up to 2 GB. You can also pass a type of line-ending, for which there are constants available in StreamVSE. The default is to write the text without appending any kind of line break. The following code will write the passed text with a line-feed.</p> <pre><code>Function writeToFile(stream as Stream, text as String) as Boolean\n    Call stream.writeText(text, EOL_LF)\n    call stream.writeNewLine(EOL_LF)\nEnd Function</code></pre>"},{"location":"howto/extensions/read-files.html#read-from-existing-file","title":"Read from existing file","text":"<p>There are <code>read...</code> functions corresponding to the <code>write...</code> functions. <code>readText()</code> can be used to read the whole file (up to 2 GB) or an individual line. This code would read a while file and pass it into a string:</p> <pre><code>Function readWholeFile(stream as Stream) as String\n    Return stream.readText()\nEnd Function</code></pre> <p>When reading line-by-line you can specify the line ending to look for, using <code>EOL_ANY</code> to match any type of line ending. However, bear in mind that the text returned does not include any line ending. So if you are wishing to construct the full text, you will need to append a line ending manually:</p> <pre><code>Function readFromFile(stream as Stream) as String\n    Dim retVal as String\n    While Not stream.isEOS\n        retVal = retVal &amp; stream.readText(True, EOL_ANY) &amp; Chr(10)\n    Wend\n    Return retVal\nEnd Function</code></pre> <p>Warning</p> <p>Remember to close the stream when reading or writing has been completed. This is a perfect use case for the <code>Try...Finally</code>. Use <code>Stream.isOpen()</code> to ensure the stream was successfully opened, otherwise an error will be thrown.</p> <p>Note</p> <p>StreamVSE can only be used to append to a file. If you wish to replace the contents, delete the file using <code>Kill</code> and then use StreamVSE to create the file.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/web.html","title":"Make HTTP REST JSON Requests","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p> <p>Note</p> <p>For specific details of APIs, see API Docs</p>"},{"location":"howto/extensions/web.html#introduction","title":"Introduction","text":"<p>Although REST doesn't have to be over HTTP or transfer content as JSON, typically this is the case. This how-to covers this typical use case and requires the use of two VoltScript Extensions, which are WebVSE and JsonVSE.</p>"},{"location":"howto/extensions/web.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating WebVSE and JsonVSE is straightforward. You just need to add the following JSON objects to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"WebVSE\": {\n            \"library\": \"WebVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"webvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        },\n        \"JsonVSE\": {\n            \"library\": \"JsonVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"jsonvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*JsonVSE\"</code> and <code>UseVSE \"*WebVSE\"</code>.</p>"},{"location":"howto/extensions/web.html#webserver-object","title":"WebServer object","text":"<p>The WebServer is the entrypoint for HTTP requests via WebVSE and is instantiated using the <code>New</code> constructor. Unlike other internally-focussed extensions (DrapiVSE and CouchVSE), <code>WebServer</code> permits defining proxy settings as properties. Proxy servers aren't currently supported, VPN access is recommended.</p> <p>If making multiple requests to the same base URL, you can re-use the same <code>WebServer</code> instance.</p> <pre><code>Private server as WebServer\n\nFunction getWebServer() as WebServer\n    If (server is Nothing) Then\n        Set server = new WebServer()\n        server.protocol = \"HTTPS\"\n        server.HostUrl = \"httpstat.us\"\n    End If\n    Return server\nEnd Function</code></pre> <p>The <code>HostURL</code> shouldn't include the protocol and may just be the hostname of the server (for example \"google.com\") or may be to a more specific URL (for example \"api.github.com/orgs/hcl-tech-software\"). The <code>HostURL</code> shouldn't end with a path separator (\"/\").</p>"},{"location":"howto/extensions/web.html#ssl-certificate-handling","title":"SSL Certificate Handling","text":"<p>To use HTTPS, the web-based extensions expect a properly verifiable SSL certificate. For well-known sites, these may be loaded by your operating system.</p> <p>For sites with self-signed certificates WebVSE has an option to disable this with <code>WebServer.SSLHostValidationOn = False</code>. This is equivalent to the libcurl command <code>curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);</code> or the curl command line option <code>-k/--insecure</code>.</p> <p>It's the responsibility of the systems administrator to ensure the relevant self-signed certificates are in the relevant cert store or, for Windows, appended to the curl-ca-bundle.crt in VoltScript executable directory.</p> <p>Alternatively, <code>WebServer.certificatePath</code> property can be passed a path to a specific self-signed certificate.</p>"},{"location":"howto/extensions/web.html#cookies","title":"Cookies","text":"<p>Although REST APIs are intended to be stateless, certain web interactions may require persisting of cookies between requests. This can be done by setting <code>PreserveCookies=True</code>.</p>"},{"location":"howto/extensions/web.html#encoding-decoding-url-content","title":"Encoding / Decoding URL content","text":"<p>When including content from variables, for example for including in querystring parameters, it can include invalid content, such as \" \", \"/\". The receiving web server will require these values to be URL encoded. The <code>WebServer</code> class provides utility functions to URL encode and decode strings - <code>WebServer.URLEncode()</code> and <code>WebServer.URLDecode()</code>, each taking a string to encode / decode.</p> <p>Note</p> <p>When sending a request, the URL is automatically encoded. So there is no need to additionally call WebServer.URLEcode(). To troubleshoot, you can use WebServer.URLEncode to find out what the value would be encoded as. But the better practice approach is to use <code>WebServer.verboseLogging = True</code>. See Troubleshooting.</p> <p>Warning</p> <p>Spaces are encoded to \"%20\". If the server you are sending to requires \"+\" instead, use <code>Replace(url, \" \", \"+\")</code>. Encoding will not re-encode the \"+\".</p>"},{"location":"howto/extensions/web.html#webrequest","title":"WebRequest","text":"<p>The <code>WebRequest</code> class handles a single specific request to a specific endpoint on a REST API or web server. The key parts of a web request are target URL, a verb (e.g. \"GET\", \"POST\"), one or more HTTP headers, cookies, potentially a request body and timeout.</p>"},{"location":"howto/extensions/web.html#basic-request","title":"Basic request","text":"<p>The default verb for a request is \"GET\". So the most basic request will just need a target URL. Defining <code>timeoutSeconds</code> is recommended for best practice. This will be appended, after a \"/\", to the <code>WebServer</code>'s HostURL.</p> <pre><code>Function makeBasicRequest() as WebResponse\n    Dim request as WebRequest\n\n    Set request = getWebServer().createRequest()\n    request.target = \"200\"\n    request.timeoutSeconds = 5\n    Return request.send()\nEnd Function</code></pre> <p>The request is sent to:</p> Property Value WebRequest.Verb GET (default value) WebServer.Protocol HTTPS WebServer.HostURL httpstat.us / WebRequest.Target 418 <p>The full request is GET https://httpstat.us/418, equivalent to the curl command:</p> <pre><code>curl --location 'https://httpstat.us/418'\n</code></pre>"},{"location":"howto/extensions/web.html#http-headers","title":"HTTP headers","text":"<p>There are helper properties for common headers:</p> <ul> <li><code>ContentType</code> for data type of data being sent, for example \"application/json\"</li> <li><code>AcceptHeader</code> for expected return data type, for example \"application/json\"</li> <li><code>AuthorizationHeader</code> for credentials beginning with type, for example \"Basic \", \"Bearer \".</li> </ul> <p>Additional headers can be added through <code>AddHeader()</code>.</p> <p>Content can be sent for PUT, PATCH, or POST requests via <code>RequestBody</code> property.</p> <p>A sample request for a POST, with JSON body content and custom headers would be:</p> <pre><code>Function makeJsonRequest() as WebResponse\n    Dim request as WebRequest\n\n    Set request = getWebServer().createRequest()\n    request.Verb = \"PUT\"\n    request.ContentType = \"application/json\"\n    request.AcceptHeader = \"application/json\"\n    Call request.addHeader(\"X-HttpStatus-Response-Foo\", \"Bar\")\n    request.target = 418\n    request.timeoutSeconds = 5\n    request.RequestBody = |{\"hello\":\"world\"}|\n    Return request.send()\nEnd Function</code></pre>"},{"location":"howto/extensions/web.html#encode-body-content","title":"Encode body content","text":"<p>In some cases, for example when sending images or sending basic authentication credentials, content may need to be Base64 encoded. This can be done via the utility function <code>WebRequest.Base64Encode()</code>, which will return the encoded value.</p>"},{"location":"howto/extensions/web.html#file-uploading-and-downloading","title":"File uploading and downloading","text":"<p>File uploading and downloading can be done synchronously or asynchronously. When performed synchronously, it returns a <code>WebResponse</code> object corresponding to the response. When performed asynchronously, it returns a <code>Completion</code> object.</p> <p><code>Completion</code> objects have an <code>IsComplete</code> property which can be polled periodically, for example in a loop with a <code>Sleep</code> function. It also has a <code>CompletionCode</code> property for determining success or failure. </p> <p>Once completed it also has a <code>WebResponse</code> object to check the response.</p> <p>Note</p> <p>If the response code is not 200, no file will be created. If file file length is 0 bytes, again, no file will be created. The <code>WebResponse</code> can be interrogated for either problem - <code>WebResponse.responseCode</code> will give the numeric response code, <code>WebResponse.ContentLength</code> will give the size of the response.</p>"},{"location":"howto/extensions/web.html#create-a-webrequest-with-urlbuilder","title":"Create a WebRequest with URLBuilder","text":"<p>Building the URL manually from strings may not be a preferable approach. The <code>URLBuilder</code> class provides functionality to build a URL and pass it to a <code>WebServer</code>.</p> <pre><code>Function makeRequestFromUrlBuilder() as WebResponse\n    Dim server as New WebServer()\n    Dim request as WebRequest\n    Dim builder as New UrlBuilder()\n\n    builder.isHttps = True\n    builder.targetHost = \"httpstat.us\"\n    builder.targetPath = \"200\"\n    Call builder.addUrlParameter(\"sleep\", \"1000\")\n    Set request = server.createRequestWithUrl(builder.toString(False)) '(1)!\n    request.timeoutSeconds = 5\n    Return request.send()\nEnd Function</code></pre> <ol> <li><code>toString()</code> parameter is for whether or not to URL encode the URL.</li> </ol> <p>Note</p> <p>When using <code>URLBuilder.toString()</code> with multiple URL parameters, they're outputted in alphabetical order.</p>"},{"location":"howto/extensions/web.html#webresponse","title":"WebResponse","text":"<p>The <code>WebResponse</code> object is the result of a <code>WebRequest.send()</code> or file upload / download. It contains all information relating to the web server's response to your request. <code>ContentType</code> contains the data type of data received, for example  \"application/json\". <code>ContentLength</code> can be checked for the size of the response as a Long in bytes. <code>AllHeaders</code> and <code>AllCookies</code> properties give string arrays of headers and cookies.</p>"},{"location":"howto/extensions/web.html#query-response-code","title":"Query response code","text":"<p><code>WebResponse.ResponseCode</code> gives the HTTP response code. These fall into five groups:</p> <ul> <li>0 bad URL, for example invalid port number, and the request cannot be sent.</li> <li>1xx informational response while additional processing continues.</li> <li>2xx successful - the request was successfully received, understood, and accepted.</li> <li>3xx redirection - additional action needs to be taken to complete the request.</li> <li>4xx client error - you have sent incorrect or insufficient information, your request needs amending.</li> <li>5xx server error - the recipient has encountered some unexpected error. This may include unanticipated bad data in your request.</li> </ul> <p>It's recommended to test the response code and act accordingly:</p> <pre><code>Function validateResponseCode(responseCode as Integer) as Boolean\n    Dim request as WebRequest\n    Dim response as WebResponse\n\n    Set request = getWebServer().createRequest()\n    request.target = \"418\"\n    Set response = request.send()\n    Return response.responseCode = 200\nEnd Function</code></pre> <p>Warning</p> <p>Some servers send a 200 response even for invalid URLs, for example returning an HTML page with status 200 if valid authentication is required (401, 403) or the resource is unavailable (404). You will need to be aware of this and handle accordingly.</p>"},{"location":"howto/extensions/web.html#process-json-response","title":"Process JSON response","text":"<p><code>ContentBody</code> is always a string. In some cases, this may be a string of JSON. It's always recommended to verify. But such content can be easily parsed using JsonVSE.</p> <pre><code>Function parseResponse(json as String) as JsonObject\n    Dim parser as New JsonParser()\n    Dim obj as JsonObject\n\n    Call parser.loadFromJSON(json)\n    Return parser.getRootObject\nEnd Function</code></pre> <p>Note</p> <p>The sending server may encode characters, for example apostrophe as \"\\u0027\". Loading into a JSON object will convert this. If in doubt about the response, cross-reference with Postman checking View &gt; Postman Console or Raw tab in the UI. The \"Pretty\" tab does the same conversion that JsonVSE will do.</p>"},{"location":"howto/extensions/web.html#decode-and-request-body-content","title":"Decode and request body content","text":"<p>In some cases, for example when receiving images or parsing cookies/headers, values may be Base64 encoded. These can be decoded via the utility function <code>WebResponse.Base64Decode(string)</code>, which will return the decoded value.</p>"},{"location":"howto/extensions/web.html#troubleshoot-requests-and-responses","title":"Troubleshoot requests and responses","text":"<p>For troubleshooting problems, you can set <code>WebRequest.verboseLogging=True</code>. This will generate a file using the request type (\"Send\", \"DownloadFile\", \"UploadFile\") and a unique key for each request. The file is stored in the project directory. NOTE: This should only be used for troubleshooting, you should not leave verbose logging set in server environments. This cannot be used in Volt Foundry because the project directory is cleaned up after testing requests.</p> <p>Note</p> <p>Bear in mind this will contain credentials, so should be sanitized before sharing with third parties.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/xmlbuilding.html","title":"Build XML","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/xmlbuilding.html#introduction","title":"Introduction","text":"<p>Although the most efficient way of modifying and improving your XML is through parsing, XMLVSE is also designed to allow developers to construct an XML tree from scratch. In this guide, the focus is on writing XML.</p>"},{"location":"howto/extensions/xmlbuilding.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating XMLVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"XmlVSE\": {\n            \"library\": \"XMLVSE VoltScript Extension\",\n            \"version\": \"1.0.3\",\n            \"module\": \"xmlvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*XMLVSE\"</code>.</p>"},{"location":"howto/extensions/xmlbuilding.html#xmlobject-class","title":"XMLObject class","text":"<p>The XMLObject class is used to hold the whole XML tree.</p>"},{"location":"howto/extensions/xmlbuilding.html#construct-xml-objects","title":"Construct XML Objects","text":"<p>To construct an XML from scratch, you need to know the key components that XML is composed of:</p> <ul> <li>Root: the primary and topmost element of an XML</li> <li>Attribute: defines the properties of a specific XML element</li> <li>Child - elements contained inside a specific XML element.</li> </ul> <p>XML elements that have a child or children are called Parent XML elements.</p> <p>To populate your XML from scratch, add a root element using the <code>AddRootTag()</code>. The first parameter is the tag and the second parameter is the value.</p> <p>Note</p> <p>Element values are optional depending on how you want your expected XML to look. You can set it as empty if you want to add another element on your root instead of a string value. In you used <code>AddRootTag()</code> to an XML object that already has a root element, a 404 error occurs. The error message is Current Object needs to be Empty to be able to add a new tag.</p> <p>Once your XMLObject has a root, you can now add Attributes into your XML Object if you want using <code>addAttribute()</code>. The first parameter is the tag and the second parameter is the value.</p> <pre><code>Function buildXML() as XMLObject\n\n    Dim xmlObj as New XMLObject\n\n    Call xmlObj.addRootTag(\"Test\", \"Hello World\")\n    Call xmlObj.addAttribute(\"version\", \"1\")\n\n    Return xmlObj\nEnd Function</code></pre>"},{"location":"howto/extensions/xmlbuilding.html#add-child-elements","title":"Add Child Elements","text":"<p>There are two ways to add Child Elements to your XML. The first way is to use string inputs <code>AddChild()</code> with the first parameter being the tag and the second parameter being the value. The second way is to use another XML Object <code>AddChildObject()</code> with the parameter needing to be an XMLObject.</p> <p>Note</p> <p>For addChild(), element values are optional depending on how you want your expected XML to look. You can set it as empty if you want to add another element on your child element instead of a string value. For AddChildObject(), if the passed parameter isn't an XML object, error 53291 occurs. The error message is Type mismatch on: followed by the supplied input. In case the passed XML Object isn't a valid XML, error 404 occurs. The error message is Child Object is Empty.</p> <pre><code>Function buildXMLWithChildren() as XMLObject\n\n    Dim xmlObj as New XMLObject\n\n    Call xmlObj.addRootTag(\"Test\", \"\")\n    Call xmlObj.addChild(\"Hello\", \"World\")\n\n    Dim ChildObj as New XMLObject\n    Call ChildObj.addRootTag(\"Foo\", \"Bar\")\n\n    Call xmlObj.addChildObject(ChildObj)\n\n    Return xmlObj\nEnd Function</code></pre>"},{"location":"howto/extensions/xmlbuilding.html#remove-elements","title":"Remove Elements","text":"<p>Removing XML Elements is also part of modifying your XML tree. XMLVSE also has methods that you can use to remove certain elements from your XML tree.</p> <ul> <li>To remove attributes, use <code>RemoveAttribute()</code>. The parameter is the attribute tag.</li> <li>To remove a child element, use <code>RemoveChild()</code>. The parameter is the child tag. You can also use <code>RemoveChildObject()</code>to remove a child using an object parameter.</li> </ul> <pre><code>Function removeXMLElements(xmlObj as XMLObject) as XMLObject\n\n    Call xmlObj.removeAttribute(\"version\")\n    Call xmlObj.removeChild(\"Hello\")\n\n    Dim ChildObj as New XMLObject\n    Set ChildObj = xmlObj.getChild(\"Foo\")\n    Call xmlObj.removeChildObject(ChildObj)\n\n    Return xmlObj\nEnd Function</code></pre>"},{"location":"howto/extensions/xmlbuilding.html#return-xml","title":"Return XML","text":"<p>For both XMLParser and XMLObject, you can use <code>ToString()</code> to return the full XML object as a string. If the passed argument is <code>True</code>, a prettified or indented XML is printed. If the passed argument is <code>False</code>, a compact XML is printed.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/xmlparsing.html","title":"XML Parsing","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/xmlparsing.html#introduction","title":"Introduction","text":"<p>The main feature of XMLVSE is to load XML strings or files and convert them to an XML object for parsing. Once parsed, the XML object can now be modified using various XMLVSE functions.</p>"},{"location":"howto/extensions/xmlparsing.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating XMLVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"XmlVSE\": {\n            \"library\": \"XMLVSE VoltScript Extension\",\n            \"version\": \"1.0.3\",\n            \"module\": \"xmlvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*XMLVSE\"</code>.</p>"},{"location":"howto/extensions/xmlparsing.html#xmlparser-class","title":"XMLParser class","text":"<p>The XMLParser class is used to generate an XML object from reading strings or a file content.</p>"},{"location":"howto/extensions/xmlparsing.html#parse-xml-strings","title":"Parse XML strings","text":"<p>To parse an XML string, you need to pass it using the <code>LoadFromXML()</code> method:</p> <pre><code>Function parseXMLString(xml as String) as XMLObject\n\n    Dim parser as New XMLParser()\n    Call parser.loadFromXML(xml)\n    Return parser.getRootXML\n\nEnd Function</code></pre> <p>If the passed string is not valid XML, a 404 error is returned. The error message is Must supply a valid XML string.</p>"},{"location":"howto/extensions/xmlparsing.html#parse-xml-files","title":"Parse XML files","text":"<p>To parse an XML file, you need to pass it using the <code>LoadFromFile()</code> method:</p> <pre><code>Function parseXMLFile(fileName as String) as XMLObject\n\n    Dim parser as New XMLParser()\n    Call parser.loadFromFile(CurDir &amp; \"/\" &amp; fileName)\n    Return parser.getRootXML\n\nEnd Function</code></pre> <p>If the XML file isn't found at the specified path, a 404 error is returned. The error message is File could not be opened: followed by the provided path.</p> <p>If the file does not contain valid XML, a 404 error is returned. The error message is XML file is not a valid XML.</p>"},{"location":"howto/extensions/xmlparsing.html#parse-xml-objects","title":"Parse XML objects","text":"<p>The XMLObject class is used to hold the whole XML tree. You can traverse throughout the XML Tree by diving into a Child Element using <code>GetChild()</code> by providing the specific Tag or step back using <code>GetParent()</code>.</p> <p>You can also get all the child element in an array of XMLObject using <code>GetChildren()</code></p> <pre><code>Sub Initialize\n\n    Dim parser as New XMLParser\n    DIm object as New XMLObject\n    Dim xmlString as String\n\n    xmlString = \"&lt;Profile version='1' publish='2024'&gt;&lt;Employee&gt;John Doe&lt;/Employee&gt;&lt;/Profile&gt;\"\n    Call parser.loadFromXML(xmlString)\n    Set object = parser.getRootXML()\n\n    DIm newObject as New XMLObject\n\n    Set newObject =  object.getChild(\"Employee\")\n    Print newObject.toString(\"true\")\n\n    Set newObject =  object.getParent()\n    Print newObject.toString(\"true\")\n\n    Dim arrayVals as Variant\n    arrayVals =  object.getChildren()\n\n    ForAll child in arrayVals         \n    Set newObject = child\n    Print newObject.Tag() &amp; \" - \" &amp; newObject.Value()\n    End ForAll\n\nEnd Sub</code></pre> <p>Warning</p> <p><code>.GetChild()</code> throws an error code 404, Child XML not found: if there is no child matching the passed label.</p>"},{"location":"howto/extensions/xmlparsing.html#modifying-parsed-xml","title":"Modifying Parsed XML","text":"<p>You can manipulate the parsed XML by modifying the tag and value properties of an XMLObject.</p> <pre><code>Sub Initialize\n\n    DIm object as New XMLObject\n    Dim parser as New XMLParser\n    Dim xmlString as String\n\n    xmlString = \"&lt;Profile version='1' publish='2024'&gt;&lt;Employee&gt;John Doe&lt;/Employee&gt;&lt;/Profile&gt;\"\n    Call parser.loadFromXML(xmlString)\n    Set object = parser.getRootXML()\n\n    object.tag = \"Account\"\n\n    Dim ChildObject as XMLObject\n    Set ChildObject = object.getChild(\"Employee\")\n\n    Call object.removeChildObject(ChildObject)\n\n    ChildObject.tag = \"Manager\"\n    ChildObject.value = \"Jane Doe\"\n\n    Call object.addChildObject(ChildObject)\n\n    print object.toString(True)\n\nEnd Sub</code></pre> <p>In the above sample, the root element tag was updated from <code>Profile</code> to <code>Account</code> and child element tag and value were updated from <code>&lt;Employee&gt;John Doe&lt;/Employee&gt;</code> to <code>&lt;Manager&gt;Jane Doe&lt;/Manager&gt;</code>. <code>GetChild</code> returns a new XMLObject instance separated from the parent object, in this case <code>ChildObject</code>. To update the parent object, remove the child with <code>RemoveChild</code> or <code>RemoveChildObject</code>, then add the modified child to the parent with <code>AddChildObject</code>.</p>"},{"location":"howto/extensions/xmlparsing.html#verify-and-troubleshoot-values","title":"Verify and troubleshoot values","text":"<p>For both XMLParser and XMLObject, you can use <code>ToString()</code> to return the full XML object as a string. If the passed argument is <code>True</code>, a prettified or indented XML is printed. If the passed argument is <code>False</code>, a compact XML is printed.</p> <p>You can also verify the XML existence within the XML Object using the <code>IsEmpty</code> checking.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/zip.html","title":"Process zip files","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/zip.html#introduction","title":"Introduction","text":"<p>VoltScript within Volt Foundry is middleware, where content is downloaded over HTTP and sent to end users over HTTP. The best way to enhance performance for processing this content is using .zip files. ZipVSE has been created for this purpose.</p> <p>Warning</p> <p>The C library that ZipVSE uses can only process <code>.zip</code> files. <code>.tar.gz</code> files can't be written or read.</p>"},{"location":"howto/extensions/zip.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating ZipVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>        \"ZipVSE\": {\n            \"library\": \"ZipVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"zipvse\",\n            \"repository\":\"volt-mx-marketplace\"\n        }\n</code></pre> <p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>{\n    \"id\": \"volt-mx-marketplace\",\n    \"type\": \"marketplace\",\n    \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n}\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*ZipVSE\"</code>.</p>"},{"location":"howto/extensions/zip.html#create-zip-archives","title":"Create zip archives","text":"<p>Creating a zip archive is done in two steps. Firstly, <code>createArchive()</code> creates the empty zip archive at a specific file location. Then you add files, in a variety of optional ways. The option you choose may vary depending on what you are adding to the zip archive and how the list of files is generated.</p> <p>Info</p> <p>When adding files to an archive, the files will be added mirroring the filepath passed. Therefore to add with just the filename, use <code>ChDir</code> to switch to the relevant directory before adding the files.</p>"},{"location":"howto/extensions/zip.html#add-files-explicitly","title":"Add files explicitly","text":"<p>The following code will add files one by one:</p> <pre><code>Function createZipAdd(dirPath as String) as ZipArchive\n    Dim zip as New ZipArchive()\n    ChDir dirPath\n    Call zip.createArchive(\"zip1.zip\", \"\", True)\n    Call zip.addFile(\"test1.txt\", \"\")\n    Call zip.addFile(\"test2.txt\", \"\")\n    Return zip\nEnd Function</code></pre> <ol> <li>The final parameter is for whether or not to overwrite an existing archive</li> </ol>"},{"location":"howto/extensions/zip.html#add-all-files-that-match-a-filespec","title":"Add all files that match a filespec","text":"<p>The following code will add all <code>.txt</code> files in a directory:</p> <pre><code>Function createZipSpec(dirPath as String) as ZipArchive\n    Dim zip as New ZipArchive()\n    ChDir dirPath\n    Call zip.createArchive(\"zip2.zip\", \"\", True)\n    Call zip.addFiles(CurDir, \"*.txt\")\n    Return zip\nEnd Function</code></pre>"},{"location":"howto/extensions/zip.html#add-files-from-an-array","title":"Add files from an array","text":"<p>The following code will add all files included in a String array. Note, the array just includes filenames, the directory is passed as a separate argument.</p> <pre><code>Function createZipArray(dirPath as String) as ZipArchive\n    Dim zip as New ZipArchive()\n    ChDir dirPath\n    Dim files(1) as String\n    files(0) = \"test1.txt\"\n    files(1) = \"test2.txt\"\n    Call zip.createArchive(\"zip3.zip\", \"\", True)\n    Call zip.addFileList(CurDir, files)\n    Return zip\nEnd Function</code></pre>"},{"location":"howto/extensions/zip.html#extract-zip-archives","title":"Extract zip archives","text":""},{"location":"howto/extensions/zip.html#extract-all-files-from-a-zip","title":"Extract all files from a zip","text":"<p>The following code can be used to extract all files from a zip. The <code>openArchive()</code> command only loads the archive into the <code>ZipArchive</code> object so it can be processed. It doesn't physically unzip it.</p> <pre><code>Function extractZip(dirPath as String)\n    Dim zip as New ZipArchive()\n    Call zip.openArchive(dirPath &amp; \"/zip1.zip\")\n    Call zip.extractAllFiles(dirPath &amp; \"/zip1\", False, True)\nEnd Function</code></pre>"},{"location":"howto/extensions/zip.html#extract-individual-files","title":"Extract individual files","text":"<p>The following code can be used to extract individual files from a zip:</p> <pre><code>Function extractZipEachFile(dirPath as String)\n    Dim zip as New ZipArchive()\n    Dim file as ZipFile\n\n    ChDir DirPath\n    Call zip.openArchive(\"zip1.zip\")\n    Set file = zip(\"test1.txt\")\n    Call file.extractFile(\"zip2\", False, True)\n    Set file = zip(\"test2.txt\")\n    Call file.extractFile(\"zip2\", False, True)\nEnd Function</code></pre> <p>Note</p> <p>Best practice is to call <code>.close()</code> on the ZipArchive when processing completes.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/extensions/zulu.html","title":"Process dates","text":"<p>Info</p> <p>This how-to assumes you are familiar with setting up a project either manually or via VoltScript Dependency Management. If you are not, follow the Intro to VoltScript Tutorials.</p>"},{"location":"howto/extensions/zulu.html#introduction","title":"Introduction","text":"<p>LotusScript has always had a date/time Variant (DataType 7). But it doesn't contain a timezone and is unaware of any daylight savings.</p> <p>When dealing with data in middleware, ISO 8601 is a standard for date/times. But the values are passed in JSON as strings with datetime format. For use within VoltScript, it may be easier to convert to a date object. This is what ZuluVSE provides.</p>"},{"location":"howto/extensions/zulu.html#voltscript-dependencies","title":"VoltScript dependencies","text":"<p>Incorporating ZuluVSE is straightforward. You just need to add the following JSON object to the <code>vsesDependencies</code> element in your <code>atlas.json</code>.</p> <pre><code>    \"ZuluVSE\": {\n        \"library\": \"ZuluVSE VoltScript Extension\",\n        \"version\": \"1.0.4\",\n        \"module\": \"zuluvse\",\n    }\n</code></pre> <p>To use the extension in your script, enter <code>UseVSE \"*ZuluVSE\"</code>.</p>"},{"location":"howto/extensions/zulu.html#parse-dates","title":"Parse dates","text":"<p>The <code>DateTimeParser</code> class is used to parse a date string or number and return a <code>DateTimeObject</code>. There are a variety of in-built methods, depending on the value you start with.</p>"},{"location":"howto/extensions/zulu.html#parse-iso-dates","title":"Parse ISO dates","text":"<p>ISO dates can be parsed in UTC or with an offset. When dates are in UTC, they don't have an offset but end in \"Z\". The following code will convert a UTC date-time string to a DateTimeObject:</p> <pre><code>Function parseISOZuluDateString() as DateTimeObject\n    Dim dateStr as String\n    Dim parser as new DateTimeParser()\n    Dim dateObj as DateTimeObject\n\n    dateStr = \"2023-08-15T09:50:20Z\"\n    Set dateObj = parser.parseISOString(dateStr)\n    Return dateObj\nEnd Function</code></pre> <p>Sometimes a date will be received with an offset. These can also be parsed using <code>parseISOString()</code>:</p> <pre><code>Function parseISOOffsetDateString() as DateTimeObject\n    Dim dateStr as String\n    Dim parser as new DateTimeParser()\n    Dim dateObj as DateTimeObject\n\n    dateStr = \"2023-08-15T02:50:20-07:00\"\n    Set dateObj = parser.parseISOString(dateStr)\n    Print dateObj.defaultFormat\n    Return dateObj\nEnd Function</code></pre>"},{"location":"howto/extensions/zulu.html#build-from-epoch","title":"Build from epoch","text":"<p><code>DateTimeParser.buildDateFromEpoch()</code> is used to build a <code>DateTimeObject</code> based on milliseconds since Jan 1 1970 midnight UTC, the Unix epoch. The following code can be used to build a date corresponding to August 15th 2023, 12:08:20 UTC.</p> <pre><code>Function parseDateEpoch()\n    Dim parser as new DateTimeParser()\n    Dim dateObj as DateTimeObject\n\n    Set dateObj = parser.BuildDateTimeFromEpoch(1692101300)\n    Print dateObj.defaultFormat\n    Return dateObj\nEnd Function</code></pre>"},{"location":"howto/extensions/zulu.html#build-from-constituent-parts","title":"Build from constituent parts","text":"<p><code>DateTimeParser.buildDateTimeObject()</code> is used to build a DateTimeObject passing year, month, day, hours, minutes, seconds and offset minutes from UTC. The following code can be used to build a <code>DateTimeObject</code> for August 4th 2023, 12:20:25 (UTC +01:00).</p> <pre><code>Function parseDateParts()\n    Dim parser as new DateTimeParser()\n    Dim dateObj as DateTimeObject\n\n    Set dateObj = parser.BuildDateTimeObject(2023,8,4,11,20,25,-60)\n    Print dateObj.defaultFormat\n    Return dateObj\nEnd Function</code></pre>"},{"location":"howto/extensions/zulu.html#build-from-string-with-formatting-codes","title":"Build from string with formatting codes","text":"<p><code>DateTimeParser.ParseDateString()</code> allows a string date to be parsed with a specific set of format codes for a specific timezone. This function uses formatting codes consistent with the underlying C/C++ format codes.</p>"},{"location":"howto/extensions/zulu.html#formatting-datetimeobjects","title":"Formatting DateTimeObjects","text":""},{"location":"howto/extensions/zulu.html#formatting-to-iso-date-format","title":"Formatting to ISO date format","text":""},{"location":"howto/extensions/zulu.html#the-basics-using-the-cc-format-codes","title":"The basics - using the C/C++ format codes","text":"<p>We use the <code>DateTimeObject.toString()</code> method to return a date or date/time string formatted to fit our needs. This function uses formatting codes consistent with the underlying C/C++ format codes. Some more common examples are included in the comments of the example code below:</p> <pre><code>Sub toStringFormatExample()\n    Dim dtObj as DateTimeObject, dtParser as New DateTimeParser\n    Dim testISOStr as String, testFmtPattern1 as String, testFmtPattern2 as string, testFmtPattern3 as String\n    testISOStr = \"2023-02-20T20:49:13Z\"\n    testFmtPattern1 = \"%Y-%m-%d %H:%M:%S %Z\"\n    testFmtPattern2 = \"%F %T %Z\"\n    testFmtPattern3 = \"%A, %B %d %Y %T %Z\"\n\n    Set dtObj = dtParser.ParseISOString(testISOStr)\n\n    Print |Using test ISO String \"| &amp; testISOStr &amp; |\" with no locale code; |\n    Print |Format pattern \"| &amp; testFmtPattern1 &amp; |\" returns \"| &amp; dtObj.toString(testFmtPattern1, \"\") &amp; |\",|\n    Print |Format pattern \"| &amp; testFmtPattern2 &amp; |\" returns \"| &amp; dtObj.toString(testFmtPattern2, \"\") &amp; |\",|\n    Print |Format pattern \"| &amp; testFmtPattern3 &amp; |\" returns \"| &amp; dtObj.toString(testFmtPattern3, \"\") &amp; |\"|\nEnd Sub</code></pre> <p>In this example code, we have three different formatting patterns to test.</p> <p>Each of the patterns (<code>testFmtPattern1</code>, <code>testFmtPattern2</code>, and <code>testFmtPattern3</code>) specifies various date time components and the order in which they should appear.  </p> <ul> <li>testFmtPattern1 <code>%Y-%m-%d %H:%M:%S %Z</code>: This pattern specifies year-month-day hour:minute:second timezone.  </li> <li>testFmtPattern2 <code>%F %T %Z</code>: This pattern utilizes special shorthand codes. <code>%Y-%m-%d</code> can be abbreviated to <code>%F</code>, while <code>%H:%M:%S</code> can be abbreviated to simply <code>%T</code>.  This pattern therefore also specifies year-month-day hour:minute:second timezone.  </li> <li>testFmtPattern3 <code>%A, %B %d %Y %T %Z</code>: This pattern demonstrates some additional codes. The day of the week uses the code <code>%A</code>, and the name of the month uses the code <code>%B</code>, both of which will be returned in the appropriate language for the locale. This pattern specifies day-of-week, name-of-month day-of-month four-digit-year hour:minute:second timezone.</li> </ul> Common shorthand codes for date/time components Format code Description %B Full month name %b Abbreviated month name %A Full day name %a Abbreviated day name %m Month %d Day of month %0d Day of month (2 digit) %Y Year as four digits %F Equivalent of %Y-%m-%d %H Hour %M Minute %S Second %T Equivalent of %H:%M:%S %Z Locale-dependent time zone name or abbreviation"},{"location":"howto/extensions/zulu.html#the-locale-parameter","title":"The locale parameter","text":"<p>The locale parameter in <code>DateTimeObject.toString(*format*, *locale*)</code> allows you to display the names of things like months and days of the week using a country or regionally specific language.</p> <p>Warning</p> <p>Before using Locales, you must ensure that the appropriate locale has been installed.  </p> <p>Locale codes consist of appropriate ISO 639 Language Codes and ISO 3166 Country Codes concatenated with an underscore, followed by a period and the encoding format.  </p> <p>Examples:   </p> <ul> <li><code>en_US.utf8</code> specifies English (United States)</li> <li><code>es_MX.utf8</code> specifies Spanish (Mexico)</li> <li><code>fr_BE.utf8</code> specifies French  (Belgium) </li> </ul> <p>A table of locale codes (less the encoding format) can be found here.</p> <p>Assuming you were to install locales for both English and French, then using the code <code>\"en_US.utf8\"</code> would produce <code>Monday, February 20 2023 20:49:13 UTC</code>, and <code>\"fr_FR.utf8\"</code> would produce <code>lundi, f\u00e9vrier 20 2023 20:49:13 UTC</code>.</p> <p>Info</p> <p>Using different locales will require the relevant language pack installed on the operating system.</p> <p>The VoltScript Dev Container is based on Red Hat Enterprise Linux 8 (RHEL 8). This distribution only has a dedicated English langpack for locales, with all others packaged in <code>glibc-all-langpacks</code>. Installing all locales can be quite large (200+ MB), so <code>glibc-all-langpacks</code> only installs the locales defined in the build macro <code>_install_langs</code> to save space.</p> <p>To select the locales to install:</p> <ol> <li> <p>Open a root terminal into the container. See Creating the Dev Container for more details.</p> </li> <li> <p>Edit <code>/etc/rpm/macros.image-language-conf</code> to define <code>_install_langs</code> as the locales you want installed. This is a colon separated list of locale prefixes (ISO 639 Language Codes), for example <code>de:fr:es</code>. If a prefix does not contain a <code>_</code>, it is added. The special argument <code>all</code> means to install all locales and must be present by itself. You can change the languages to install with this command, replacing <code>&lt;lang&gt;</code> with the locales to install:</p> <pre><code>sed -i 's!%_install_langs.*!%_install_langs &lt;lang&gt;!' /etc/rpm/macros.image-language-conf\n</code></pre> </li> <li> <p>Install <code>glibc-all-langpacks</code>. This can be done with this command:</p> <pre><code>microdnf install glibc-all-langpacks &amp;&amp; microdnf clean all\n</code></pre> <p>Locales will be installed to <code>/usr/lib/locale/locale-archive</code>.</p> </li> <li> <p>Inspect the available locales by running <code>locale -a</code>.</p> <p>For more information on selecting what locales to install, run <code>build-locale-archive -h</code> after installing <code>glibc-all-langpacks</code>. This is the tool which compiles the locale archive. The build macro <code>_install_langs</code> is passed as the argument to <code>--install-langs</code>.</p> <p>You can change the installed locales by editing <code>/etc/rpm/macros.image-language-conf</code>, then reinstalling <code>glibc-all-langpacks</code>:</p> <pre><code>sed -i 's!%_install_langs.*!%_install_langs de:fr:es!' /etc/rpm/macros.image-language-conf\nmicrodnf reinstall glibc-all-langpacks &amp;&amp; microdnf clean all\n</code></pre> </li> </ol>"},{"location":"howto/extensions/zulu.html#converting-lotusscript-custom-date-time-formats","title":"Converting LotusScript custom date-time formats","text":"<p><code>DateTimeParser.ConvertLSFormat()</code> converts a string of custom LotusScript datetime formats into corresponding C/C++ format codes. The translated formats can now be recognized and used by other ZuluVSE functions, such as <code>ParseDateString()</code> and <code>toString()</code>.</p> <pre><code>Sub Initialize\n\n    Dim dtObj as DateTimeObject, dtParser as New DateTimeParser\n    Dim OldFrmt as String, NewFrmt as String, testFmtLocale as String\n\n    Set dtObj = dtParser.GetNow()\n    testFmtLocale = \"C\"\n\n    OldFrmt = \"m/d/yy\" \n    NewFrmt = dtParser.ConvertLSFormat(OldFrmt)\n    Print \"m/d/yy: \" &amp; dtObj.toString(NewFrmt, testFmtLocale)\n\n    OldFrmt = \"d-mmm-yy\" \n    NewFrmt = dtParser.ConvertLSFormat(OldFrmt)\n    Print \"d-mmm-yy: \" &amp; dtObj.toString(NewFrmt, testFmtLocale)\n\n    OldFrmt = \"c\" \n    NewFrmt = dtParser.ConvertLSFormat(OldFrmt)\n    Print \"c: \" &amp; NewFrmt &amp; \"-&gt;\" &amp; dtObj.toString(NewFrmt, testFmtLocale)\nEnd Sub</code></pre> <p>In this example code, 3 custom LotusScript datetime formats are translated.</p> <ul> <li><code>m/d/yy</code> is converted into <code>%m/%d/%y</code>.</li> <li><code>d-mmm-yy</code> is converted into <code>%d-%b-%y</code>.</li> <li><code>c</code> is converted into <code>%m/%d/%y %H:%M:%S</code>.</li> </ul> Custom LotusScript datetime formats and their respective C/C++ format equivalents LotusScript C/C++ c %m/%d/%y %H:%M:%S d %d dd %d ddd %a dddd %A ddddd %m/%d/%y dddddd %B %d, %Y w %w ww %V m %m mm %m mmm %b mmmm %B y %j yy %y yyyy %Y h %H hh %H n %M nn %M s %S ss %S ttttt %H:%M:%S AM/PM am/pm %p A/P a/p %p z %z zz %Z <p>Info</p> <p>Since LotusScripts doesnt have formats for writing locales, We've added <code>z</code> and <code>zz</code> for that purpose. <code>z</code> writes locale-dependent time zone name or abbreviation while <code>zz</code> writes offset from UTC in the ISO 8601 format (e.g. -0430).</p>"},{"location":"howto/foundry/index.html","title":"Develop Volt Foundry Integration Services","text":"<p>This section covers developing, testing, and deploying integration services for Volt Foundry:</p> <ul> <li>Write pre/postprocessor</li> <li>Build Integration Services</li> <li>VoltScript vs LotusScript</li> </ul>"},{"location":"howto/foundry/prepostprocessor.html","title":"Write pre/postprocessor","text":"<p>Volt Foundry integration service can also be coded in VoltScript. However, only small snippets of code are expected, for example to validate input parameters or manipulate the output. As a result, VoltScript code is entered directly into the Monaco editor, and merged into boilerplate VoltScript. This handles passing the response back to Volt Foundry for subsequent processing.</p> <p></p> <p>Note</p> <p>VoltScript pre/postprocessors are not available for VoltScript integration services. This is a limitation for performance reasons, see Understanding VoltScript in Volt MX Go.</p> <p>To understand the flow for running preprocessors and postprocessors, see Understanding VoltScript in Volt MX Go.</p>"},{"location":"howto/foundry/prepostprocessor.html#preprocessors","title":"Preprocessors","text":"<p>The function that preprocessor code is inserted into returns a boolean, <code>false</code> to abort processing or <code>true</code> to continue processing. Volt Foundry will automatically append code to make the default action <code>Return True</code> after your code completes.</p> <p>If you wish to abort processing, you should also consider setting the <code>opstatus</code> or <code>httpStatusCode</code> and adding an error message. These can be picked up by your downstream applications, that is the Iris app or other application calling the Volt Foundry REST service.</p>"},{"location":"howto/foundry/prepostprocessor.html#postprocessors","title":"Postprocessors","text":"<p>Postprocessor code is also inserted into a function, but the return value isn't used. You can set the <code>opstatus</code> or <code>httpStatusCode</code>, add an error message or populate the result JSON object.</p>"},{"location":"howto/foundry/integrations/index.html","title":"Develop Volt Foundry Integration Services","text":"<p>This section covers developing, testing, and deploying integration services for Volt Foundry:</p> <ul> <li>Use VS Code Extension Build Development Features</li> <li>Write and Package Integration Service Code</li> <li>Configure a VoltScript Integration Service</li> <li>Advanced configuration</li> <li>Troubleshoot</li> </ul>"},{"location":"howto/foundry/integrations/advanced.html","title":"Advanced configuration","text":"<p>The Advanced section of an operation allows configuring advanced settings:</p> <ul> <li>Custom Code Invocation<ul> <li>Preprocessor and Postprocessors</li> </ul> </li> <li>Properties<ul> <li>Set timeout (in ms).</li> <li>Cache results for x seconds.</li> </ul> </li> <li>Front End API<ul> <li>Override path to this operation.</li> <li>Change verb for this operation.</li> </ul> </li> <li>Server Events<ul> <li>Raise event on incoming request.</li> <li>Raise event on outgoing response.</li> <li>Subscribe to an event.</li> </ul> </li> </ul> <p>Further details are available in Volt MX documentation, covering:</p> <ul> <li>Override throttling per operation</li> <li>Configuring custom front-end URLs</li> <li>Customizing Front-end API verbs</li> <li>Server Events processing</li> </ul>"},{"location":"howto/foundry/integrations/archipelago.html","title":"Use VS Code Extension Build Development Features","text":"<p>The Visual Studio Code Build Management Extension provides various functionality for speeding up development.</p>"},{"location":"howto/foundry/integrations/archipelago.html#atlasjson","title":"atlas.json","text":"<p>The first is an atlas.json snippet template. This can be accessed by creating an atlas.json, typing <code>foundry-atlas</code> and accepting the snippet.</p> <p>The snippet automatically adds the dependencies and repository for VoltMXObjects.</p> <p>Warning</p> <p>For EA3 you will need to update the VoltScript VoltMX Middleware version number in the snippet. Please change to \"latest\". The update was not identified prior to packaging of the VoltScript Extension.</p>"},{"location":"howto/foundry/integrations/archipelago.html#volt-foundry-script-boilerplate","title":"Volt Foundry script boilerplate","text":"<p>The second is a script snippet template for writing a VoltScript integration service operation. This can be accessed by creating a .vss script file, typing <code>foundry</code> and accepting the snippet. The snippet:</p> <ul> <li>Adds required <code>Use</code> and <code>UseVSE</code> statements.</li> <li>Adds a <code>Sub Initialize</code> with the boilerplate code for extracting Volt Foundry objects and sending back a response.</li> </ul>"},{"location":"howto/foundry/integrations/archipelago.html#package-for-volt-foundry","title":"Package for Volt Foundry","text":"<p>This is a command accessed from the Visual Studio Code Command Palette when you are in the atlas.json or a .vss file. The process:</p> <ul> <li>Prompts for the project directory.</li> <li>Prompts for the location of the atlas.json.</li> <li>Prompts for any additional directories or files to be included in the package.<ul> <li>Separate multiple instructions with commas.</li> <li>Directories and filenames will be picked up relevant to the project's working directory.</li> <li>Passing a filename or directory and filename will include that file.</li> <li>Passing a directory and spec will include all files with that spec in the parent directory. For example, \"foo/*.json\" will include all .json files in foo directory.</li> <li>ZipVSE's <code>.addFiles()</code> API isn't recursive, it only includes files matching the spec, it doesn't include subdirectories.</li> </ul> </li> <li>Creates a zip comprising:<ul> <li>atlas.json</li> <li>seti.ini</li> <li>.vss files in src directory</li> <li>.vss files in libs directory</li> <li>VSEs in vses directory</li> <li>any additional requested directories / files</li> </ul> </li> </ul> <p>The zip is named using the <code>name</code> and <code>version</code> in the atlas.json. For example, if the name is \"vss-poc\" and version is \"1.0.0\", the zip file will be called \"vss-poc-1.0.0.zip\" and placed in the root of the project directory, ready to be uploaded for Volt Foundry.</p>"},{"location":"howto/foundry/integrations/configuring.html","title":"Configure a VoltScript Integration Service","text":"<p>Once you have written and packaged your Integration Service code, you need to configure your Integration Service on Volt Foundry and upload your packaged code.</p> <p>Note</p> <p>This assumes you have already written your Integration Service code, packaged it up for upload to Volt Foundry, and have a Volt Foundry server available. If you are unfamiliar with this process it is recommended you go through the Introduction to VoltScript for Volt Foundry tutorials.</p>"},{"location":"howto/foundry/integrations/configuring.html#creating-an-integration-service","title":"Creating an Integration Service","text":"<ol> <li>Log into your Volt Foundry server.</li> <li> <p>On the Apps page, open an existing app or click ADD NEW.</p> <p></p> </li> <li> <p>On Configure Services tab, click the Integration tab and then click CONFIGURE NEW.</p> <p></p> </li> <li> <p>Set the Name to the desired name for your Integration Service.</p> </li> <li>Select \"VoltScript\" under Service Type.</li> <li> <p>Click Upload New to upload your packaged Integration Service ZIP file. </p> <p></p> <p>Once your ZIP file is uploaded you will see it listed, along with the Name, Description, and Version you entered in your package's <code>atlas.json</code> file, as well as an Editor pane where you could optionally modify your VSS code.</p> <p></p> </li> <li> <p>If you have configured an Identity Service for your Application, select it under Identity Service for Backend Token.</p> </li> <li>You may optionally enter a Description.</li> <li>Once you're done, click SAVE &amp; ADD OPERATION.</li> </ol> <p></p>"},{"location":"howto/foundry/integrations/configuring.html#adding-an-operation-to-an-integration-service","title":"Adding an Operation to an Integration Service","text":"<p>Once you click SAVE &amp; ADD OPERATION you're taken to the Operations List tab, where you can configure a new Operation.</p> <ol> <li>Enter a name for your Operation in the Operation Name field.</li> <li>Select the VSS containing the desired Operation in the File Name dropdown.</li> <li> <p>Click ADD OPERATION.</p> <p></p> </li> <li> <p>After adding your new Operation you can click SAVE AND FETCH RESPONSE to save your operation and test to make sure it works.</p> <p></p> <p>If everything is successful, you should get an Output Result console window pop up at the bottom of the screen with the results of your operation.</p> <p></p> </li> </ol>"},{"location":"howto/foundry/integrations/configuring.html#advanced-options","title":"Advanced options","text":"Field Description Custom Code Invocation - Preprocessor and Postprocessor You can add pre and post processing logic to services to modify the request inputs. Only Rules are available for VoltScript integration service preprocessors and postprocessors. Properties Additional Configuration Properties allows you to configure service call time out cache response. Front End API Front-end API allows you map your endpoint (or) backend URL of an operation to a front-end URL. Server Events Using Server Events you can configure this service to trigger or process server side events. <p>For more details, see Advanced Configuration.</p>"},{"location":"howto/foundry/integrations/configuring.html#configure-request-operation","title":"Configure request operation","text":"<p>Integration services accept only <code>form-url-encoded</code> inputs for all the input parameters provided in the service input parameters (request input).</p> <p>To forward the body of the client's request to backend as it is, select the Enable pass-through input body checkbox.</p> <p>You can perform the following actions in Request Input tab:</p> <ol> <li>Click Add Parameter to add an entry if the entries for input and the output tabs doesn't exist.</li> <li>To make duplicate entries, select the checkbox for the entry, click Copy and Paste.</li> <li>To delete an entry, select the checkbox for an entry and click Delete .</li> <li> <p>To configure the request input tab, provide the following details:  </p> Field Description Name It contains a Unique Identifier. Change the name if required. Test Value Enter a value. A test value is used for testing the service. Default Value Enter the value, if required. The default value will be used if the test value is empty. Scope Select Request or Session. It's set to Request by default. Request indicates that the value must be retrieved from the HTTP request received from the mobile device. Session indicates that the value must be retrieved from the HTTP session stored on Volt Foundry. Identity: If this is selected, you can map a request parameter to a value of the response from the identity provider. Data Type Select one of the following data typesString - A combination of alpha-numeric and special characters. Supports all formats including UTF-8 and UTF-16 with no maximum size limit. Boolean - A value that can be true or false.Number - An integer or a floating number.Collection - A group of data, also referred as data set. Encode Select the checkbox to enable encoding of an input parameter. For example, the name New York Times would be encoded as New_York_Times when the encoding is set to True. The encoding must also adhere to the HTML URL encoding standards. Description Provide a suitable description. </li> <li> <p>To validate the operation details, click Save and Test.</p> </li> </ol>"},{"location":"howto/foundry/integrations/configuring.html#configure-response-operation","title":"Configure response operation","text":"<p>In a VoltScript service, the complete response from the VoltScript code is sent to the client device.</p> <p>Note</p> <p>By default, the <code>opStatus</code> and <code>httpStatusCode</code> values for VoltScript services are added as 0 and 200.</p>"},{"location":"howto/foundry/integrations/troubleshooting.html","title":"Test and troubleshoot","text":"<p>Testing can be done in Volt Foundry or locally. Errors handling is added to the <code>Sub Initialize</code> in the Volt Foundry snippet.</p> <p>To test locally, you will probably need the content object passed from Volt Foundry to VoltScript. Otherwise, the global objects won't be initialized in VoltMXObjects.vss, such as VoltMxRequest, VoltMxResult.</p>"},{"location":"howto/foundry/integrations/troubleshooting.html#save-and-fetch-response","title":"Save And Fetch Response","text":"<p>The SAVE AND FETCH RESPONSE button at the bottom of an operation can be used to test an operation.</p> <p></p> <p>This will run the operation, using the test (if configured) or default values for any input parameters. The result will be displayed at the bottom of the screen.</p> <p></p> <p>Tip</p> <p>You can change the input parameters on-the-fly in the Request Payload panel and use the the Save and ReTest button to run with the new updates. This doesn't take into account updates made to test values or default values in the main part of the operation.</p> <p>Note</p> <p>An environment needs to be set up and added to the operation, on the drop-down to the left of the SAVE AND FETCH RESPONSE button. The environment is set up on the Environments tab in the left-hand navigation.</p>"},{"location":"howto/foundry/integrations/troubleshooting.html#understand-the-test-panel","title":"Understand the test panel","text":"<p>The test panel has two tabs, Test and Log. If an identity service is tied to the integration service, an additional tab, Identity Backed Response is added.</p> <p>Identity Backed Response initially prompts the user to log into the identity service using the AUTHORIZE button. When authorized, the JWT token returned is displayed, along with buttons at the right-hand side of the panel to clear the token, copy the token or expand the panel.</p> <p>Test shows the payload being sent with the request and the result that would be provided for the result.</p> <p>Log shows the various steps in the process:</p> <ul> <li>Request: the payload being loaded by Volt Foundry, including any request input header or body parameters. Header parameters aren't relevant for VoltScript integration services.</li> <li>Pre-Processor Output: only shows if a preprocessor is added. This shows the modified payload after the preprocessor runs. This includes whether or not to continue execution, modified input parameters and result object.</li> <li>Integration Service Input: doesn't show for coded integration services. This shows the modified request sent to the integration service.</li> <li>Integration Service Output: doesn't show for coded integration services. This shows the response from the remote service.</li> <li>PostProcessor Output: only shows if a postprocessor is added. This shows the modified payload after the postprocessor runs. This includes input parameters and result object.</li> <li>Response: shows the response sent from Volt Foundry.</li> <li>Miscellaneous: shows performance and logs.</li> </ul>"},{"location":"howto/foundry/integrations/troubleshooting.html#access-payloads-for-voltscript","title":"Access Payloads for VoltScript","text":"<p>When you write a VoltScript integration service, there is boilerplate code that take a JSON string as contextual input and converts it to VoltScript objects using VoltMXObjects script library module. For unit testing or testing your local VoltScript code from REST clients like Postman, you need to know what JSON Volt Foundry passes across. The test panel allows you to access these JSON objects.</p> <p></p> <p>To do this, modify the payload to include a JSON element called <code>vsTestingContext</code> with the boolean value <code>true</code> and then click the Save and Retest button in the panel. With this in the request payload, the VoltScript code won't be executed. Instead, the Output Result will contain two JSON objects:</p> <ul> <li> <p>unitTestContext: A JSON object that corresponds to <code>Context.context</code> from ContextVSE. This string can then be passed to <code>extractObjects()</code> function to create the Volt MX objects that would be created for a request via Volt Foundry. This will allow you to write unit tests to check various branches in your processing logic or troubleshoot your code locally.</p> <p>Note</p> <p>DrapiServer won't be automatically authenticated. Your unit tests will need to pass test credentials and login, passing the authenticated DrapiServer object to your code. This can be done in a <code>beforeEach()</code> or <code>beforeAll()</code> of a CustomBeforeAfterTester, see Write code to BeforeAll, BeforeEach etc.</p> </li> <li> <p>httpServerContext: The actual JSON object Volt Foundry passes to VoltScript's HTTP server, including contextual data (<code>context</code>) and JWT token from identity service (<code>jwttoken</code>). This complete object can be passed from Postman to VoltScript's HTTP server. Testing this way will automatically extract the JWT token and authenticate the DrapiServer, assuming the JWT token is still valid. For more information, see Call VoltScript from Postman and tutorial.</p> </li> </ul> <p>Warning</p> <p>For both JSON objects, you will need to update <code>projectDir</code> to your local project directory path, if you are using it in your VoltScript code. Alternatively, add logic to use <code>CurDir</code> under testing circumstances.</p>"},{"location":"howto/foundry/integrations/troubleshooting.html#run-locally-from-postman","title":"Run locally from Postman","text":"<p>If the VoltScript runtime is started with the HTTP server (using --http-server option), you can also run the VoltScript script from Postman. The URL should be:</p> <ul> <li>http://localhost:PORT/run, where the port maps to the HTTP port VoltScript runtime's http server is started with. Port 9060 is the default.</li> <li>?path= plus the absolute path to the .vss file to run.</li> <li>&amp;seti_path= plus the absolute path to the seti.ini file to use.</li> </ul> <p>The Content-Type header should be set to \"application/json\". The body should contain the <code>httpServerContext</code> JSON object. For more details, see Run HTTP server.</p>"},{"location":"howto/foundry/integrations/writing.html","title":"Write and Package Integration Service Code","text":"<p>A VoltScript integration service is uploaded to Volt Foundry as a zip file containing source, libs and vses directories as well as seti.ini and atlas.json. Uploading both Windows and Linux versions of VSEs ensures the code can run on whatever platform Volt Foundry is installed. Each operation corresponds to a main script in the source directory in your VoltScript package.</p> <p></p> <p>Note</p> <p>Currently main scripts must be placed in a directory called <code>src</code>, which is also the default for <code>sourceDir</code> in the atlas.json.</p> <ol> <li>Create the file atlas.json.</li> <li>Type all or part of \"foundry-atlas\" and select the snippet.</li> <li>Complete required fields and add any additional dependencies. name and version will be used to generate the zip file.</li> <li>Run dependency management using VoltScript: Install Dependencies VS Code command.</li> <li>Create a main script in <code>src</code> directory.</li> <li>Type all or part of \"foundry\" and select the snippet. Enter your custom code in the block marked.</li> <li>Add other main scripts as required.</li> <li>Run Volt Foundry build management using VoltScript: Package for Foundry VS Code command.</li> </ol> <p>The resulting zip can be uploaded to Foundry.</p>"},{"location":"howto/foundry/integrations/writing.html#interacting-with-volt-foundry-context","title":"Interacting with Volt Foundry context","text":"<p>The Volt Foundry contextual data is automatically parsed in the <code>extractObjects()</code> call. Content you may need will be:</p> Object Description PROJECT_DIR Directory of this project on disk. Use this instead of <code>CurDir</code> when code should parse files uploaded with the project, because CurDir will be the directory of the VoltScript executable. VoltMxRequest.getInputParam() Access a request parameter mapped in Request Input body parameters.  VoltMxRequest.getRequestParam() Access a request parameter not mapped in Request Input body parameters. VoltMxRequest.getHeaderParam() Access a header parameter VoltMxRequest.getIdentityParam() Access the JWT token from the identity service associated with this integration service. For talking to Domino via DrapiVSE, this is automatically passed to the <code>DrapiServer</code> object. For other backends, you need to parse the JWT token manually to retrieve whatever information you need to access the backend as the current logged on user. VoltMxResult.opstatus Integer property holding the opstatus to pass back from Volt Foundry, defaulting to 0. VoltMxResult.httpStatusCode Integer property holding the http status code to pass back from Volt Foundry, defaulting to 200. VoltMxResult.result JsonObject property for the response from Volt Foundry. VoltMxResult.addDebugMessage() Adds a message to debug out from Java to the Volt Foundry application logs, in the same way debug messages can be logged from Java or JavaScript integration services. Java logging level will need amending to output the logs. VoltMxResult.setErrorMessage() Sets an error message to be picked up by Volt Foundry, generating an exception for the operation. <p>For more details, see documentation of Volt MX Objects</p>"},{"location":"howto/foundry/integrations/writing.html#write-testable-code","title":"Write testable code","text":"<p>Writing custom code in the main script is sufficient for running in Volt Foundry. However, it makes the script harder to test. Recommended practice is to write your custom code in a function in a VoltScript Library Module, then call that from the main script. This allows you to write unit tests to check all potential scenarios for your REST service operation. </p>"},{"location":"howto/foundry/ls-to-vs/index.html","title":"Converting LotusScript to VoltScript","text":"<p>This section will cover some tips on converting code.</p> <p>Note</p> <p>This how-tos is not intended to give a 1:1 example of LotusScript and VoltScript. It is intended to educate, to help you understand the paradigms that may have become instinctive with Notes Client development, and to help you understand how code should be structured differently for development outside the Notes Client.</p>"},{"location":"howto/foundry/ls-to-vs/index.html#sample-code","title":"Sample code","text":"<p>LotusScript code often combines UI and backend classes. This is an example of an action button used in read mode to change company name and update associated Contacts:</p> <pre><code>Sub Click(Source As Button)\n    Dim ws As New NotesUIWorkspace\n    Dim companyName As String\n    Dim newCompanyName As Variant\n    Dim s As New NotesSession\n    Dim doc As NotesDocument\n    Dim contDoc As NotesDocument\n    Dim db As NotesDatabase\n    Dim view As NotesView\n    Dim dc As NotesDocumentCollection\n\n    Set doc = ws.CurrentDocument.Document\n    companyName = doc.Company(0)\n    newCompanyName =  ws.Prompt(PROMPT_OKCANCELEDIT, \"New Company\", \"Enter New Company Name\", companyName)\n    If Not IsEmpty(newCompanyName) Then\n        doc.Company = newCompanyName\n        Call doc.Save(True, False, True)\n        Print \"Updated Company\"\n        Set db = s.CurrentDatabase\n        Set view = db.GetView(\"(luContactsByCompany)\")\n        Set dc = view.GetAllDocumentsByKey(companyName, True)   \n        Set contDoc = dc.GetFirstDocument\n        While Not contDoc Is Nothing\n            doc.Company = newCompanyName\n            Call doc.save(True, False, True)\n            Set contDoc = dc.GetNextDocument(contDoc)\n        Wend\n        Print \"Updated \" &amp; dc.count &amp; \" contacts\"\n        Call ws.ViewRefresh\n        Call ws.CurrentDocument.Close\n        Call ws.EditDocument(False, doc)\n    End If\nEnd Sub\n</code></pre> <p>There are three aspects of converting this to VoltScript.</p> <ol> <li>UI vs backend.</li> <li>Notes backend classes.</li> <li>Looping to update documents.</li> </ol> <p>Let's break this out.</p>"},{"location":"howto/foundry/ls-to-vs/index.html#ui-vs-back-end","title":"UI vs back-end","text":"<p>This challenge is not specific to Volt MX Go or VoltScript. The same problem exists when converting this paradigm to XPages, or traditional Domino web development with Forms and Agents, or any web development platform where front-end and back-end code are separate.</p> <p>The code falls into three sections:</p> <ol> <li>Lines 12-16: gathering user input.</li> <li>Lines 17-18, 20-28: backend processing.</li> <li>Lines 19 and 29-32: UI updates.</li> </ol> <p>Obviously, only the second section is relevant, whether it's XPages Java, a LotusScript web agent, or a VoltScript function in Volt Foundry. The first and third sections need to be processed in the web application's user interface.</p> <p>This is the code that needs to be converted to VoltScript. There are variables used within these lines but defined outside these needs. The values need to be gathered in the UI and passed as inputs. Note that the <code>if</code> statement is not included in this part. With proper application development, the function should not be called if the company name is blank.</p> <p>Note also that the <code>Print</code> statements are covered as UI updates. But it's important to state that there is no explicit success / failure processing: with everything being in synchronous LotusScript, if the database updates fail the code will error and the engine automatically notify the UI. The code will need to return success / failure explicitly in a format the UI can process. In the case of VoltScript on Volt Foundry, this is as a JSON, values in <code>VoltMXResult.result</code>.</p>"},{"location":"howto/foundry/ls-to-vs/index.html#notes-backend-classes","title":"Notes backend classes","text":"<p>There is no concept of \"current database\" or \"current document\" in VoltScript. This contextual information needs to be passed as inputs, along with current user. DrapiVSE provides the classes to interact with Domino databases.</p>"},{"location":"howto/foundry/ls-to-vs/index.html#looping-to-update-documents","title":"Looping to update documents","text":"<p>Lines 27-34 get a <code>NotesDocumentCollection</code> and iterate each document in turn to update the company name. When converting code to run anywhere outside the current Domino server, looping paradigms should raise red flags. Regular calls to a remote server will perform badly. In LotusScript, this could and should be replaced with <code>NotesDocumentCollection.stampAll()</code>. In VoltScript, it should be replaced with a \"/bulk/update\" call to DRAPI, which can be achieved via <code>DrapiRequest.bulkPatchDocuments()</code>.</p>"},{"location":"howto/foundry/ls-to-vs/index.html#summary","title":"Summary","text":"<p>Due to the fundamental differences in how VoltScript is used vs LotusScript, it requires you to have a different approach to how you write your code. VoltScript is independent of Domino; Domino is simply another back end available via REST APIs. So when working with a Domino back end, you need to approach it as you would working with any other back-end with a REST API. This means that you want to minimize your interactions with the API, because each round-trip to the server costs time. You also need to keep in mind that VoltScript is stateless, meaning each interaction with a REST API is independent of any previous or future actions.</p> <p>Understanding these fundamental differences will allow you to write more efficient code to accomplish your goals.</p> <p>Warning</p> <p>As with other languages, Domino access is based on Domino REST API. VoltScript does not provide full developer-level LotusScript-level access to the Domino server and database. Such code should be restricted to the Domino server, where it can be managed by the Domino Administrator. As a result, not all processes will be suitable for moving to VoltScript in a middleware layer.</p>"},{"location":"howto/language/index.html","title":"Core language","text":"<p>This section covers how-to queries about the core VoltScript language syntax and functions.</p> <ul> <li>Understanding CurDir()</li> <li>Error handling</li> <li>Loops</li> <li>Short-circuiting logical expressions</li> </ul>"},{"location":"howto/language/conditionals.html","title":"Short-circuiting logical expressions","text":""},{"location":"howto/language/conditionals.html#introduction","title":"Introduction","text":"<p>In LotusScript, logical operations (<code>And</code> and <code>Or</code>) evaluate all expressions before deciding which branch of the conditional statement to process. VoltScript adds new operators - <code>||</code> and <code>&amp;&amp;</code> - for short-circuiting the logical operations.</p>"},{"location":"howto/language/conditionals.html#_1","title":"||","text":"<p><code>||</code> short-circuits logical expressions where developers might otherwise use <code>Or</code>. This performs like Visual Basic's <code>OrElse</code> operator, running the minimum conditional statements required. The following code won't throw an error and continue to the <code>Return</code> statement.`</p> <pre><code>Function orSuccess as String\n    Dim obj as Student\n    If (obj is Nothing || obj.Name != \"\") Then\n        Print \"Student not initialized\"\n    End If\n    Return \"Success\"\nEnd Function</code></pre> <p>Note</p> <p>Because <code>||</code> can now be an empty string and <code>OrElse</code>, <code>If passedStr = \"\" || args(0) = \"\" Then</code> won't compile. The first condition will need to be wrapped in parentheses, so <code>If (passedStr = \"\") || args(0) = \"\" Then</code>.</p>"},{"location":"howto/language/conditionals.html#_2","title":"&amp;&amp;","text":"<p><code>&amp;&amp;</code> short-circuits logical conjunctions on two or more expressions. This performs like Visual Basic's <code>AndAlso</code> operator, running the minimum conditional statements required. The following code won't run the <code>obj.Score</code> condition if <code>obj.Name</code> is blank.</p> <pre><code>Function andSuccess as String\n    Dim obj as New Student\n    If (obj.Name != \"\" &amp;&amp; obj.Score &gt; 90) Then\n        Print \"High-score valid student\"\n    End If\n    Return \"Success\"\nEnd Function</code></pre>"},{"location":"howto/language/conditionals.html#understanding-when-to-short-circuit","title":"Understanding when to short-circuit","text":"<p>There may still be cases when you do not want to short-circuit logical expressions. When running unit tests, you want to know if all are successful or any have failed. <code>TestSuite.ranSuccessfully()</code> returns whether that test was successful. But consider the following script:</p> <pre><code>Sub Initialize\n\n    Dim testRunner as New testRunner(\"Language tests\")\n    Dim result as Boolean\n\n    result = errorTests(testRunner)\n    result = result And logicalTests(testRunner)\n\n    If result Then Print \"TESTS SUCCESSFUL\" Else Print \"TESTS UNSUCCESSFUL\"\n\nEnd Sub\n</code></pre> <p>If you used <code>&amp;&amp;</code> on line 7, the second set of tests would only run of the first tests failed. But you want to run them every time. As a result, <code>And</code> is the better choice for this use case.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/language/curdir.html","title":"Understanding CurDir()","text":"<p><code>CurDir()</code> has always been a LotusScript function. The unwary developer may assume <code>CurDir()</code> function returns the directory containing the script currently being edited, but this is a misconception. The VoltScript <code>CurDir()</code> function works the same way it does in LotusScript, returning the current working directory at runtime, so the directory from which the script is being run. Typically, this will be the project directory.</p> <p>This can be tested by comparing <code>CurDir</code> from a test or main script with the following function in a VoltScript Library Module.</p> <pre><code>Function getCurrentWorkingDirectory() as String\n    Return CurDir\nEnd Function</code></pre> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/language/errors.html","title":"Error handling","text":""},{"location":"howto/language/errors.html#introduction","title":"Introduction","text":"<p>VoltScript adds Try/Catch/Finally to improve on LotusScript error handling and provides a more consistent developer experience compared to other languages. There aren't currently any enhancements to error functions or logging.</p> <p>Note</p> <p>Traditional error handling in LotusScript with with <code>On Error</code> statements. This can still be used in VoltScript, but example code will prefer <code>Try...Catch</code> syntax.</p>"},{"location":"howto/language/errors.html#trycatchfinally","title":"Try/Catch/Finally","text":"<p>Try/Catch allows inline coding to handle errors. This improves readability of code and can simplify code when nesting Try/Catch. Finally blocks allow cleanup regardless of errors. Even if the final instruction of a Try or Catch block is to exit the sub or function, the Finally block will still be processed before the exit instruction.</p> <p>At the very least, a <code>Try</code> block must include either a <code>Catch</code> or <code>Finally</code> block. The following isn't valid syntax:</p> <pre><code>Try\n    ' Do something\nEnd Try</code></pre>"},{"location":"howto/language/errors.html#catching-specific-errors","title":"Catching specific errors","text":"<p>Specific errors are caught using <code>Catch Error</code> + the error number. The following code will catch the type mismatch thrown because <code>value</code> isn't a Boolean and can't be parsed as a Boolean:</p> <pre><code>Function catch13Error()\n    Dim value as String\n\n    value = \"Hello world\"\n    Try\n        If (value = true) Then\n            Print \"value is a boolean true\"\n        End If\n    Catch Error 13\n        Print \"Type Mismatch - value is not a boolean\"\n    End Try\nEnd Function</code></pre>"},{"location":"howto/language/errors.html#catching-generic-errors","title":"Catching generic errors","text":"<p>A simple Catch block will catch any other uncaught error. Consequently, it should appear after all blocks that are catching specific errors. If there are no blocks catching specific errors, it will catch all errors.</p> <pre><code>Sub catchError()\n    Try\n        Error 22\n    Catch\n        Print \"Catch \" &amp; Err() &amp; \" on line \" &amp; Erl()\n    End Try\nEnd Sub</code></pre>"},{"location":"howto/language/errors.html#exiting-blocks","title":"Exiting blocks","text":"<p>In both Try and Catch you can exit out of the sub or function. The following function will return \"Success\" if you want to continue without error, otherwise it will print an error and return \"Failure\".</p> <pre><code>Function tryCatchExit(throwError as boolean) as String\n    Try\n        If (throwError) Then Error 400, \"You wanted an error\"\n        Return \"Success\"\n    Catch\n        Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n        Return \"Failure\"\n    End Try\nEnd Function</code></pre> <p>Warning</p> <p>You can't exit out of the Finally block using <code>Exit</code> or <code>Return</code>.</p>"},{"location":"howto/language/errors.html#stack-trace","title":"Stack trace","text":"<p>When you catch an error, it's often important to know at which line the current function was called. <code>GetThreadInfo(12)</code> provides this information, giving a stack for the current line number and the from where the current sub or function was called, all the way to the initializing code. The following code gives a stack that prints \"GETSTACK\" twice if the argument passed is true, or once if the argument passed is false.</p> <pre><code>Function getStack(recurse as Boolean) as String\n    If (recurse) Then\n        Return getStack(false)\n    Else\n        Print GetThreadInfo(12)\n        Return GetThreadInfo(12)\n    End If\nEnd Function</code></pre> <p>Note</p> <p>The output of <code>GetThreadInfo(12)</code> is a string with line feeds (<code>Chr(10)</code>) separating each element in the stack and an additional blank line at the end. It comprises four elements for wherever the call is made:</p> <ul> <li>module, i.e. current script file name.</li> <li>class or an empty string, if current procedure is not part of a class.</li> <li>module, i.e. current sub or function.</li> <li>line number</li> </ul> <p>If you wish to parse it, you will need to do some manipulation.</p> <p>Warning</p> <p>When using <code>GetThreadInfo(12)</code>, the line at the start of the stack is the current line, not an error line. Your error handling will still need to use <code>Erl()</code> to get the line the error actually occurred on.</p>"},{"location":"howto/language/errors.html#finally-block","title":"Finally block","text":"<p>There may be processing that needs to be completed regardless of success or failure. This can be done in a Finally block. The Finally block runs before breaking out of a Try or Catch block, so can be used for unlocking files etc. In the following example, the note in the Finally block will be printed regardless of success or failure:</p> <pre><code>Function doFinally(throwError as Boolean) As String\n    Try\n        If (throwError) Then Error 400, \"You wanted an error\"\n        Return \"Success\"\n    Catch\n        Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n        Return \"Failure\"\n    Finally\n        Print \"NOTE: Running in finally\"\n    End Try\nEnd Function</code></pre>"},{"location":"howto/language/errors.html#nesting-trycatch","title":"Nesting Try/Catch","text":"<p>As expected, Try/Catch/Finally can be nested. This helps keep your code more readable and avoid jumping around your script. The following code demonstrates throwing errors in outer and inner Try blocks:</p> <pre><code>Function nestTC(error1 as Boolean, error2 as Boolean) as Integer\n    Try\n        If (error1) Then Error 400, \"You wanted an outer error\"\n        Print \"Outer success\"\n        Return 1\n    Catch\n        Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n        Try\n            If (error2) Then Error 401, \"You wanted an inner error\"\n            Print \"Inner success\"\n            Return 2\n        Catch\n            Print \"Error \" &amp; Error() &amp; \" on line \" &amp; Erl()\n            Return 3\n        End Try\n    End Try\nEnd Function</code></pre> <p>Success</p> <p>Use of Try/Catch/Finally should remove the need to use <code>GoTo</code> in code, improving readability and support.</p> <p>Note</p> <p>Error handling is currently the same as LotusScript, using <code>Err()</code> for the error number, <code>Error()</code> for the error description and <code>Erl()</code> for the error line. See LotusScript documentation for more details.</p> <p>Enhancements are on the roadmap, but no further details are available at this time.</p>"},{"location":"howto/language/errors.html#logging","title":"Logging","text":"<p>There are no specific enhancements for error logging from VoltScript. This may be addressed in the future. Currently, the recommended approach would be to use StreamVSE to write to a file.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/language/loops.html","title":"Loops","text":""},{"location":"howto/language/loops.html#introduction","title":"Introduction","text":"<p>There are no additions to the available iterative statements (loops) in VoltScript. But the pre- and post-fix increment and decrement operators may change the way code is written.</p>"},{"location":"howto/language/loops.html#iterative-statements","title":"Iterative statements","text":"<p>Like LotusScript, VoltScript provides the following iterative statements:</p> <ul> <li>For...Next loop uses a numeric variable, iterating from a lower bound to an upper bound, both defined in the <code>For</code> statement. The numeric variable is automatically incremented by the loop.</li> <li>ForAll...in loop iterates all elements in an array, list or VoltScript Extension class that implements a collection. <code>Exit ForAll</code> statement allows you to exit early.</li> <li>While loop iterates according to a condition, checked at the start of each loop. There is no <code>Exit</code> statement provided to break out of this condition, so if you wish to do this, best practice is to use a <code>Do...</code> loop instead. It's the developer's responsibility to remember to change the condition variable within the loop.</li> <li>Do...Loop loop iterates without condition until an <code>Exit Do</code> statement is triggered.</li> <li>Do While...Loop loop checks a condition before starting each loop and, as long as the condition is true, executes the conditions. It's the developer's responsibility to remember to change the condition variable within the loop or call <code>Exit Do</code>.</li> <li>Do...Loop While loop checks a condition after each loop, always iterating the loop at least once. The loop is iterated again as long as the condition is true. It's the developer's responsibility to remember to change the condition variable within the loop or call <code>Exit Do</code>.</li> <li>Do Until...Loop loop checks a condition before starting each loop and executes the loop until the condition is true. It's the developer's responsibility to remember to change the condition variable within the loop or call <code>Exit Do</code>.</li> <li>Do...Loop Until loop checks a condition after each loop, always iterating the loop at least once. The loop is iterated again until a condition is true. It's the developer's responsibility to remember to change the condition variable within the loop or call <code>Exit Do</code>.</li> </ul> <p>Note</p> <p>When using a <code>ForAll</code> loop, the data type of the element variable in  the container is <code>Variant</code>. Best practice will be to cast it to the relevant datatype before using. If it is being passed to another Sub or Function, you will need to cast it before passing it to the method or you will receive a Type Mismatch error.</p> <p>This is consistent with LotusScript, although it is encountered less frequently. <code>NotesDocument.items</code> is one such container in LotusScript that can be iterated using a <code>ForAll</code> loop. More usually in LotusScript you need to use <code>getFirst...</code> and <code>getNext...</code> function to iterate the collection.</p> <p>This flow diagram should help you choose the right iterative loop:</p> <pre><code>flowchart TD\n    A{Iterate\\nnumeric\\nvariables?}-- Yes --&gt;B(For...Next)\n    A-- No --&gt;C{Iterate all\\nelements in a\\ncollection?}\n    C-- Yes --&gt;D(ForAll...in...)\n    C-- No --&gt;E{Loop without\\ncondition?}\n    E-- Yes --&gt;F(Do...Loop)\n    E-- No --&gt;G{When to\\ncheck\\ncondition?}\n    G-- Start of each loop --&gt;H{Continue to\\ncompletion\\nalways?}\n    H-- Yes --&gt;I(While...Wend)\n    H-- No --&gt;J{When to\\nbreak loop?}\n    J-- When condition\\nis false --&gt;K(Do While...Loop)\n    J-- When condition\\nis true --&gt;L(Do Until...Loop)\n    G-- End of each loop --&gt;M{When to\\nbreak loop?}\n    M-- When condition\\nis false --&gt;N(Do...Loop While)\n    M-- When condition\\nis true --&gt;O(Do...Loop Until)</code></pre> <p>Success</p> <p>Use of the right iterative statement should prevent error conditions or the need to use <code>GoTo</code>, improving readability and support of the code.</p>"},{"location":"howto/language/loops.html#prefixpostfix-incrementdecrement","title":"Prefix/Postfix increment/decrement","text":"<p>When using numeric variables in <code>While</code> and <code>Do</code> loops, historically a separate instruction to increment or decrement the variable was required. However, prefix and postfix increment and decrement operators can avoid the need for this.</p> <p>Warning</p> <p>You may need to think carefully about whether to use prefix or postfix operators. Remember with a prefix operator, the variable will be modified before any other instructions on the line are processed; with the post-fix operator, all other instructions on the line will be processed and then the variable will be modified.</p>"},{"location":"howto/language/loops.html#while-loop","title":"While loop","text":"<p>The <code>While</code> loop is probably the most familiar to LotusScript developers. The following example will print all elements of an array, incrementing the variable after the print:</p> <pre><code>Sub loopArray(passedArr as Variant)\n    Dim i as Integer\n    While i &lt;= UBound(passedArr)\n        Print passedArr(i++)\n    Wend\nEnd Sub</code></pre>"},{"location":"howto/language/loops.html#do-with-prefix-or-postfix-increment","title":"Do with prefix or postfix increment","text":"<p>The danger of incrementing a variable within the loop is that the unobservant developer may wish to make an additional use of the array element, so copy and paste <code>passedArr(i++)</code>, inadvertently double-incrementing the variable <code>i</code> within each loop. <code>Do</code> loops can avoid the temptation by ensuring the variable is incrementing in the loop command.</p> <p>However, incrementing at the start of the loop will skip the first variable, so the condition must be at the end. This can be achieved with either prefix or postfix operator. The following code uses the prefix operator.</p> <pre><code>Sub loopArrayDo(passedArr as Variant)\n    Dim i as Integer\n    Do\n        Print passedArr(i)\n    Loop Until ++i &gt; UBound(passedArr)\nEnd Sub</code></pre> <p>The following code does the same with a postfix operator:</p> <pre><code>Sub loopArrayDoPostfix(passedArr as Variant)\n    Dim i as Integer\n    Do\n        Print passedArr(i)\n    Loop Until i++ = UBound(passedArr)\nEnd Sub</code></pre>"},{"location":"howto/language/loops.html#more-complex-postfix-operations","title":"More complex postfix operations","text":"<p>Imagine we want to iterate the words in \"The quick brown fox jumps over the lazy dog\" but exit at the second \"the\". Postfix operators can make the code very terse:</p> <pre><code>Sub loopArrayExitThe(passedArr as Variant)\n    Dim i as Integer\n    Dim the as Integer\n    Do Until i &gt; UBound(passedArr)\n        If (LCase(passedArr(i)) = \"the\") Then\n            If the++ &gt; 0 Then Exit Do\n        End If\n        Print passedArr(i++)\n    Loop\nEnd Sub\n</code></pre> <p>Line 5 checks if the lower-cased word is \"the\". Line 6 checks a variable is greater than 0 and then increments it, allowing the conditional statement to be reduced to a single line. After printing the current word, the variable for the <code>Do</code> loop is incremented.</p> <p>The complete implementations of the code snippets are available on GitHub.</p>"},{"location":"howto/running/index.html","title":"Run code","text":"<p>This section covers how-to queries about running your VoltScript code.</p> <ul> <li>Run from command line</li> <li>Run from Visual Studio Code</li> <li>Run HTTP server</li> </ul>"},{"location":"howto/running/http-server.html","title":"Run HTTP server","text":"<p>If the <code>--http-server &lt;port&gt;</code> option is passed when starting the VoltScript runtime, the runtime will listen on the specified port for HTTP POST requests.</p> <p>The request:</p> <ul> <li>should use the POST verb.</li> <li>should use the URL:<ul> <li>http://localhost:PORT/run using the port passed when starting the HTTP server.</li> <li>?path= plus the absolute path to the .vss file to run.</li> <li>&amp;seti_path= plus the absolute path to the seti.ini file to use.</li> </ul> </li> <li>should pass <code>Content-Type</code> header with the value \"application/json\".</li> <li>should pass a JSON payload comprising:<ul> <li>context that's accessible via ContextVSE's <code>Context.context</code> property.</li> <li>jwttoken that's an optional JSON value comprising a JWT token that DrapiVSE will pick up to automatically log into a DrapiServer.</li> </ul> </li> </ul> <p>Note</p> <p>The HTTP server isn't intended to be accessible directly to the internet, because query parameters expected are the path to the script to run. As a result, it doesn't support HTTPS and is no enabled for HTTP/2. It's intended for internal development or calling from a locally-hosted application.</p> <p>Terminate the HTTP server process by using <code>Ctrl + C</code>.</p>"},{"location":"howto/running/http-server.html#debugging","title":"Debugging","text":"<p>If you wish to debug code running on the HTTP server, you will need to start the debug HTTP server using <code>--debug-server &lt;port&gt;</code> option instead.</p>"},{"location":"howto/running/voltscript.html","title":"Run from command line","text":"<p>Note</p> <p>VoltScript runtime does not yet support ARM processors.</p> <p>Any VoltScript file can be run from the command line on Windows or Linux. This is done using the VoltScript executable downloaded from My HCLSoftware{: target=\"_blank\" rel=\"noopener noreferrer\"} portal.</p> <p>Note</p> <p>Ensure the directory containing the VoltScript executable is included in the PATH environment variable.</p> <p>The VoltScript program requires as its final parameter a path to the file to run, including the <code>.vss</code> suffix:</p> <pre><code>VoltScript scripts/testScript.vss\n</code></pre> <p>Multiple scripts can be passed, in which case all will be compiled and run.</p>"},{"location":"howto/running/voltscript.html#run-process","title":"Run process","text":"<ol> <li>The program first compiles the code. If there are any <code>Use</code> statements, the program will look for a file at the relevant absolute or relative path and compile that. If there are any <code>UVSE</code> statements, the relevant VoltScript Extensions will be loaded using the following process:<ul> <li>Use the <code>seti.ini</code> file passed via the <code>--seti</code> argument.</li> <li>Use a <code>seti.ini</code> in the current working directory, if found. For VS Code, this will be the workspace folder open.</li> <li>Use a <code>seti.ini</code> in the same directory as the VoltScript executable, if found.</li> </ul> </li> <li>If compilation fails, a \"Use or UseVSE Error\" is raised and the program exits with an exit code 19.</li> <li>If compilation passes, any code in <code>Sub Initialize</code> blocks in any of the files is run, as well as any code not in any Sub or Function block.</li> <li>Print statements and runtime errors are routed to the console. If VoltScript runs to completion, a 0 exit code is returned.</li> </ol>"},{"location":"howto/running/voltscript.html#options-available","title":"Options Available","text":"<p>Additional options can be passed:</p> Option Description -c Compiles only, doesn't run any code --context &lt;context&gt; Sends a string of text, passed after the option, that can be picked up using ContextVSE. Note: there are operating system limitations on what content can be passed as part of the string. --no-utf8 Treats the source file as platform character set --debug-server  Starts the debug server on the specified port --headless, -H Sets headless mode, msgbox calls are routed to print statements --help, -h Shows the options available --http-server  Starts the HTTP server on the specified port --path, -I &lt;path&gt; Sets the path to look for the given scripts --seti, -X &lt;path&gt; Uses a seti.ini at the relevant path to identify file locations for any VoltScript extensions --verbose, -v Enables verbose output --version Shows the BaliScript version string"},{"location":"howto/running/voltscript.html#streamvse-stdio","title":"StreamVSE STDIO","text":"<p>If StreamVSE is being used to receive input from STDIO, running VoltScript will prompt for content to be passed.</p>"},{"location":"howto/running/vscode.html","title":"Run from Visual Studio Code","text":"<p>An open VoltScript file can be run from the Command Palette, VoltScript: Save &amp; Run Script. The standard VS Code keyboard shortcuts (Cmd + F5 / Ctrl + F5) will also work. An input box will be displayed to add any additional runtime parameters. For additional parameters, see runtime options.</p> <p>Note</p> <p>StreamVSE can be used to prompt for use input when running code. This is already in use with dependency management, where you are prompted for settings.</p>"},{"location":"howto/running/vscode.html#debugging","title":"Debugging","text":""},{"location":"howto/running/vscode.html#setting-up-launchjson","title":"Setting up launch.json","text":"<p>You can also debug code in VS Code. This can be done by going to the Run / Debug tab configuration and clicking create a launch.json file, using standard VS Code functionality.</p> <p></p> <p>The file will be created as launch.json in a <code>.vscode</code> directory. The content will default to:</p> <pre><code>{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n\n        {\n            \"type\": \"voltscript\",\n            \"name\": \"VoltScript - Run Active\",\n            \"request\": \"launch\",\n            \"pathToScript\": \"${file}\",\n            \"scriptContext\": \"\",\n            \"setiPath\": \"${workspaceFolder}/seti.ini\",\n            \"stopAtEntry\": true\n        }\n    ]\n}\n</code></pre> <p>Warning</p> <p>VS Code will pop up a dialog to select a launch configuration. This appears over and covers the default configuration that gets created. Unless you specifically want to add another configuration, just click elsewhere on the screen and save the default launch.json file.</p> <p>This will run the open script file (<code>\"pathToScript\": \"${file}\"</code>) looking for a seti.ini file in the root of the workspace folder (<code>\"setiPath\": \"${workspaceFolder}/seti.ini\"</code>). If your code is not using VSEs and you don't have a seti.ini, replace this value with an empty string. The code will break on the first line (<code>\"stopAtEntry\": true</code>). To just run the code without debugging, change <code>stopAtEntry</code> to false.</p> <p>You can pass contextual data by pasting it into <code>scriptContext</code>, escaping any double quotes as required. This can be picked up with ContextVSE, see Receive input.</p> <p>Warning</p> <p>The Debug Console cannot receive input, so you cannot debug code that uses StreamVSE to prompt the user for input. You will need to modify your script accordingly, for example passing a value in <code>scriptContext</code> to tell your script to use hard-coded content instead of prompting the user for input.</p>"},{"location":"howto/running/vscode.html#additional-configurations","title":"Additional configurations","text":"<p>Two other VoltScript configurations are available:</p> <ul> <li>VoltScript: Launch (Local)</li> <li>VoltScript: Launch (Remote)</li> </ul> <p>They can be added by using content assist in the launch.json or clicking the launch configuration drop-down on the Run / Debug tab and selecting \"Add configuration...\". Scroll down the dialog box that appears to find the additional configurations.</p>"},{"location":"howto/running/vscode.html#voltscript-launch-local","title":"VoltScript: Launch (Local)","text":"<p>This configuration is for running a specific script from VS Code. If you just want to run the currently open script, use the default configuration instead.</p> <p><code>stopAtEntry</code> defaults to true. You will need to manually complete the <code>pathToScript</code>, <code>scriptContext</code>, and <code>setiPath</code> values. Use variables as required, e.g. <code>${workspaceFolder}</code> for the current workspace folder. For more details of variabvles available, see Variables Reference documentation.</p>"},{"location":"howto/running/vscode.html#voltscript-launch-remote","title":"VoltScript: Launch (Remote)","text":"<p>This configuration is for running a specific script using VoltScript's HTTP server. This can be useful for debugging code for Foundry using a payload previously extracted from Foundry.</p> <p><code>stopAtEntry</code> defaults to true. You will need to manually complete the <code>pathToScript</code>, <code>scriptContext</code>, <code>setiPath</code>, <code>serverPort</code>, and <code>serverHost</code> values as required. Full paths will be required for <code>pathToScript</code> and <code>setiPath</code>, because these are used by the HTTP server, not VS Code.</p>"},{"location":"howto/running/vscode.html#using-the-debugger","title":"Using the debugger","text":"<p>For details on using VS Code's debugger, see the standard VS Code debugging documentation, with the following caveats:</p> <ul> <li>The only breakpoints supported are:<ul> <li>Standard breakpoints.</li> <li>Triggered breakpoints.</li> <li>Inline breakpoints.</li> </ul> </li> <li>Function breakpoints, data breakpoints, and logpoints are not supported.</li> <li>Variable values can be updated, including array elements.</li> <li>Array bounds cannot be dynamically changed in the Variables panel.</li> <li>Strings values display in quotes. When setting a value, remove the quotes: the inputted value will be wrapped in quotes.</li> <li>The Watch section is not supported.</li> <li>Debug Console REPL is not supported.</li> </ul>"},{"location":"howto/sharing/index.html","title":"Share code","text":"<p>This section covers how-to queries about sharing your VoltScript code with other developers.</p> <ul> <li>Package VoltScript Extensions</li> <li>Package VoltScript Libraries</li> <li>Publish to GitHub or a web server</li> </ul>"},{"location":"howto/sharing/libraries.html","title":"Package VoltScript Libraries","text":"<p>Note</p> <p>VoltScript Extensions can be scaffolded in VoltScript Interface Designer. You can also generate code skeletons and API documentation from VSID.</p> <p>VoltScript Libraries are published as individual files. You will need to share:</p> <ul> <li>the main <code>.vss</code> file.</li> <li>the <code>atlas.json</code> file.</li> <li>any custom <code>.vss</code> files not specified as dependencies in the <code>atlas.json</code>.</li> </ul> <p>Note</p> <p>If you are creating a release on GitHub, you should add these files manually into the release. If in doubt, look at one of the HCL-developed repositories for an example.</p>"},{"location":"howto/sharing/libraries.html#downstream-dependencies","title":"Downstream dependencies","text":"<p>You don't need to publish downstream dependencies. VoltScript Libraries or VoltScript Extensions included in your <code>atlas.json</code> as dependencies from other external repositories will automatically be downloaded, providing they're accessible.</p>"},{"location":"howto/sharing/libraries.html#documentation-for-voltscript-build-manager-consumers","title":"Documentation for VoltScript Build Manager consumers","text":""},{"location":"howto/sharing/libraries.html#dependencies","title":"Dependencies","text":"<p>Include in your documentation a JSON object for each <code>.vss</code> file, comprising the library, version, and <code>.vss</code> filename. For example:</p> <pre><code>\"dependencies\": [\n  {\n    \"library\": \"voltscript-testing\",\n    \"version\": \"1.0.1\",\n    \"module\": \"VoltScriptTesting.vss\"\n  }\n]\n</code></pre> <p>If publishing to GitHub, the library will be the GitHub repository name. If publishing to a generic web server, the library will be a directory with a subdirectory for each version.</p> <p>Note</p> <p>You don't need to include any documentation referring to the <code>atlas.json</code>, that will be picked up automatically.</p>"},{"location":"howto/sharing/libraries.html#publishing","title":"Publishing","text":"<p>Include in your documentation a JSON object for the repository consumers will need to add into their atlas.json.</p> <p>Note</p> <p>Always use an ID that will be unique for this URL, because consumers will need to add a corresponding entry with the same ID in their environment-wide atlas-settings.json.</p>"},{"location":"howto/sharing/libraries.html#github","title":"GitHub","text":"<p>If you are publishing to GitHub or GitHub Enterprise, the type should be \"github\". The URL format varies depending on the environment:</p> <ul> <li>For github.com, the URL will be \"https://api.github.com/repos/\" + OWNER_NAME.</li> <li>For GitHub Enterprise Server, the URL will be \"http(s)://HOSTNAME/api/v3/repos/\" + OWNER_NAME.</li> </ul> <p>Example:</p> <pre><code>{\n  \"id\": \"hcl-github\",\n  \"type\": \"github\",\n  \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n}\n</code></pre>"},{"location":"howto/sharing/libraries.html#generic-web-server","title":"Generic Web Server","text":"<p>For a generic web server or Domino database, the type should be \"webserver\". The URL will be appended with \"/LIBRARY/VERSION/MODULE\".</p> <pre><code>{\n  \"id\": \"my-nsf\",\n  \"type\": \"webserver\",\n  \"url\": \"https://my-webserver.com/VoltScriptRepository.nsf\"\n}\n</code></pre> <p>Tip</p> <p>If you want to use Domino as a repository, you have two options:</p> <ol> <li>Create folders on the Domino server in /data/domino folder. <li>Use an NSF and either:<ul> <li>Open the Package Explorer view and add folders under the WebContent directory and drag your files in.</li> <li>Add as File Resources. This is the less recommended approach, because the File Resource name needs to include forward slashes to simulate a folder structure.</li> </ul> </li> <p></p>"},{"location":"howto/sharing/publish.html","title":"Publish to GitHub or a web server","text":"<p>Voltscript Build Manager currently supports two types of repository - GitHub and generic web servers that allow downloading content via a standard folder structure.</p>"},{"location":"howto/sharing/publish.html#publishing-to-github","title":"Publishing to GitHub","text":"<p>If publishing to GitHub, VoltScript's build manager will pull files from a release in a repository using standard GitHub APIs. For \"latest\" GitHub automatically redirects and knows which is the latest version, and the GitHub API returns the actual version number, so no additional work is required.</p> <p>Note</p> <p>Make a note of your repository name. This will be the library you need to pass to consumers.</p> <p>When ready, create a Release. The tag you give the release, for example \"1.0.0-RC1\", will be the version you need to pass to consumers. The source code will automatically be created on the release. In addition, add the packaged files for the VoltScript Extension or VoltScript Library. You don't need to include <code>.vss</code> files or extensions from other external repositories, VoltScript build manager will automatically download those. However, if there are additional <code>.vss</code> files custom for this repository, you will need to include those.</p> <p>Regardless of whether the repo is public or private, users will need to set up a Personal Access Token to pull down the release artifacts.</p>"},{"location":"howto/sharing/publish.html#publishing-to-a-generic-web-server","title":"Publishing to a generic web server","text":"<p>When downloading from a web server, VoltScript Build Manager will build a URL using LIBRARY/VERSION/MODULE. To support \"latest\", your web server will need the latest version in two directories, one called \"latest\" and one with the actual version number. In addition, the \"latest\" directory will also need to include a file with the name <code>version.txt</code>, which includes just the actual current version number. This should be updated as you release a new version. So the <code>version.txt</code> file will just be, for example:</p> <pre><code>1.0.0\n</code></pre>"},{"location":"howto/sharing/publish.html#publishing-to-domino","title":"Publishing to Domino","text":"<p>Domino can be used as a generic web server repository, either putting the files directly on the server or in an NSF.</p> <p>When put directly on the server, create a directory structure using LIBRARY/VERSION and put the modules and atlas.json in this directory. Anything prior to this will be the repository URL.</p> <p>When put in an NSF, you can either:</p> <ul> <li>Use File Resources, where the filename is LIBRARY/VERSION/MODULE. Its <code>atlas.json</code> would be LIBRARY/VERSION/atlas.json. If VERSION is latest, you would also need a LIBRARY/latest/version.txt file resource.</li> <li>In Package Explorer view, right-click the WebContent directory and create a folder with the library name. Right-click that directory and create a folder for the version name. Then drag or paste your modules into that folder.</li> </ul> <p></p>"},{"location":"howto/sharing/publish.html#ensuring-correct-http-response-codes","title":"Ensuring correct HTTP response codes","text":"<p>You can use basic authentication, even if session authentication is enabled for the server. However, by default, if authentication fails, you get an HTTP 200 result with a login page. This isn't what you want for REST API access. This can be circumvented by using a \"Overrides Session Authentication\" Web Site Rule document. For more information, see Authenticating a DAS Request from Other Types of Applications.</p> <p>In Domino Directory, go to Configuration \u2192 Messaging \u2192 Internet Sites. Ensure there is an Internet Site document for the server. Open it up. Click Web Site \u2192 Create Rule. Add a description, as appropriate. Change the Type of rule to Override Session Authentication. Set the Incoming URL pattern to an appropriate path for the requests, for example <code>*/VSRepo.nsf/*</code>.</p>"},{"location":"howto/sharing/publish.html#requiring-authentication","title":"Requiring authentication","text":"<p>VoltScript Build Manager supports generic web servers that are secured for basic authentication. If credentials are found for a matching repository ID, they're added to the Basic Authentication header.</p>"},{"location":"howto/sharing/vses.html","title":"Package VoltScript Extensions","text":"<p>Note</p> <p>VoltScript runtime does not yet support ARM processors.</p> <p>Note</p> <p>VoltScript Extensions can be scaffolded in VoltScript Interface Designer. You can also generate code skeletons and API documentation from VSID.</p> <p>VoltScript Extensions are written in C/C++, which makes them platform, architecture, and processor-specific. In addition, dependencies may vary depending on what's automatically included in a specific platform. As a result, the VoltScript Build Manager code expects a zip file containing zips per platform/architecture/processor including all dependencies required.</p> <p>The top-level zip file should be named VSENAME.zip. This should contain zips with VSENAME + \"-\" + platform code. The valid options for VoltScript are currently:</p> <ul> <li>linux-x64</li> <li>win64</li> </ul> <p>Tip</p> <p>Linux filenames are case-sensitive, so recommendation for the Linux zip file is to use lower-case.</p> <p>Warning</p> <p>ZipVSE cannot extract tar files, so use .zip files for all operating systems.</p>"},{"location":"howto/sharing/vses.html#example","title":"Example","text":""},{"location":"howto/sharing/vses.html#jsonvse","title":"JsonVSE","text":"<ul> <li>JsonVSE.zip<ul> <li>LICENSE<ul> <li>license</li> <li>notices</li> </ul> </li> <li>JsonVSE-win64.zip<ul> <li>JsonVSE.dll</li> </ul> </li> <li>jsonvse-linux-x64.zip<ul> <li>jsonvse.so</li> </ul> </li> </ul> </li> </ul>"},{"location":"howto/sharing/vses.html#webvse","title":"WebVSE","text":"<ul> <li>WebVSE.zip<ul> <li>LICENSE<ul> <li>license</li> <li>notices</li> </ul> </li> <li>WebVSE-win64.zip<ul> <li>WebVSE.dll</li> <li>libcurl-x64.dll</li> </ul> </li> <li>webvse-linux-x64.zip<ul> <li>libwebvse.so</li> </ul> </li> </ul> </li> </ul> <p>Tip</p> <p>When naming VoltScript Extensions and zip files, bear in mind the following logic in VoltScript dependency management:</p> <ul> <li>Using module in <code>atlas.json</code>:<ul> <li>Download the zip using library and module.</li> <li>Extract it and look for a zip called -win64.zip or -linux-x64.zip.</li> <li>To update <code>seti.ini</code>, if there is only one file in the zip, use that. Otherwise, look for a file including the label for the JSON object in atlas.json.</li> </ul> </li> </ul>"},{"location":"howto/sharing/vses.html#documentation-for-voltscript-build-manager-consumers","title":"Documentation for VoltScript Build Manager consumers","text":"<p>See information under references.</p>"},{"location":"howto/sharing/vses.html#publishing","title":"Publishing","text":"<p>Include in your documentation a JSON object for the repository consumers will need to add into their atlas.json.</p> <p>Note</p> <p>Always use an ID that will be unique for this URL, because consumers will need to add a corresponding entry with the same ID in their environment-wide atlas-settings.json.</p>"},{"location":"howto/sharing/vses.html#github","title":"GitHub","text":"<p>If you are publishing to GitHub or GitHub Enterprise, the type should be \"github\". The URL format varies depending on the environment:</p> <ul> <li>For github.com, the URL will be \"https://api.github.com/repos/\" + OWNER_NAME.</li> <li>For GitHub Enterprise Server, the URL will be \"http(s)://HOSTNAME/api/v3/repos/\" + OWNER_NAME.</li> </ul> <p>Example:</p> <pre><code>{\n  \"id\": \"hcl-github\",\n  \"type\": \"github\",\n  \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n}\n</code></pre>"},{"location":"howto/sharing/vses.html#generic-web-server","title":"Generic Web Server","text":"<p>For a generic web server or Domino database, the type should be \"webserver\". The URL will be appended with \"/LIBRARY/VERSION/MODULE\".</p> <pre><code>{\n  \"id\": \"my-nsf\",\n  \"type\": \"webserver\",\n  \"url\": \"https://my-webserver.com/VoltScriptRepository.nsf\"\n}\n</code></pre> <p>Tip</p> <p>If you want to use Domino as a repository, you have two options:</p> <ol> <li>Create folders on the Domino server in /data/domino folder. <li>Use an NSF and either:<ul> <li>Open the Package Explorer view and add folders under the WebContent directory and drag your files in.</li> <li>Add as File Resources. This is the less recommended approach, because the File Resource name needs to include forward slashes to simulate a folder structure.</li> </ul> </li> <p></p>"},{"location":"howto/sharing/vses.html#volt-mx-marketplace","title":"Volt MX Marketplace","text":"<p>VoltScript Extensions, which will typically not be open sourced, are hosted on Volt MX Marketplace. The completed zip can be uploaded to Volt MX Marketplace for approval.</p> <p>After upload, you will be prompted to complete the submission form:</p> <ul> <li>the category should be \"VoltScript Extensions\".</li> <li>it should target the latest Volt Foundry.</li> <li>recommended practice is to make the name the VoltScript Extension name + \" VoltScript Extension\".</li> <li>upload an image 400 x 300 pixels, typically we have used a screenshot of a snippet of implementation code.</li> <li>add links to documentation and API docs. Documentation will include the JSON consumers need to add.</li> <li>in the checkboxes lower down, ensure it targets Volt Foundry and not Volt Iris. This ensures it does not appear as a component in Iris.</li> <li>submit.</li> </ul> <p>After approval, you will be able to access the download. Hovering on the \"Download\" button gives a URL. The JSON you provide for the user should be:</p> <pre><code>*VSENAME* {\n    \"library\": \"TITLE ON ASSET VOLT MX MARKETPLACE\",\n    \"version\": \"1.0.0\",\n    \"module\": \"LOWERCASE VSE NAME FOR EXAMPLE JSONVSE\",\n    \"repository\": \"volt-mx-marketplace\"\n}\n</code></pre> <p>If in doubt, compare with the page on the Volt MX Marketplace for an existing HCL VoltScript Extension and the JSON in our documentation.</p>"},{"location":"howto/writing/index.html","title":"Write code","text":"<p>This section covers how-to queries about writing your VoltScript code.</p> <ul> <li>Visual Studio Code Extensions</li> <li>Use VoltScript Library Modules</li> <li>Use VoltScript Extensions</li> <li>Structure your project code</li> </ul>"},{"location":"howto/writing/ai.html","title":"Using GitHub Copilot for AI assistance","text":"<p>Note</p> <p>Code actions need coding and adding to a Visual Studio Code extension. This takes time. While those are added,using an AI assistant like GitHub Copilot can fill the gap. At HCL, we've been using GitHub Copilot since spring 2024. With its knowledge of Visual Basic and LotusScript, and an awareness of files that are open, it can be an effective peer programmer.</p> <p>This \"how-to\" is by no means exhaustive. For full details, read the GitHub Copilot Extension documentation. This is designed to highlight some easy-to-miss gotchas and give ideas on how GitHUb Copilot might enhance your developer experience.</p>"},{"location":"howto/writing/ai.html#background","title":"Background","text":"<p>GitHub Copilot extension for VS Code can advise on and perform code actions on files, and also has documentation specifically for best practices. It's important to understand the different contexts. Copilot interaction can be done from:</p> <ul> <li>a Quick Chat, from the Command Center Copilot menu at the top of VS Code.</li> <li>the Chat sidebar.</li> <li>Editor Inline Chat, which can be started from the right-click menu.</li> </ul> <p>The Editor Inline Chat can make amendments to the code in the editor, which you can accept or discard. So you may need to carefully consider on which line you begin the chat. Other options will just show you sample code.</p> <p>By default, GitHub Copilot will \"see\" the contents of the file visible in the editor window. This may mean it does not see everything you want it to see. You can use <code>#file</code> to add a whole file as context.</p> <p>GitHub Copilot will offer code suggestions as you type. It has not been trained on VoltScript language and its training lags behind what is available on the web. As a result APIs may not be accurate. We have found that WebVSE and JsonVSE are particularly prone to incorrect assumptions of API calls, and its initial guesses will be based on other language APIs.</p> <p>We recommend being careful with your wording. GitHub Copilot can be particularly verbose with some responses. There is a max size for responses. On occasion we have found responses that exceed its limit. Re-wording the question to avoid lengthy exposition can avoid the problem.</p>"},{"location":"howto/writing/ai.html#some-ideas-of-uses","title":"Some ideas of uses","text":""},{"location":"howto/writing/ai.html#api-doc-comments","title":"API Doc comments","text":"<p>GitHub Copilot can be asked to add an API Doc comment to a function. Asking GitHub Copilot to generate the whole comment may not give the best explanation and correct language syntax, depending on what else is in the document. But if you start to add the comment, it can complete JavaDoc / JSDoc syntax for <code>@param</code>, <code>@returns</code> etc.</p>"},{"location":"howto/writing/ai.html#format-code","title":"Format code","text":"<p>GitHub Copilot can be used to format code with correct indentations.</p>"},{"location":"howto/writing/ai.html#unreachable-code","title":"Unreachable code","text":"<p>GitHub Copilot can advise on any unreachable code in a block.</p> <p>Checking for unused functions is more difficult, because some libraries may not be fully utilized. However, by passing specific files and asking a targeted question, it may be possible to verify for unused functions in a specific library.</p>"},{"location":"howto/writing/ai.html#complexity","title":"Complexity","text":"<p>By passing a file, it's possible to check for code for complexity, either under cyclomatic complexity rules or cognitive complexity rules. Other complexity types may also be tested.</p>"},{"location":"howto/writing/ai.html#change-variable-names","title":"Change variable names","text":"<p>Changing variables names in a function can also be done with gitHub Copilot. In tests, this has correctly just updated variable names, not replaced class declarations where the class name was the same as the variable name.</p> <p>Updating across whole files may have differing levels of success.</p>"},{"location":"howto/writing/ai.html#refactor-code-move-to-separate-function","title":"Refactor code - move to separate function","text":"<p>GitHub Copilot can also be used to move a chunk of code into its own function. If manually refactoring code, having the original code still available and visible might help Copilot \"copy and paste\" the code across.</p>"},{"location":"howto/writing/libraries.html","title":"Use VoltScript Library Modules","text":"<p>Info</p> <p>For pulling external VoltScript Library Modules via dependency management, see the relevant repository or, for HCL-developed library modules, see the references.</p> <p>Note</p> <p>Domino developers will be familiar with the <code>Use</code> statement for incorporating external script library modules. However, in an NSF all script libraries have to be placed in the same location.</p> <p>VoltScript files can include VoltScript code in external <code>.vss</code> files. This is done by referencing the filename, without the <code>.vss</code> suffix, in a <code>Use</code> statement at the start of the script. The file can be referenced with a relative or absolute path.</p> <p>Note</p> <p>Currently, relative paths are relative to the file being run. If a VoltScript File A contains a Use statement to File B, which contains a Use statement to File C, the relative path for File C is resolved relative to File A, not File B.</p> <p>Warning</p> <p>Although valid for one-off runs, absolute paths should be avoided, because it makes code more difficult to transfer to other environments.</p>"},{"location":"howto/writing/libraries.html#correct-syntax","title":"Correct Syntax","text":"<p>Assume the following directory structure:</p> <p>/tmp/projecta \u00a0\u00a0\u00a0\u00a0entry.vss \u00a0\u00a0\u00a0\u00a0libA.vss \u00a0\u00a0\u00a0\u00a0libB.vss \u00a0\u00a0\u00a0\u00a0libC.vss</p> <p>The following would be valid Use statements and positioning in <code>entry.vss</code>:</p> <pre><code>Use \"libA\"  'Looks for libA.vss in the same directory\nUse \"../projecta/libB\"  'Navigates to parent directory (tmp) of the current directory (projecta), then looks for libB.vss in projecta directory\nUse \"/tmp/projecta/libC\"  'Looks for /tmp/projecta/libC.vss\n\nSub Initialize\n\nEnd Sub</code></pre> <p>Note</p> <ul> <li>The directory separator \"/\" should be used for cross-platform compatibility. It's standard for *nix platforms but also understood by modern Windows platforms.</li> <li>See Structuring Your Project for best practices.</li> </ul>"},{"location":"howto/writing/libraries.html#dependency-management","title":"Dependency management","text":"<p>It's recommended to include VoltScript Extensions via dependency management. This will automatically download and extract the files, and create the seti.ini. For details of what to add to your atlas.json, see references on VoltScript Library Modules.</p> <p>Troubleshooting</p> <p>If the VoltScript Dependency Manager fails, review the information printed to the console. An atlas-settings.json will be required for dependencies pulled from GitHub or from a web server that requires authentication. The dependencies will be downloaded to the .vss directory in the user's home before being copied to the project. If using a dev container, this will be the user's home in the container.</p>"},{"location":"howto/writing/structure.html","title":"Structure your project code","text":"<p>There is no specific directory structure required for individual one-off scripts, and there is no format prescribed by the IDE or runtime. The best practice, encouraged by content assist in <code>atlas.json</code>, is the following format:</p> <p>project/ \u00a0\u00a0\u00a0\u00a0src/ \u00a0\u00a0\u00a0\u00a0test/ \u00a0\u00a0\u00a0\u00a0libs/ \u00a0\u00a0\u00a0\u00a0vses/ \u00a0\u00a0\u00a0\u00a0seti.ini \u00a0\u00a0\u00a0\u00a0atlas.json</p> <p>For more clarification:</p> Directory/File Description src Main script(s) to run test Unit and integration script(s) to run libs .vss libraries containing classes, subs and functions vses .dll or .so C/C++ extensions seti.ini File containing mappings for VoltScript Extensions atlas.json Configuration file of project structure and dependencies"},{"location":"howto/writing/vscode.html","title":"Visual Studio Code IDE","text":"<p>The intended IDE (Integrated Development Environment) for VoltScript projects is Visual Studio Code. To support development, two Visual Studio Code Extensions are provided:</p> <ul> <li>VoltScript Language Support provides core language functionality - compilation, problem notification, syntax symbols.</li> <li>VoltScript Build Management provides dependency management functionality.</li> </ul>"},{"location":"howto/writing/vscode.html#code-view","title":"Code View","text":"<p>VoltScript code is validated as you type. Errors are displayed in various context:</p> <ul> <li>The text is highlighted with a red \"squiggle\" underline.</li> <li>A message is displayed in the Problems view.</li> <li>The file is marked in red in the Explorer view.</li> <li>The relevant symbol is highlighted in red in the Outline view. </li> </ul>"},{"location":"howto/writing/vscode.html#code-snippets","title":"Code Snippets","text":"<p>Code snippets are provided for VoltScript. Note that code snippets look for a prefix, one or more trigger words that are substring-matched against what's typed.</p> <p>Info</p> <p>Regex can't be used for Visual Studio Code snippet prefixes, so \"If\" will match <code>If</code> and <code>End If</code>. The character set is also limited, so for <code>%REM</code> the snippet prefix is just \"REM\".</p> <p>By default, snippet suggestions are accepted with the Enter or Tab key. This can be changed in Preferences \u2192 Settings by changing the Accept Suggestion on Enter setting under Text Editor \u2192 Suggestions.</p> <p>Note</p> <p>Content assist doesn't yet integrate with core language functions and keywords, VoltScript Extension classes or VoltScript Libraries. The out-of-the-box Visual Studio Code content assist will offer suggestions based on open files. Hover documentation isn't yet available.</p> <p>There is a specific code snippet for Volt Foundry boilerplate code, accessed via <code>foundry</code>. For more details, see Volt Foundry script boilerplate.</p>"},{"location":"howto/writing/vscode.html#outline-view","title":"Outline View","text":"<p>Symbols (Classes, Types, Methods, Properties, Variables) are identified in the Outline.</p> <p>Note</p> <p>If the code can't be compiled, outline symbols can't be extracted.</p> <p>Info</p> <p>The Visual Studio Code Outline view automatically contributes a button to collapse all symbols. Alternative, sorting options are available by clicking on the ellipsis (...).</p>"},{"location":"howto/writing/vscode.html#command-palette","title":"Command Palette","text":"<p>Three Command Palette commands are contributed by the Visual Studio Code extensions:</p> <ul> <li>VoltScript: Save &amp; Run Script has a shortcut code F5 and is only available when editing a <code>.vss</code> file.</li> <li>VoltScript: Run Dependency Setup validates or creates the <code>.vss</code> directory in the user's home directory and is only available when editing an <code>atlas.json</code> or <code>atlas-settings.json</code>.</li> <li>VoltScript: Install Dependencies prompts for project directory, <code>atlas.json</code>, <code>atlas-settings.json</code>, and whether to force download of dependencies. This is only available when editing an <code>atlas.json</code> or <code>atlas-settings.json</code>.</li> </ul>"},{"location":"howto/writing/vscode.html#terminal","title":"Terminal","text":"<p>The integrated Terminal also provides the ability to run code from command line.</p>"},{"location":"howto/writing/vscode.html#debugger","title":"Debugger","text":"<p>Debugging is available. For more details, see debugging.</p>"},{"location":"howto/writing/vses.html","title":"Use VoltScript Extensions","text":"<p>VoltScript Extensions are application extensions written in C/C++. </p> <ul> <li>On a Windows operating system, they will have a <code>.dll</code> suffix. </li> <li>On a Mac operating system, they will have a <code>.dylib</code> suffix.  </li> <li>On a Linux operating system, they will have a <code>.so</code> suffix. </li> </ul> <p>They must be compiled as 64-bit extensions, because the VoltScript runtime is only available for 64-bit.</p> <p>Note</p> <p>Domino developers may not be aware, but they're familiar with extensions which (for LotusScript) are referred to as LSXs. Virtually all LotusScript code depends on at least one LSX, lsxbe. This is added to scripts and compilation paths automatically by Domino Designer, and the install process of Notes or Domino automatically registers the relevant extensions with the operating system.</p> <p>Third party LSXs in LotusScript would need to be registered on the operating system and explicitly referenced using <code>UseLSX...</code> syntax.</p>"},{"location":"howto/writing/vses.html#setiini","title":"seti.ini","text":"<p>Unlike LotusScript LSXs on Windows, VoltScript Extensions don't need to be registered with the operating system explicitly. They can be lazy-loaded at compile-time, either with a literal path or referenced in a seti.ini file. The latter is the recommended best practice.</p> <p>If you are using VoltScript Dependency Management, the <code>seti.ini</code> will be created automatically for you. If not, you will need to create it manually.</p>"},{"location":"howto/writing/vses.html#dependency-management","title":"Dependency management","text":"<p>It's recommended to include VoltScript Extensions via dependency management. This will automatically download and extract the files, and create the <code>seti.ini</code>. For details of what to add to your atlas.json, see references on VoltScript Extensions.</p> <p>Troubleshooting</p> <p>If the VoltScript Dependency Manager fails, review the information printed to the console. An atlas-settings.json will be required for dependencies pulled from GitHub or from a web server that requires authentication. The dependencies will be downloaded to the .vss directory in the user's home before being copied to the project. If using a dev container, this will be the user's home in the container.</p>"},{"location":"howto/writing/vses.html#relative-absolute-paths","title":"Relative / Absolute Paths","text":"<p>The <code>seti.ini</code> contains mappings of extension names to file paths for Windows and Linux operating systems. As with <code>Use</code> statements, the paths can be absolute or relative. Relative paths ensure consistency across environments.</p> <p>Note</p> <ul> <li>Relative paths should be relative to the location of <code>seti.ini</code>.</li> <li>Prefixing with \"./\" will map relative to the <code>seti.ini</code> location.</li> <li>Using forward slashes ensures consistent format.</li> <li>Dependency management will auto-generate the <code>seti.ini</code> if it doesn't exist or force argument is set to <code>true</code>.</li> </ul>"},{"location":"howto/writing/vses.html#file-format-rules","title":"File Format Rules","text":"<p>The key aspects to remember are:</p> <ul> <li>The file must be named seti.ini.</li> <li> <p>Line endings must be LF, not CRLF. This is required for both Linux and Windows, even though the default line ending setting for Windows is CRLF. In Visual Studio Code, the line ending can be changed in the bottom-right of the IDE. </p> <p></p> </li> <li> <p>The file must include a blank line at the end.</p> </li> <li>Mappings to Windows .dll files are in a section starting <code>[VoltScriptExtensions\\2.0\\Windows]</code>.</li> <li>Mappings to Mac .dylib files are in the section starting <code>[VoltScriptExtensions\\2.0\\Mac]</code>.</li> <li>Mappings to Linux .so files (Docker container) are in a section starting <code>[VoltScriptExtensions\\2.0\\Linux]</code>.</li> <li>Mappings are in format ALIAS=PATH. The alias is the name used in the <code>UseVSE</code> statement.</li> </ul>"},{"location":"howto/writing/vses.html#sample-setiini","title":"Sample seti.ini","text":"<p>A sample seti.ini is:</p> <pre><code>[LotusScriptExtensions\\2.0\\Windows]\nJsonVSE=./vses/JsonVSE.dll\n\n[VoltScriptExtensions\\2.0\\Mac]\nJsonVSE=./vses/libjsonvse.dylib\n\n[LotusScriptExtensions\\2.0\\Linux]\nJsonVSE=./vses/libjsonvse.so\n</code></pre> <p>This will map the name \"JsonVSE\" on either operating system to an extension in a \"vses\" directory at the same level as the <code>seti.ini</code> file.</p> <p>The <code>seti.ini</code> can be loaded when a script is run by passing the --seti option to the VoltScript program.</p>"},{"location":"howto/writing/vses.html#usevse-statement","title":"UseVSE Statement","text":"<p>The extension can be included in a script file by using the <code>UseVSE</code> statement. This takes two string formats:</p> <ul> <li>\"*EXTENSION_NAME\", mapping to the name defined in the <code>seti.ini</code>, such as <code>UseVSE \"*JsonVSE\"</code>.</li> <li>\"EXTENSION_PATH\", with an absolute path to the extension, including the <code>.so</code>, <code>.dll</code>, or <code>.dylib</code> extension.</li> </ul> <p>Obviously, the latter requires the same directory setup in all environments and is only recommended for quick one-off scripts.</p> <p>Note</p> <p><code>UseLSX</code> is still aliased, so could be used. But <code>UseVSE</code> is recommended.</p>"},{"location":"references/index.html","title":"References","text":"<p>References cover documentation for individual functions and API documentation for VoltScript Extensions.</p>"},{"location":"references/index.html#voltscript-language-reference","title":"VoltScript language reference","text":"<p>Currently, this documentation only covers new language functions added to VoltScript. For any other language functions, pre-existing to LotusScript\u00ae, see LotusScript Language Reference.</p>"},{"location":"references/index.html#voltscript-extensions","title":"VoltScript Extensions","text":"<p>A number of VoltScript Extensions have been developed by HCL.</p>"},{"location":"references/index.html#voltscript-libraries","title":"VoltScript Libraries","text":"<p>A number of VoltScript Libraries have been developed by HCL.</p>"},{"location":"references/index.html#documentation-and-source-code","title":"Documentation and source code","text":"<ul> <li>HCL Volt MX Go Documentation</li> <li>VoltScript Collections<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Testing<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript JSON Converter<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Console Colors<ul> <li>Source code</li> </ul> </li> <li>VoltScript Interface Designer<ul> <li>Source Code</li> <li>Documentation</li> </ul> </li> <li>VoltScript Volt MX Middleware<ul> <li>Source Code</li> <li>Documentation</li> </ul> </li> <li>VoltScript Logging<ul> <li>Source Code</li> <li>Documentation</li> </ul> </li> </ul>"},{"location":"references/index.html#support","title":"Support","text":"<p>To share information, ask questions, and learn about VoltScript, go to the Community.</p>"},{"location":"references/archipelago.html","title":"Dependency Management Process","text":""},{"location":"references/archipelago.html#install-dependencies","title":"Install dependencies","text":"<p>Dependency management will:</p> <ul> <li>Call <code>runSetup()</code> to check for and, if required, create the <code>.vss</code> directory.</li> <li>Call <code>loadArgs()</code> to prompt for project directory, <code>atlas.json</code> location, <code>atlas-settings.json</code> location and whether or not to force download of dependencies.</li> <li>Call <code>loadSettings()</code> to validate and convert <code>atlas-settings.json</code> into a VoltScript object (a <code>Map</code> of <code>AtlasWebServerSettings</code> or <code>AtlasGitHubSettings</code>).</li> <li>Call <code>loadAtlas()</code> to validate and convert <code>atlas.json</code> into an <code>Atlas</code> VoltScript object.</li> <li>Call <code>buildProjectDirectories()</code> to create directories for sourceDir, testDir, libsDir and vsesDir properties.</li> <li>Convert the <code>Atlas</code> object into an <code>EffectiveAtlas</code>.</li> <li>Call <code>EffectiveAtlas.identifyDependenciesToDownload</code> to dentify any dependencies in <code>atlas.json</code> that can't be found locally. If the user chose to force download of dependencies, this is all dependencies.</li> <li>Call <code>downloadDirectDependencies()</code> to call <code>downloadDependency()</code> for any dependencies explicitly referenced in the <code>atlas.json</code> that weren't found locally. If an <code>atlas.json</code> was downloaded, the dependency is added to a queue to process for downstream dependencies.</li> <li>Call <code>downloadDownstreamDependencies()</code> to iterate the queue of dependencies that were downloaded with an <code>atlas.json</code>. That <code>atlas.json</code> is loaded into an <code>Atlas</code> VoltScript object and converted to an <code>EffectiveAtlas</code> VoltScript object. Any dependencies not already processed are downloaded. If an <code>atlas.json</code> was also downloaded, the dependency is added to the bottom of the queue.</li> <li>Call <code>copyDependencies()</code> to copy VoltScript Libraries from user's <code>.vss</code> directory to libsDir. VoltScript Extensions are extracted into vsesDir, depending on runtimePlatforms property, and the platform-specific names of the actual VoltScript Extension identified.</li> <li>Call <code>CreateSetiIni()</code> to create a seti.ini for any VoltScript extensions, if seti.ini doesn't exist or force is set to <code>true</code>. Otherwise, the existing seti.ini won't be updated.</li> <li> <p>Call <code>copyMiscFiles()</code> to sync between sourceDir and testDir any <code>.vss</code> files not included in mainScripts, unitTestScript and integrationTestScripts. </p> <p>Note</p> <p>This only runs if <code>libsDir</code> isn't set.</p> </li> <li> <p>Create an effective-atlas.json with verbose details of actual versions, actual locations, and actual repositories used. This can be used to troubleshoot unexpected behavior.</p> <p>Note</p> <p><code>effective-atlas.json</code> should be excluded in your <code>.gitignore</code>.</p> </li> </ul>"},{"location":"references/archipelago.html#list-dependencies","title":"List dependencies","text":"<p>The \"list dependencies\" process is similar, except VSEs are not downloaded. The atlas.json of VoltScript Libraries needs to be downloaded to check downbstream dependencies. The list process will:</p> <ul> <li>Call <code>runSetup()</code> to check for and, if required, create the <code>.vss</code> directory.</li> <li>Call <code>loadCheckArgs()</code> to prompt for project directory, <code>atlas.json</code> location, <code>atlas-settings.json</code> location.</li> <li>Call <code>loadSettings()</code> to validate and convert <code>atlas-settings.json</code> into a VoltScript object (a <code>Map</code> of <code>AtlasWebServerSettings</code> or <code>AtlasGitHubSettings</code>).</li> <li>Call <code>loadAtlas()</code> to validate and convert <code>atlas.json</code> into an <code>Atlas</code> VoltScript object.</li> <li>Call <code>buildProjectDirectories()</code> to create directories for sourceDir, testDir, libsDir and vsesDir properties.</li> <li>Convert the <code>Atlas</code> object into an <code>EffectiveAtlas</code>.</li> <li>Call <code>EffectiveAtlas.identifyDependenciesToDownload</code> to dentify any dependencies in <code>atlas.json</code> that can't be found locally. If the user chose to force download of dependencies, this is all dependencies.</li> <li>Call <code>downloadDirectDependencies()</code> to call <code>downloadDependency()</code> for any VoltScript Library dependencies explicitly referenced in the <code>atlas.json</code> that weren't found locally. If an <code>atlas.json</code> was downloaded, the dependency is added to a queue to process for downstream dependencies.</li> <li>Call <code>downloadDownstreamDependencies()</code> to iterate the queue of dependencies that were downloaded with an <code>atlas.json</code>. That <code>atlas.json</code> is loaded into an <code>Atlas</code> VoltScript object and converted to an <code>EffectiveAtlas</code> VoltScript object. Any dependencies not already processed are downloaded. If an <code>atlas.json</code> was also downloaded, the dependency is added to the bottom of the queue.</li> <li>Call <code>printDependencies()</code> to print out a list of dependencies and any version conflicts.</li> </ul>"},{"location":"references/atlas.html","title":"atlas.json and atlas-settings.json schemas","text":""},{"location":"references/atlas.html#atlasjson-and-atlas-settingsjson-schemas","title":"atlas.json and atlas-settings.json schemas","text":"<p>The VS Code extension will validate both the <code>atlas.json</code> and <code>atlas-settings.json</code> for you. There are snippets available for populating a commented sample of all valid options, which can be retrieved by typing \"atlas\" or \"atlas-settings\".</p> <p></p>"},{"location":"references/atlas.html#atlasjson","title":"atlas.json","text":""},{"location":"references/atlas.html#sample-structure","title":"Sample structure","text":"<p>Note</p> <p>Required properties are highlighted.</p> <p></p>"},{"location":"references/atlas.html#detailed-description","title":"Detailed description","text":"Property Required Description name \u2713 name of your project displayName user-friendly name for the project description \u2713 verbose description of what your project does authors \u2713 an array of names of developers for the project license license under which you wish the project to be available publisher owner of the project, typically your company name repo where the course code can be accessed library group name for the projectIf stored on GitHub, this would be the repository name. version \u2713 current version for the projectSemver format is recommended. sourceDir \u2713 directory where main runnable VoltScript files will be storedIf you wish to place such files in the root of the project, use an empty string (\"\"). testDir directory where unit and integration test runnable VoltScript files will be storedThis can be omitted if tests are being put in the root. libsDir directory where VoltScript Libraries (.vss files) will be stored This can be omitted if they will be put in the root. vsesDir directory where VoltScript Extensions will be storedThis can be omitted if they will be put in the root. mainScripts \u2713 an array of files that are main runnable scripts. unitTestScript an array of files that are unit test runnable scripts. integrationTestScripts an array of files that are integration test runnable scripts. repositories \u2713 an array of repository objects, each containing the following properties:- id: Use to cross-reference with the <code>atlas-settings.json</code>.- type: Currently, only \"github\", \"webserver\", and \"marketplace\" are supported.- url: base URL for API calls to the repository. dependencies \u2713 an array of dependency objects mapping to VoltScript files to use. The dependency contains three properties:- library: The group under which the <code>.vss</code> files and their own <code>atlas.json</code> are grouped.- version: an explicit version number mapping to a release, or \"latest\" to also retrieve the most recent- module: the specific file to be incorporated- repository: an optional property mapping to a repository IDIf used, Archipelago will look in that repository first. testDependencies \u2713 an array of dependency objects mapping to VoltScript files only for use in unit and integration tests. The dependency structure if the same as for dependencies vseDependencies \u2713 an object of extension dependency objects mapping to extensions to use. The extension dependency is a JSON object whose label is the name you intend to use in the <code>UseVSE</code> statement, and which has the following properties:- library: the group under which the VoltScript Extension(s) are grouped. For Volt MX Marketplace, this is VSE title on the marketplace, e.g. \"JsonVSE VoltScript Extension\".- version: a human-readable version corresponding to an asset version on Volt MX Marketplace. \"latest\" is not supported.- module: the specific filename to be downloaded. For Volt MX Marketplace, this will be the asset filename without the extension, e.g. \"jsonvse\". runtimePlatforms only relevant is vseDependencies is set. An array of platforms for which to copy VSE dependencies into the project. If omitted or an empty array, the VSE files for all platforms will be copied into the project. If defined, only the VSE files for the relevant platforms will be used.For example, if the array is [\"Windows64\"] only the .dll files for each VSE will be copied into the project and the code can only be run and deployed to a Windows server.Valid options are: Windows64, LINUX, MACOS. Mac dylibs can and have been cross-compiled for both Intel and ARM processors, so only a single platform option is required for MacOS. Currently only Linux-x64 is supported, a future release will add Linux-aarch64 support and a separate option. <p>Note</p> <p>If you have the VoltScript Build Manager extension installed, validation in Visual Studio Code ensures your <code>atlas.json</code> is valid. Typing \"atlas\" allows you to pull in a snippet providing all possible options and comments.</p>"},{"location":"references/atlas.html#atlas-settingsjson","title":"atlas-settings.json","text":""},{"location":"references/atlas.html#sample-structure_1","title":"Sample structure","text":"<p>Within each repository JSON object, all properties are required.</p>"},{"location":"references/atlas.html#detailed-description_1","title":"Detailed description","text":"<p>The label for each settings JSON object should be the id used for that repository in the <code>atlas.json</code>. The schema for each settings object is:</p> Property Required Description type \u2713 either \"github\", \"webserver\", or \"marketplace token \u2713 only accepted where <code>type</code> is \"github\"This is the GitHub Personal Access Token. credentials \u2713 only accepted where 'type' is \"webserver\"a Base64-encoded string of the username + \":\" + password username \u2713 only accepted where 'type' is \"marketplace\"The username to log into Volt MX Marketplace password \u2713 only accepted where 'type' is \"marketplace\"The password to log into Volt MX Marketplace authUrl \u2713 only accepted where 'type' is \"marketplace\"The login URL for Volt MX Marketplace, https://accounts.auth.demo-hclvoltmx.net/login <p>A sample atlas-settings file sould look something like this:</p> <pre><code>{\n    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    },\n    \"my-web-server\": {\n        \"type\": \"webserver\",\n        \"credentials\": \"${env.CRED}\"\n    },\n    \"volt-mx-marketplace\": {\n        \"type\": \"marketplace\",\n        \"username\": \"${env.USERNAME}\",\n        \"password\": \"${env.PASSWORD}\",\n        \"authUrl\": \"https://accounts.auth.demo-hclvoltmx.net/login\"\n    }\n}\n</code></pre> <p>Warning</p> <p>The <code>atlas-settings.json</code> is a JSON object of settings for repositories in an <code>atlas.json</code>. As a result, you won't get content assist at the top level. You'll only receive content assist for each settings JSON object. Typing \"atlas-settings\" enables you to pull in a snippet providing all possible options and comments.</p> <p>See Using VoltScript Build Manager for more details.</p>"},{"location":"references/components.html","title":"VoltScript Components","text":"<p>VoltScript comprises multiple components delivered via different methods. This can be confusing. This page aims to demystify what comes from where, for which audience, for what purpose.</p> <p></p>"},{"location":"references/components.html#download-retrieval-locations","title":"Download / Retrieval Locations","text":"Location Artefact Purpose My HCLSoftware Windows installer Develop VoltScript on WindowsRun standalone VoltScript code on Windows My HCLSoftware Mac installer Develop VoltScript on any MacRun standalone VoltScript code on Intel/ARM Mac Harbor Linux Container Image Develop VoltScript on any platform using VS Code Dev Containers Harbor Volt Foundry Container Image Upload or code VoltScriptintegration services on Volt Foundry Volt MX Marketplace VoltScript Extensions Provides closed-source low-level functionalityAdd via build managementImport into VoltScript integration service zip HCL GitHub org VoltScript Library Modules Provides open source helpersAdd via build managementDownload from Releases and upload to VoltScript integration service zip <p>For Volt Foundry, see the Volt Foundry documentation, paying special notice to the Enable VoltScript in Volt Foundry how-to guide in the Volt MX Go documentation.</p>"},{"location":"references/components.html#audience","title":"Audience","text":""},{"location":"references/components.html#administrators","title":"Administrators","text":"<p>Administrators will only require Volt Foundry. For more information, see the Enable VoltScript in Volt Foundry how-to guide in the Volt MX Go documentation.</p>"},{"location":"references/components.html#developers","title":"Developers","text":"<p>Developers' starting point will depend on their development approach:</p> <ul> <li>For developers wishing to develop VoltScript code locally:<ul> <li>On Windows, download the Windows installer and follow instructions in the relevant tutorial.</li> <li>On any Mac, download the Mac installer and follow instructions in the relevant tutorial.</li> <li>On any platform, download the Linux dev container image and follow instructions in the relevant tutorial.</li> </ul> </li> <li>For developers wishing to write their code directly into a Volt Foundry, see the Enable VoltScript in Volt Foundry how-to guide in the Volt MX Go documentation.</li> </ul> <p>Note</p> <ul> <li>VoltScript integration service projects can be coded locally and uploaded into Volt Foundry, or they can be coded directly into Volt Foundry. Better IDE integration is currently possible with local development on Visual Studio Code, plus the ability to write and run unit tests. If you know the APIs and are willing to accept that compile-time errors are only exposed at runtime, developing directly on Volt Foundry may be quicker.</li> <li>A container image is not currently available for ARM-based Mac. The Linux container image for Intel Mac may work, but is unsupported.</li> <li>As with Volt MX Go early access program, only a containerized image of Volt Foundry is provided.</li> </ul>"},{"location":"references/components.html#voltscript-extensions","title":"VoltScript Extensions","text":"<p>Developers should not download the VoltScript extensions from the Volt MX Marketplace. However, you will need credentials for Volt MX Marketplace, see Volt MX Marketplace how-to.</p> <p>For locally-based development, the Archipelago build management system should be used to pull down extensions.</p> <p>For development directly on Volt Foundry, you can import directly from the Volt MX Marketplace. You will prompted for the username and password for Volt MX Marketplace.</p>"},{"location":"references/components.html#voltscript-library-modules","title":"VoltScript Library Modules","text":"<p>For locally-based development, the Archipelago build management system should be used to pull down VoltScript Library Modules. This will automatically pull in downstream dependencies.</p> <p>For development directly on Volt Foundry, you will need to download the scripts from the Releases area of the relevant repo, then upload to Volt Foundry. You will need to ensure you pull in the relevant dependencies, which can be confirmed by looking at the relevant atlas.json.</p>"},{"location":"references/dependency-map.html","title":"Dependency Map","text":"<p>The following diagram shows dependency map between dependency management script (archipelago), VoltScript Library Modules and VoltScript Extensions:</p> <p></p> <p>All VoltScript Extension and VoltScript Library Module repositories depend on VoltScript Testing for unit tests. But these are just used as test dependencies, not compile-time dependencies.</p>"},{"location":"references/libraries.html","title":"VoltScript Library Modules","text":"<p>VoltScript Libraries are <code>.vss</code> files with provided classes, subs, and functions for use in the main and test scripts. They shouldn't have a <code>Sub Initialize</code>.</p> <p>For documentation on HCL-developed VoltScript Libraries, see:</p> <ul> <li>VoltScript Testing provides classes for unit-/integration-testing and validation. <ul> <li>Source Code </li> <li>Documentation </li> </ul> </li> <li>VoltScript JSON Converter provides classes for configured deserialization / serialization of JSON. <ul> <li>Source Code </li> <li>Documentation</li> </ul> </li> <li>VoltScript Collections provides Collection, Map and Pair classes. <ul> <li>Source Code</li> <li>Documentation</li> </ul> </li> <li>VoltScript Console Colors provides constants for changing the console colors when printing to a terminal that supports this functionality. <ul> <li>Source Code</li> </ul> </li> <li>VoltScript Volt MX Middleware provides classes for interacting with context and updating results for Volt Foundry. <ul> <li>Source Code</li> <li>Documentation</li> </ul> </li> <li>VoltScript Logging provides classes for error tracking and logging. <ul> <li>Source Code</li> <li>Documentation</li> </ul> </li> </ul> <p>Within this documentation you can access aggregated API Docs.</p>"},{"location":"references/libraries.html#dependency-management","title":"Dependency management","text":"<p>Dependency management is available in the documentation for each project, but also aggregated here:</p>"},{"location":"references/libraries.html#authentication","title":"Authentication","text":"<p>You'll need a Personal Access Token to use GitHub REST APIs. You'll then need to add this to the JSON object in your atlas-settings.json, in the .vss directory of your user home directory:</p> <pre><code>    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    }\n</code></pre>"},{"location":"references/libraries.html#repository","title":"Repository","text":"<p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>        {\n            \"id\": \"hcl-github\",\n            \"type\": \"github\",\n            \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n        }\n</code></pre>"},{"location":"references/libraries.html#dependency","title":"Dependency","text":"<p>You'll need the relevant dependency to add to your dependencies or testDependencies object in the atlas.json of your project:</p> <pre><code>        {\n            \"library\": \"voltscript-testing\",\n            \"version\": \"1.0.1\",\n            \"module\": \"VoltScriptTesting.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre> <pre><code>        {\n            \"library\": \"voltscript-json-converter\",\n            \"version\": \"1.0.5\",\n            \"module\": \"VoltScriptJsonConverter.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre> <pre><code>        {\n            \"library\": \"voltscript-collections\",\n            \"version\": \"1.0.5\",\n            \"module\": \"VoltScriptCollections.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre> <pre><code>        {\n            \"library\": \"voltscript-console-colors\",\n            \"version\": \"1.0.1\",\n            \"module\": \"VoltScriptConsoleColors.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre> <pre><code>        {\n            \"library\": \"voltscript-voltmx-middleware\",\n            \"version\": \"1.0.5\",\n            \"module\": \"VoltMXObjects.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre> <pre><code>        {\n            \"library\": \"voltscript-logging\",\n            \"version\": \"1.0.1\",\n            \"module\": \"VoltScriptLogging.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre> <p>Troubleshooting</p> <p>If the VoltScript Dependency Manager fails, review the information printed to the console. An atlas-settings.json will be required for dependencies pulled from GitHub or from a web server that requires authentication. The dependencies will be downloaded to the .vss directory in the user's home before being copied to the project. If using a dev container, this will be the user's home in the container.</p> <p>Note</p> <p>VoltScript code is compiled for the platform at runtime. As a result, unlike VoltScript Extensions (VSEs), you don't need to worry about the runtime platform of your custom VoltScript code when sharing code.</p>"},{"location":"references/options.html","title":"Runtime options","text":"<p>The following options are available when starting the VoltScript runtime:</p> Option Description -c Compiles only, doesn't run any code --context &lt;context&gt; Sends a string of text, passed after the option, that can be picked up using ContextVSE.  Note: There are operating system limitations on what content can be passed as part of the string. --no-utf8 Treats the source file as platform character set --debug-server  Starts the debug server on the specified port --headless, -H Sets headless mode, msgbox calls are routed to print statements --help, -h Shows the options available --http-server  Starts the HTTP server on the specified port --path, -I &lt;path&gt; Sets the path to look for the given scripts --seti, -X &lt;path&gt; Uses a seti.ini at the relevant path to identify file locations for any VoltScript extensions --verbose, -v Enables verbose output --version Shows the BaliScript version string"},{"location":"references/unsupported.html","title":"Unsupported functions","text":""},{"location":"references/unsupported.html#inputbox","title":"InputBox","text":"<p>The <code>InputBox</code> function can't be used in VoltScript, because there are no UI elements to display the content.</p>"},{"location":"references/unsupported.html#messagebox","title":"MessageBox","text":"<p>The <code>MessageBox</code> or <code>MsgBox</code> function and statement should be avoided. VoltScript is designed to run as middleware, so a prompt that blocks processing and requires user interaction will have unexpected outcomes. The <code>--headless</code> option when running VoltScript can convert any <code>MessageBox</code> calls into <code>Print</code> statements. The best practice is to avoid using <code>MessageBox</code>.</p>"},{"location":"references/unsupported.html#sendkeys","title":"SendKeys","text":"<p><code>SendKeys</code> is used to enter keystrokes in the active window as if they were entered from the keyboard. This is not supported in Notes / Domino on UNIX or MacOS platforms. It also makes no sense a VoltScript environment, so is unsupported but with no intention to remove from the runtime engine.</p>"},{"location":"references/unsupported.html#asc-chr-uni-and-multi-byte-character-sets","title":"Asc(), Chr(), Uni() and multi-byte character sets","text":"<p>We are aware of an issue with <code>Asc()</code> and <code>Chr()</code> when using multi-byte characters. The problem has been identified with 3 byte Thai characters. The problem is likely to also affect <code>Uni()</code> There are no plans to fix at this point.</p>"},{"location":"references/unsupported.html#other-functions","title":"Other functions","text":"<p>Some other functions do not make sense in a VoltScript context, like <code>CreateObject</code>, <code>IMESetMode</code>, <code>IMEStatus</code>, <code>IsUnknown</code>, <code>Shell</code>, <code>ShellID</code>, <code>Stop</code>, <code>Yield</code>.</p>"},{"location":"references/vses.html","title":"VoltScript Extensions","text":"<p>VoltScript Extensions are closed-source C/C++ binaries, <code>.dll</code> files on Windows, and <code>.so</code> files on Linux. The are hosted on Volt MX Marketplace. Some leverage other C/C++ libraries, for example libcurl. The following VoltScript Extensions are available:</p> <p>Note: Click the links to view the API Docs.</p> <ul> <li>ContextVSE provides access to command line <code>--context</code> argument.</li> <li>CouchVSE provides a layer for integrating with CouchDB.</li> <li>DrapiVSE: provides a layer for making calls to Domino REST API.</li> <li>HashVSE provides hashing and cryptographic utilities.</li> <li>JsonVSE provides utilities for manipulating JSON.</li> <li>OSUtilVSE provides utilities for integrating with the operating system.</li> <li>StreamVSE provides utilities for reading/writing files and STDIO.</li> <li>WebVSE provides utilities for making HTTP(s) calls via libcurl.</li> <li>XMLVSE provides utilities for manipulating XML.</li> <li>ZipVSE provides utilities for reading/writing zip files. This can't read / write <code>.tar.gz</code> files.</li> <li>ZuluVSE provides utilities for reading/writing UTC date/times.</li> </ul> <p>You can also access aggregated API Docs.</p>"},{"location":"references/vses.html#dependency-management","title":"Dependency management","text":"<p>VoltScript Extensions for dependency management are hosted in Volt MX Demo Marketplace. You'll need three parts:</p>"},{"location":"references/vses.html#logon","title":"Logon","text":"<p>You'll need a username and password for Volt MX Marketplace. Make sure you've tested successfully logging into the web interface before using it for dependency management. You'll then need to add this to the JSON object in your atlas-settings.json, in the .vss directory of your user home directory:</p> <pre><code>    \"volt-mx-marketplace\": {\n        \"type\": \"marketplace\",\n        \"username\": \"YOUR_USERNAME\",\n        \"password\": \"YOUR_PASSWORD\",\n        \"authUrl\": \"https://accounts.auth.demo-hclvoltmx.net/login\"\n    }\n</code></pre>"},{"location":"references/vses.html#repository","title":"Repository","text":"<p>You'll need to add to your repositories object in the atlas.json of your project:</p> <pre><code>        {\n            \"id\": \"volt-mx-marketplace\",\n            \"type\": \"marketplace\",\n            \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n        }\n</code></pre>"},{"location":"references/vses.html#dependency","title":"Dependency","text":"<p>You'll need the relevant dependency to add to your vseDependencies object in the atlas.json of your project:</p> <pre><code>        \"ContextVSE\": {\n            \"library\": \"ContextVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"contextvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"CouchVSE\": {\n            \"library\": \"CouchVSE VoltScript Extension\",\n            \"version\": \"1.0.3\",\n            \"module\": \"couchvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"DrapiVSE\": {\n            \"library\": \"DrapiVSE VoltScript Extension\",\n            \"version\": \"1.0.0\",\n            \"module\": \"drapivse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"HashVSE\": {\n            \"library\": \"HashVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"hashvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"JsonVSE\": {\n            \"library\": \"JsonVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"jsonvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"OSUtilsVSE\": {\n            \"library\": \"OSUtilsVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"osutilsvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"StreamVSE\": {\n            \"library\": \"StreamVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"streamvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"WebVSE\": {\n            \"library\": \"WebVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"webvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"XmlVSE\": {\n            \"library\": \"XMLVSE VoltScript Extension\",\n            \"version\": \"1.0.3\",\n            \"module\": \"xmlvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"ZipVSE\": {\n            \"library\": \"ZipVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"zipvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <pre><code>        \"ZuluVSE\": {\n            \"library\": \"ZuluVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"zuluvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n</code></pre> <p>Troubleshooting</p> <p>If the VoltScript Dependency Manager fails, review the information printed to the console. An atlas-settings.json will be required for dependencies pulled from GitHub or from a web server that requires authentication. The dependencies will be downloaded to the .vss directory in the user's home before being copied to the project. If using a dev container, this will be the user's home in the container.</p>"},{"location":"references/vses.html#platform-support","title":"Platform Support","text":"<p>VoltScript Extensions need to be compiled for specific platforms:</p> <ul> <li>.dll are extensions for Windows. Remember, VoltScript only supports 64-bit Windows.</li> <li>.so are extensions for Linux-x64. Currently VoltScript only support Linux-x64. Linux-aarch64 support will follow later, but will require different files.</li> <li>.dylib are extensions for MacOS. Platform libraries for MacOS can be cross-compiled, so the same file can be used on MacOS with Intel or ARM processor.</li> </ul> <p>You will need to ensure the VoltScript project and dependency management is set up to support all runtime platforms, both for development and deployment.</p>"},{"location":"references/whatsnew/index.html","title":"New Language Features","text":"<p>This is the list of new functions available in VoltScript.</p> <ul> <li>GetThreadInfo</li> <li>Return</li> <li>Try/Catch/Finally</li> <li>Number Manipulation</li> <li>!= alias</li> <li>Short-Circuit Conditionals</li> <li>CreateUUID()</li> </ul>"},{"location":"references/whatsnew/getthreadinfo.html","title":"GetThreadInfo","text":"<p>GetThreadInfo function is pre-existing in LotusScript, but has been extended in VoltScript.</p> <p>The LSI constants available with LotusScript aren't included by default, so the integer indices will be needed instead. The full table with indices, including the new options, is below:</p> Index Code (Not in VoltScript) Meaning 0 LSI_THREAD_LINE Current line number from file 1 LSI_THREAD_PROC Name of current procedure 2 LSI_THREAD_MODULE Name of current module 3 LSI_THREAD_VERSION LotusScript\u00ae version number 4 LSI_THREAD_LANGUAGE OS (Human) language setting 5 LSI_THREAD_COUNTRY OS Country or region setting 6 LSI_THREAD_TICKS Get current clock ticks* 7 LSI_THREAD_TICKS_PER_SEC Get clock ticks per second (supported only on platforms that support parallel processing primitives) 8 LSI_THREAD_PROCESS_ID Get current process ID (supported only on platforms that support parallel processing primitives) 9 LSI_THREAD_TASK_ID Get current task ID (supported only on platforms that support parallel processing primitives) 10 LSI_THREAD_CALLPROC Get the name of the calling procedure 11 LSI_THREAD_CALLMODULE Get the name of the calling module 12 Get stack trace, comprising calling module (script file), class (or an empty string, if not in a class), calling procedure (sub/function name), and line numberNote: Do not include <code>.</code> in your filename, because manipulation of the module name strips everything after the first <code>.</code>. 13 Get platform (WIN64, LINUX64, MACARM, MACX86) 14 Get current memory 15 Get memory used 16 Get memory available <ul> <li>On Windows this always returns 2147483647</li> </ul>"},{"location":"references/whatsnew/notequal.html","title":"Inequality Operator Alias","text":"<p>In LotusScript, a boolean inequality check in an <code>If</code> statement is done using <code>&lt;&gt;</code>. For better consistency with other languages VoltScript has introduced the alias <code>!=</code>. Both can be used and there is no difference in how they work, so the following two code blocks will both work the same.</p> <pre><code>Function checkEmptyString(passedVal as String) as Boolean\n    If (passedVal &lt;&gt; \"\") Then\n        Return True\n    Else\n        Return False\n    End If\nEnd Function</code></pre> <pre><code>Function checkEmptyString(passedVal as String) as Boolean\n    If (passedVal != \"\") Then\n        Return True\n    Else\n        Return False\n    End If\nEnd Function</code></pre> <p>Note</p> <p>The code is more verbose than necessary, to clearly illustrate the new syntax. <code>Return passedVal != \"\"</code> would be valid code and more terse.</p> <p>The syntax can be used for numerics as well as strings:</p> <pre><code>Function checkNotZero(passedVal as Integer) as Boolean\n    If (passedVal != 0) Then\n        Return True\n    Else\n        Return False\n    End If\nEnd Function</code></pre>"},{"location":"references/whatsnew/orelseandalso.html","title":"Short-Circuit Conditionals","text":"<p>Short-Circuit Evaluation is a programming mechanism by which evaluation of a condition ceases as soon as the result of the condition can be determined.  Attitional comparisons are considered redundant and ignored.</p> short-circuit comparisons <p>In LotusScript (from which VoltScript evolved), <code>And</code> and <code>Or</code> comparisions always evaluate every condition (both sides of the comparison operator), which can result in ineffecient code (or sometimes code failures).   Short Circuit comparisons (<code>||</code> for <code>Or</code>, and <code>&amp;&amp;</code> for <code>And</code>) will cease comparison at the first condition which logically ends the need for additional comparisons, and will not evaulate additional conditions. The following code example should help: <pre><code>Dim a as Integer\nDim b as Integer\nDim c as Integer\n\na = 1 \nb = 2 \nc = 3 \n\nIf (a &lt; b) || (b &lt; c) Then Print \"True: evaluated first condition, skipped second condition\"\nIf (a &lt; b) &amp;&amp; (b &lt; c) Then Print \"True: evaluated both conditions\"\nIf (a &gt; b) || (b &gt; c) Then Print \"False: evaluated both conditions\"\nIf (a &gt; b) &amp;&amp; (b &gt; c) Then Print \"False: evaluted first condition, skipped second condition\"</code></pre></p>"},{"location":"references/whatsnew/orelseandalso.html#orelse","title":"|| (OrElse)","text":"<p>An <code>If...Then...Else</code> statement can contain multiple conditional statements. If a logical OR statement is used in LotusScript, all the conditional statements will be executed, regardless of the outcome.</p> <pre><code>Class Student\n    Public ID As Long\n    Public Name As String\n    Public Score As Single\nEnd Class\n\nSub orFail\n    Dim obj as Student\n    If (obj is Nothing Or obj.Name != \"\") Then\n        Print \"Student not initialized\"\n    End If\nEnd Sub\n</code></pre> <p>When running the <code>orFail</code> method, the above code will throw an \"Object Variable Not Set\" error on line 8 because both conditional statements will be executed, which means <code>obj.Name</code> will be checked even though <code>obj is Nothing</code> returns true.</p> <p>VoltScript provides a short-circuit OR operator, <code>||</code>. This performs like Visual Basic's <code>OrElse</code> operator, running the minimum conditional statements required. The following code will not throw an error and continue to the <code>Return</code> statement.`</p> <pre><code>Function orSuccess as String\n    Dim obj as Student\n    If (obj is Nothing || obj.Name != \"\") Then\n        Print \"Student not initialized\"\n    End If\n    Return \"Success\"\nEnd Function</code></pre> <p>Danger</p> <p>Because <code>||</code> represents either an empty string or an <code>OrElse</code> indicator, using both of them in the same line of code (without forced grouping) will not compile.  The use of either parentheses or breaking the code into multiple lines is recommended.  </p> <pre><code>    If passedStr = \"\" || args(0) = \"\" Then  ' &lt;&lt; This line will not compile \n\n    If (passedStr = \"\") || args(0) = \"\" Then  ' &lt;&lt; Use this pattern instead</code></pre> <p>Warning</p> <p><code>Print</code> can also take a string of values, e.g. <code>Print \"One\" \"Two\" \"Three\"</code>. The recommended best practice is to concatenate strings with ampersand. <code>Or</code> is valid in a Print statement, e.g. <code>Print True or False</code>, but undocumented for LotusScript and with limited use cases. <code>||</code> in a Print statement runs as \"OrElse\" and is strongly discouraged.</p>"},{"location":"references/whatsnew/orelseandalso.html#andalso","title":"&amp;&amp; (AndAlso)","text":"<p>If a logical AND statement is used in LotusScript, all the conditional statements will also be executed, regardless of the outcome. So in the following code, both conditions will be checked, even if the <code>obj.Name</code> condition is not met.</p> <pre><code>Sub andFail\n    Dim obj as New Student\n    If (obj.Name != \"\" And obj.Score &gt; 90) Then\n        Print \"High-score valid student\"\n    End If\nEnd Sub</code></pre> <p>VoltScript provides a short-circuit AND operator, <code>&amp;&amp;</code>. This performs like Visual Basic's <code>AndAlso</code> operator, running the minimum conditional statements required. The following code will not run the <code>obj.Score</code> condition if <code>obj.Name</code> is blank.</p> <pre><code>Function andSuccess as String\n    Dim obj as New Student\n    If (obj.Name != \"\" &amp;&amp; obj.Score &gt; 90) Then\n        Print \"High-score valid student\"\n    End If\n    Return \"Success\"\nEnd Function</code></pre> Why didn't you just change the behavior of And and Or? <p>This is an extremely valid question, and was something the development team discussed at length. Because existing LotusScript business logic code is likely to be imported into VoltScript environments, changing the behavior of these logical operators could break the imported code, which the development team deemed to be unacceptable.  </p> <p>For more details, see Short-circuiting logical expressions.</p>"},{"location":"references/whatsnew/plusplus.html","title":"Number Manipulation","text":""},{"location":"references/whatsnew/plusplus.html#mathematical-assignment-operators","title":"Mathematical Assignment Operators","text":"<p>The following assignment operators have been added:</p> <ul> <li>+=, the addition assignment operator, adds the value of the right operand to a variable and assigns the result to the variable.</li> <li>-=, the subtraction assignment operator, subtracts the value of the right operand from a variable and assigns the result to the variable.</li> <li>*=, the multiplication assignment operator, multiplies the variable by the right operand and assigns the result to the variable.</li> <li>/= and \\=, the division assignment operators, divide the variable by the right operand and assign the result to the variable.</li> </ul> <pre><code>    Dim i as Integer\n    i += 5\n    Print i     ' Prints 5\n    i -= 3\n    Print i     ' Prints 2\n    i *= 4\n    Print i     ' Prints 8\n    i /= 2\n    Print i     ' Prints 4\n    i \\= 2\n    Print i     ' Prints 2</code></pre> <p>Note</p> <p>The assignment operators cannot be combined with another function, e.g. <code>Print i += 2</code> will not compile.</p>"},{"location":"references/whatsnew/plusplus.html#increment-and-decrement-operators","title":"Increment and Decrement Operators","text":"<p>In LotusScript, incrementing a numeric value is done using code such as <code>i = i + 1</code>. VoltScript adds the increment operator (++) and decrement operator (--). These can both be used prefix and postfix.</p> <p>If used postfix (<code>i++</code>) the variable is incremented after it is used. If used prefix (<code>++i</code>) the variable is incremented before it is used.</p> <pre><code>Dim i as Integer\nPrint ++i       ' Prints 1\nPrint i++       ' Prints 1 again, and after printing increments i to 2\nPrint i         ' Prints 2\nPrint --i       ' Prints 1\nPrint i--       ' Prints 1 again, and after printing decrements i to 0\nPrint i         ' Prints 0</code></pre> <p>Warning</p> <p><code>+=</code> can only be used for manipulation of numeric values. It cannot be used for string concatenation.</p>"},{"location":"references/whatsnew/return.html","title":"Return","text":"<p>One of the new features of VoltScript is the <code>Return</code> statement.  This statement immediately ceases operation of any method (Sub, Function, or Property) and returns to the calling code.  If the method is supposed to return a value (such as with a Function or a Property Get), the value which is returned to the calling code will be the value following the <code>return</code> statement.   If no value follows the <code>return</code> statement, then the value that is returned will be the default value for the method's return data type.  (\"\" for Strings, 0 for Integers, etc).  If the metod's return type is an object, then a no-value <code>return</code> statement will return <code>Nothing</code>.</p> <p>Info</p> <p>In LotusScript the way to break out of a sub or function is <code>Exit Sub</code> or <code>Exit Function</code>. In a function, the way to return a value is <code>FUNCTION_NAME =</code>, prepended with <code>Set</code> if the function returns an object.</p> <p>For VoltScript, the LotusScript syntax will still work. But you can also use the <code>Return</code> statement. This is designed to simplify the code and make it more consistent with other languages, including Visual Basic.</p>"},{"location":"references/whatsnew/return.html#subs-and-setter-properties","title":"Subs and Setter Properties","text":"<p><code>Return</code> in a Sub or Setter Property will stop processing and exit the Method.</p> <pre><code>Sub printMessage(msg as String)\n    If msg = \"\" Then Return\n    Print msg  ' &lt;&lt; this line will never execute!!\nEnd Sub  \n\nProperty Set Message(msg As String)\n    Return \n    Me.message = msg  ' &lt;&lt; this line will never execute!!\nEnd Poperty </code></pre> <p>A sub does not return a value, so you cannot pass a value or variable to the Return statement.</p>"},{"location":"references/whatsnew/return.html#functions-and-getter-properties","title":"Functions and Getter Properties","text":"<p>In these methods, <code>Return</code> will work the same as <code>Exit Function</code> or <code>Exit Property</code>, by aborting processing and returning the default value for the method's datatype.</p> <pre><code>Function incrementCounter(counter as Integer) as Integer\n    Try\n        Return ++counter\n    Catch\n        Return  ' If incrementing counter causes an Overflow error\n    End Try\nEnd Function  \n\nProperty Get myTypeName As String \n    Return TypeName(Me) ' returns the TypeName of the carrying class\n\n    myTypeName = TypeName(Me)  ' &lt;&lt; this line will never execute!!\nEnd Property \n\nProperty Get noTypeName As String \n    Return ' returns an empty string\n\n    noTypeName = |no type name|  ' &lt;&lt; this line will never execute!!\nEnd Property </code></pre> <p>For functions, the Return statement can also take a value or variable to return. <code>Set</code> does not need to be prepended, so syntax is identical whether you are returning a scalar/scalar array or an object.</p> <pre><code>UseVSE \"*ZuluVSE\"\nFunction convertDate(incoming as Variant) as Variant\n    Dim dp as New DateTimeParser\n    If (\"STRING\" = TypeName(incoming)) Then\n        Return dp.parseISOString(incoming)  'String -&gt; DateTimeObject\n    Else\n        Return incoming.toISODateTime()     'DateTimeObject -&gt; String\n    End If\nEnd Function</code></pre> <p>Note</p> <p>The syntax of the <code>Return</code> statement is identical for returning a String and a DateTimeObject.</p>"},{"location":"references/whatsnew/return.html#return-and-trycatchfinally","title":"Return and Try/Catch/Finally","text":"<p>Using <code>Return</code> will still respect a Try/Catch/Finally statement. The <code>Finally</code> block(s) will be processed before exiting the sub or function.</p>"},{"location":"references/whatsnew/tcf.html","title":"Try...Catch...Finally","text":"<p>Info</p> <p>Error handling in LotusScript is managed using the <code>On Error</code> statement with GoTo labels and Resume statements.</p> <p>For VoltScript, the LotusScript syntax will still work. But you can also use Try...Catch...Finally syntax.</p> <p>Try...Catch...Finally provides a way to catch specific or generic errors. At the minimum, the Try block must be followed by either a Catch block or a Finally block. The following is not valid syntax:</p> <pre><code>Try\n    ' Do something\nEnd Try</code></pre>"},{"location":"references/whatsnew/tcf.html#catching-specific-and-general-error-codes","title":"Catching Specific and General Error Codes","text":"<p>To catch errors matching a specific error number, use <code>Catch Error</code> and the relevant error code. For example, the following code will catch the Path/File Access error:</p> <pre><code>Try\n    MkDir(passedPath)\nCatch Error 75\n    ' Nothing to do, directory already exists\nCatch\n    Print Error() &amp; \": \" &amp; Erl()\nEnd Try\n</code></pre> <p>The final <code>Catch</code> on line 5 will catch any other error.</p>"},{"location":"references/whatsnew/tcf.html#finally-block","title":"Finally Block","text":"<p>The Finally block will execute after the Try and/or Catch blocks. This can be used to perform any cleanup or reset variables before continuing processing.</p> <pre><code>Type Student\n    ID As Long\n    Name As String ' Variable-length string variable\n    Score As Single\nEnd Type\nDim undergrad As Student\nSub WriteStudents\n    Dim fileNum1 As Integer\n    Dim fileNum2 as Integer\n    Try\n        fileNum1% = FreeFile\n        Open \"scores.csv\" For Input As fileNum1%\n        fileNum2% = FreeFile\n        Open \"hiscores.csv\" For Append As fileNum2%\n        While Not EOF(fileNum1%) ' Read until end of file.\n            Input #fileNum1%, undergrad.ID, undergrad.Name, undergrad.Score\n            If undergrad.Score &gt; 92 Then\n                Write #fileNum2%, undergrad.ID, undergrad.Name, undergrad.Score\n            End If\n        Wend\n    Catch\n        Print \"Error reading or writing file, \" &amp; Error() &amp; \": \" &amp; Erl()\n    Finally\n        Try\n            Close fileNum1%\n            Close fileNum2%\n        Catch\n            ' File not opened\n        End Try\n    End Try\nEnd Sub\n</code></pre> <p>In the above code, two files are opened, one for reading (line 12) and one for writing (line 14). If the score is greater than 92, the line is written to the second file. If an error occurs, it is caught on line 22. But the files - if opened - need to be closed. This is done on lines 25 and 26. But the files might not have been successfully opened. There are various defensive coding options to handle this, but Try...Catch...Finally can be nested, and this approach showcases that.</p> <p>Note</p> <p>Variables declarations are always processed at the start of the sub or function. So variables declared in the <code>Try</code> or <code>Catch</code> can be referenced in <code>Catch</code> or <code>Finally</code> blocks (or even after the completion of the Try/Catch/Finally block), but may not have been initialized.</p>"},{"location":"references/whatsnew/tcf.html#nesting-trycatchfinally","title":"Nesting Try...Catch...Finally","text":"<p>Try...Catch...Finally blocks can be nested. So the following code is valid:</p> <pre><code>Function comparePeople(personA as Person, personB as Person)\n    Dim msgs() as Variant\n    Dim i as Integer\n    Dim errCount as Integer\n\n    Try\n        If (personA.firstName != personB.firstName) Then\n            Call AddMessage(personA, personB, \"firstName\", msgs)\n        End If\n        If (personA.lastName != personB.lastName) Then\n            Call AddMessage(personA, personB, \"lastName\", msgs)\n        End If\n        If (personA.age != personB.age) Then\n            Call AddMessage(personA, personB, \"age\", msgs)\n        End If\n        For i = 0 to UBound(personA.jobs)\n            Try\n                If (personA.jobs(i) != personB.jobs(i)) Then\n                    Error 1001, \"Mismatch\"\n                End If\n            Catch\n                If (errCount &gt; 3) Then\n                    ReDim Preserve msgs(UBound(msgs) + 1)\n                    msgs(UBound(msgs)) = \"...and other jobs\"\n                    Exit For\n                Else\n                    AddMessage(personA, personB, \"job\" &amp; i, msgs)\n                    errCount++\n                End If\n            End Try\n        Next\n    Catch\n        Print Error() &amp; \": \" &amp; Erl()\n    End Try\n\nEnd Function\n</code></pre> <p>The outer try/catch starting at line 6 catches any generic errors. But when iterating the jobs fixed-size array starting at line 16, we want to exit if more than three jobs are different. To handle this we compare the jobs and throw an error at line 19. If we've found more than three jobs different, we add a generic message to the <code>msgs</code> array and exit the for loop, otherwise add the message and increment the counter.</p>"},{"location":"references/whatsnew/tcf.html#trycatchfinally-or-on-error","title":"Try...Catch...Finally OR On Error","text":"<p>A Sub or Function cannot use both Try...Catch...Finally and On Error. If you try to use both, you will receive the error \"Method cannot contain both an ON ERROR/RESUME statement and a TRY statement\".</p> <p>However, a Sub or Function that uses <code>On Error</code> can call a Sub or Function that uses Try...Catch...Finally, and vice versa.</p> <p>Warning</p> <p>Try...Catch....Finally have to be used inside a sub or function.</p> <p><code>On Error</code> statements and Try...Catch...Finally blocks cannot be mixed in the same sub or function.</p>"},{"location":"references/whatsnew/uuid.html","title":"CreateUUID()","text":"<p>This is a new function that generates a unique label in Universal Unique Identifier format.</p>"},{"location":"topicguides/index.html","title":"Topic guides","text":"<p>This section discusses and explains topics and concepts about VoltScript to help you gain a better understanding of how it works.</p> <ul> <li>Architectural considerations</li> <li>Writing VoltScript code</li> <li>Understanding VoltScript in Volt MX Go</li> <li>Understanding Integration Services in Volt Foundry</li> <li>VoltScript Extensions</li> <li>VoltScript Library Modules</li> <li>Running VoltScript code</li> <li>Considerations when using VoltScript as middleware</li> </ul>"},{"location":"topicguides/architectural.html","title":"Architectural considerations","text":"<p>The core priorities when evolving VoltScript have been:</p> <ul> <li>Simplicity: VoltScript is designed for writing quick, effective, powerful middleware functions. It's not intended to provide low-level memory and thread management. Async processing will predominantly be handled by the middleware layer it runs on. VoltScript is intended for middleware projects that go from spec to production in days or weeks, not months or years.</li> <li>Approachability: LotusScript was adopted because it was approachable for the citizen developers who embraced the Lotus Notes platform. The target audience is developers who want to get things done and move on to the next task, writing code that minimizes gotchas and is easily understandable.</li> <li>Consistency: Where appropriate, VoltScript has been modified with syntactical changes and structures that are consistent with approaches adopted across other and younger languages.</li> <li>Modern Developer Experience: The VoltScript language is being supplemented by tooling and constructs to bring software development IDE functionality and processes that are standard across the industry.</li> <li>Extensibility: Extensibility is at the heart of VoltScript, both for VoltScript developers and C/C++ developers. To build a thriving community, the contribution and consumption of code by a wide audience is required.</li> <li>Fun: Last but by no means least, coding in VoltScript should be fun, not frustrating, with as many successful outcomes as possible.</li> </ul>"},{"location":"topicguides/considerations.html","title":"Considerations when using VoltScript as middleware","text":"<p>There are some functions and statements not supported in VoltScript, and these are covered in the Reference</p>"},{"location":"topicguides/considerations.html#understanding-middleware","title":"Understanding Middleware","text":"<p>There is no VoltScript server. The VoltScript runtime is started for each call with no retained in-memory variables or objects. At the end of that call, all in-memory variables and objects are removed and the runtime shut down. Each call is discreet and stateless.</p> <p>It's also important to emphasize that VoltScript won't be running wherever the UI is. Therefore, a separate call will be required between each user interaction.</p> <p></p> <p>Note</p> <p>In Domino development, a single event (such as QuerySave of a Form) is a single block of LotusScript including multiple steps each separated by requests for a user response. LotusScript runs in the Notes Client and can prompt for user interaction in the middle of a single block of code.</p> <p>When converting that kind of process to middleware, it's important to understand that the single module of code is actually multiple separate processes. VoltScript as middleware is more analagous to Web Query Save agents. If the desire is to use VoltScript, either all user responses need to be available at the start or the code needs breaking into multiple REST services. The alternative is to convert as much as possible into a front-end coding language (e.g. JavaScript) and use VoltScript for only the non-interactive elements.</p>"},{"location":"topicguides/considerations.html#messagebox","title":"MessageBox","text":"<p>VoltScript in Volt MX Go runs as middleware, so functions that require direct user interaction should be avoided. The <code>--headless</code> option can be used to convert <code>MessageBox</code> statements to Print statements.</p>"},{"location":"topicguides/considerations.html#static-keyword","title":"Static Keyword","text":"<p>The <code>Static</code> keyword in LotusScript can be used for Variables, Properties, Functions, and Subs. Static indicates that variables should retain their values between calls while the current module remains loaded.</p> <p>In HCL Notes\u00ae and Domino\u00ae, modules can remain loaded beyond a single operation by the user. In VoltScript, each user- or system-triggered process is stateless. As a result, the benefits of using the <code>Static</code> keyword are fewer than in LotusScript.</p>"},{"location":"topicguides/considerations.html#communication-protocols-and-performance-considerations","title":"Communication protocols and performance considerations","text":"<p>Certain points should be borne in mind for middleware:</p> <ul> <li>Typically, middleware code is acting on a request from the user and retrieving or updating data in some remote database.</li> <li>Usually, the communication both with the user and to the remote database will be over HTTP.</li> <li>Usually, the incoming request will have some timeout included.</li> </ul> <p>If dealing with a single small chunk of data, this distinction may not be important. However, in other scenarios, the impact on performance may be considerable:</p> <ul> <li>When updating one document, it's common to update multiple related documents in the same call. When this code is running in the same location as data, multiple calls to the database are fast to get the next document, update an item and save to disk. When the code is running elsewhere, those multiple network calls will have an exponential impact on the performance. In addition, for each network call the data will need to be converted from received format to VoltScript objects and back to a different format for making the update. If there are proxy servers in between, the impact will be more significant.</li> <li>When processing large amounts of data, the data needs to be collected at the database layer, sent over some network protocol (often HTTP/S), received, converted and processed. After that, the data is sent to the user interface over another network protocol, typically HTTP/S, where it needs to be received, converted and processed. Performance will be impacted.</li> </ul> <p>As a result, receiving and manipulating large quantities of data in the middleware layer isn't recommended.</p>"},{"location":"topicguides/running.html","title":"Running VoltScript code","text":""},{"location":"topicguides/running.html#vs-code-extension","title":"VS Code Extension","text":"<p>VoltScript files can be run from the Visual Studio Code IDE via the extension using F5 or VoltScript: Save &amp; Run Script Command Palette command. This uses the VoltScript runtime program but is intended for development-only purposes. Production code should be run via the VoltScript runtime. This could be triggered from a shell file for scheduled processing or as a process from external systems.</p>"},{"location":"topicguides/running.html#runtime","title":"Runtime","text":"<p>Note</p> <p>LotusScript runs in HCL Notes Client and HCL Domino server products, as it also used to run in many Lotus products. Those products are written in the same language as LotusScript itself.</p> <p>In the case of VoltScript, there was no plan to build a C/C++ server to house a VoltScript task. The runtime is a standalone program, VoltScript, used to run a single script. Think of it like bash, which is used to run a single command-line script. There is no context where VoltScript objects can be held in memory between calls. A script starts, runs, finishes, sends a response to the user and deletes all VoltScript and C/C++ objects from its memory. The VoltScript executable is a stateless program, so any non-ephemeral data must be persisted elsewhere, e.g. in a database, a caching service like Redis, or files.</p>"},{"location":"topicguides/running.html#context","title":"Context","text":"<p>Another point worth emphasizing is that LotusScript in Notes/Domino is tightly coupled to the environment it's running in. Certain classes, for example <code>NotesSession</code>, <code>NotesUIWorkspace</code>, are automatically contributed, which load certain environment-specific properties. Specific entrypoints add more context, for example when in a document, <code>NotesUIWorkspace.CurrentDocument</code> is bound. Certain events, like QuerySave, provide the <code>NotesUIDocument</code> as a parameter, which the runtime will pre-seed, before custom code is triggered. For certain agent triggers, <code>NotesDatabase.selectedDocuments</code> is bound to a specific collection. Such context needs to be contributed by the environment triggering the VoltScript runtime, not by the runtime itself. The VoltScript runtime should just manage receiving such input.</p> <p>For more information on methods to handle VoltScript inputs, see Managing Input Parameters</p>"},{"location":"topicguides/running.html#compiled-vs-interpreted","title":"Compiled vs Interpreted","text":"<p>VoltScript, like LotusScript, is a compiled language. The <code>.vss</code> file that you write gets compiled at runtime for VoltScript to run and use. On the whole this compiled layer is hidden from developers, but it's important to bear in mind. This is the reason dependencies need to be available in the expected locations in all environments.</p>"},{"location":"topicguides/running.html#deployed-code","title":"Deployed Code","text":"<p>The intention is that entrypoint code and dependencies, along with configuration files, will be deployed as a self-contained directory. This will include the full directory structure of the project including:</p> <ul> <li>Entrypoint file in the source directory defined in <code>atlas.json</code>.</li> <li>VoltScript library modules in the libs directory defined in <code>atlas.json</code>.</li> <li>VoltScript extensions in the <code>vses</code> directory defined in the <code>atlas.json</code>.</li> <li>seti.ini, if VoltScript extensions are in use.</li> <li><code>atlas.json</code> for support purposes to identify versions in use.</li> </ul> <p>The expected process for running the code is <code>VoltScript --seti PATH_TO_SETI entryScript.vss</code>.</p>"},{"location":"topicguides/whatis.html","title":"What is VoltScript?","text":"<p>VoltScript is a BASIC scripting language evolved from LotusScript\u00ae, which was developed for the Lotus Software family of products. The language has been extended for use with HCL Volt MX Go, as a server-side scripting language running within the Volt Foundry middleware layer.</p>"},{"location":"topicguides/writing.html","title":"Writing VoltScript code","text":""},{"location":"topicguides/writing.html#vss-file-and-structure","title":".vss File and Structure","text":"<p>The file suffix for VoltScript code is <code>.vss</code> (similar to <code>.lss</code>, the suffix for LotusScript). The <code>Sub Initialize</code> of all files and all dependencies will be run. Also any code outside of a sub or function will be run. However, best practice is to structure your file so <code>Sub Initialize</code> is the entrypoint.</p>"},{"location":"topicguides/writing.html#standalone-script-file-vss","title":"Standalone Script File (.vss)","text":"<p>VoltScript code can be written and run as a single self-contained file, where the only external calls are to core language data types and functions. But this is only advisable for small scripts to run quick actions.</p>"},{"location":"topicguides/writing.html#voltscript-projects","title":"VoltScript Projects","text":"<p>In practice, most code will use external classes or methods either in other <code>.vss</code> files (VoltScript Library Modules) or VoltScript Extensions (<code>.dll</code> or <code>.so</code> files written in C/C++). VoltScript's build manager system is designed to pull those external dependencies from either GitHub or a web server repository. The atlas.json file is used to define the structures of your project and its dependencies.</p> <p>See How to Structure Your Project for more details.</p> <p>See How to Use Build Manager for how it will create your project structure and build dependencies.</p>"},{"location":"topicguides/writing.html#ide","title":"IDE","text":"<p>The target IDE for writing complex VoltScript projects is Visual Studio Code on Windows or Mac. There are two Visual Studio Code extensions for VoltScript:</p> <ul> <li>VoltScript Language Support includes all functionality to write, compile, and run VoltScript code in Visual Studio Code.</li> <li>VoltScript Build Manager includes the functionality for dependency management, project directory structuring, and build manager.</li> </ul>"},{"location":"topicguides/writing.html#voltscript-language-support-extension","title":"VoltScript Language Support extension","text":"<p>The VoltScript Language Support extension provides language features to Visual Studio Code.</p> <ul> <li>VoltScript language is automatically detected for <code>.vss</code> files.</li> <li>Syntax highlighting is provided for VoltScript.</li> <li>VoltScript code is validated as you type. Errors are displayed in various context:<ul> <li>The text is highlighted with a red \"squiggle\" underline.</li> <li>A message is displayed in the Problems view.</li> <li>The file is marked in red in the Explorer view.</li> <li>The relevant symbol is highlighted in red in the Outline view.   </li> </ul> </li> <li> <p>Code snippets are provided for VoltScript. Note that code snippets look for a prefix, one or more trigger words that are substring-matched against what's typed. Regex can't be used for code snippet prefixes, so \"If\" will match <code>If</code> and <code>End If</code>. </p> <p>Note</p> <p>By default, snippet suggestions are accepted with the <code>Enter</code> or <code>Tab</code> key. This can be changed in Preferences\u2192Settings by changing the Accept Suggestion on Enter setting under Text Editor\u2192Suggestions.</p> </li> <li> <p>Symbols (Classes, Types, Methods, Properties, Variables) are identified in the Outline. </p> <p>Note</p> <p>If the code can't be compiled, outline symbols can't be extracted.</p> </li> <li> <p>atlas.json and atlas-settings.json files are validated for correct JSON syntax, with content assist.</p> </li> <li>VoltScript: Save &amp; Compile Script is a Command Palette option with the shortcut code Ctrl + B / Command + B.</li> <li>VoltScript: Save &amp; Run Script is a Command Palette option with the shortcut code F5.</li> </ul>"},{"location":"topicguides/writing.html#voltscript-build-manager-extension","title":"VoltScript Build Manager extension","text":"<p>The VoltScript Build Manager extension provides Command Palette options for running setup and installing dependencies. These call the VoltScript_Archipelago command line tool provided with VoltScript.</p> <ul> <li>On startup, if there is an <code>atlas.json</code> file in the workspace folder, <code>VoltScript_Archipelago setup</code> will be triggered in the integrated Terminal.</li> <li>VoltScript: Run Dependency Setup validates or creates the <code>.vss</code> directory in the user's home directory.</li> <li>VoltScript: Install Dependencies prompts for project directory, <code>atlas.json</code>, <code>atlas-settings.json</code> and whether to force download of dependencies.</li> </ul> <p>Functionality in the extensions will continuously evolve.</p>"},{"location":"topicguides/foundry/index.html","title":"Understanding VoltScript in Volt Foundry","text":"<p>This section covers VoltScript and integration services in Volt Foundry:</p> <ul> <li>VoltScript in Volt MX Go</li> <li>Integration Services in Volt Foundry</li> </ul>"},{"location":"topicguides/foundry/foundry-architecture.html","title":"Integration Services in Volt Foundry","text":"<p>An integration service is a Volt Foundry component that represents the application interaction with an external system or data source. Each integration service uses a specific technology or business adapter, such as JSON, Java, VoltScript, SAP Gateway, MongoDB, Salesforce. An integration service defines Operations, which are sub-components that represent each REST endpoint. One or more Integration services are published together through an App. But the external URI uses the integration service name and the Operation name.</p> <p>For VoltScript, each operation maps to a .vss file in <code>src</code> directory of the zip file. The approach is the same as for Java, where each operation maps to a Java class in the JAR file.</p> <p></p> <p>For more details on integration services in Volt MX, see Integration Overview.</p>"},{"location":"topicguides/foundry/voltscript-architecture.html","title":"VoltScript in Volt MX Go","text":"<p>Note</p> <p>LotusScript in HCL Notes and Domino is a server-side (Domino) and client-side (Notes) language. VoltScript is only a server-side language running in Volt Foundry.</p>"},{"location":"topicguides/foundry/voltscript-architecture.html#integration-services","title":"Integration services","text":"<p>HCL Volt Foundry uses integration services for connecting to remote services or running custom code via technology or business adapters. In HCL Volt MX, the technology adapters for running custom code are:</p> <ul> <li>Volt MX Mock Data Adapter for generating mock data.</li> <li>Java Adapter for running custom Java code from an uploaded JAR file. Operations run a Java class implementing the JavaService2 interface.</li> <li>JavaScript Adapter for running functions in a custom JavaScript code from an uploaded JavaScript file. There are certain limitations.</li> </ul> <p>In Volt MX Go, VoltScript is added as an additional custom code language.</p> <p></p>"},{"location":"topicguides/foundry/voltscript-architecture.html#preprocessors-and-postprocessors","title":"Preprocessors and postprocessors","text":"<p>Integration services also permit custom code invocation before (preprocessor) and/or after the main integration service. In Volt MX there are three options:</p> <ul> <li>Java for running custom Java code from an uploaded JAR file. Preprocessors run a Java class implementing the DataPreProcessor interface. Postprocessors run a Java class implementing the DataPostProcessor interface.</li> <li>JavaScript for running custom JavaScript code entered into the Monaco editor.</li> <li>Rules for running custom logic using MVFLEX Expression Language (MVEL).</li> </ul> <p>In Volt MX Go, VoltScript is added as an additional custom code language for preprocessors and postprocessors. However, only small snippets of code are expected, for example to validate input parameters or manipulate the output. As a result, VoltScript code is entered directly into the Monaco editor, and merged into boilerplate VoltScript.</p> <p></p> <p>Info</p> <p>Note the final two lines, both <code>Return True</code> and <code>End Function</code> are automatically appended.</p> <p>Note</p> <p>VoltScript pre/postprocessors are not available for VoltScript integration services. This is a limitation for performance reasons, see below.</p>"},{"location":"topicguides/foundry/voltscript-architecture.html#how-volt-foundry-runs-preprocessors-and-postprocessors","title":"How Volt Foundry runs preprocessors and postprocessors","text":"<p>The sequence flow for running preprocessors and postprocessors is:</p> <pre><code>sequenceDiagram\n  autonumber\n  actor user as User\n  participant op as Foundry Operation\n  participant pre as Preprocessor\n  participant post as Postprocessor\n  user-&gt;&gt;op: Call Foundry REST service\n  opt Preprocessor enabled\n  op-&gt;&gt;pre: Call preprocessor\n  end\n  activate pre\n  pre-&gt;&gt;op: Return true (continue) or false (abort)\n  deactivate pre\n  alt Abort\n  op-&gt;&gt;user: Return result\n  else Continue\n  op-&gt;&gt;op: Run main integration service\n  opt Postprocessor enabled\n  op-&gt;&gt;post: Call postprocessor\n  post-&gt;&gt;op: Return result\n  end\n  op-&gt;&gt;user: Return result\n  end</code></pre> <p>For more information, see Workflow of Integration Services.</p>"},{"location":"topicguides/foundry/voltscript-architecture.html#how-volt-foundry-runs-voltscript","title":"How Volt Foundry runs VoltScript","text":"<p>Integration with the VoltScript runtime is via the multi-threaded HTTP server, the equivalent of <code>VoltScript --httpserver</code>.</p> <pre><code>sequenceDiagram\n  autonumber\n  actor user as User\n  participant foundry as Foundry Java\n  participant servlet as VoltScript Servlet\n  participant v as VoltScript\n  user-&gt;&gt;foundry: Call Foundry REST service\n  rect rgb(222,222,222)\n  foundry-&gt;&gt;foundry: Serialize context info\n  foundry-&gt;&gt;servlet: Post request\n  servlet-&gt;&gt;v: Run VoltScript code\n  v-&gt;&gt;v: Deserialize context info\n  v-&gt;&gt;v: Run custom code\n  v-&gt;&gt;servlet: Print JSON response\n  servlet-&gt;&gt;foundry: Send JSON response\n  foundry-&gt;&gt;foundry: Deserialize response\n  end\n  foundry-&gt;&gt;user: Send JSON response</code></pre> <p>Note</p> <p>Obviously, for a VoltScript integration service, it's inefficient to call repeat the process in the shaded area multiple times for a VoltScript preprocessor and/or postprocessor. The best practice is to include any preprocessing or postprocessing of content within the main VoltScript integration service code.</p>"},{"location":"topicguides/voltscript-extensions/index.html","title":"VoltScript Extensions","text":"<p>This section covers background on the various VoltScript Extensions created by HCL.</p> <p>HCL provides VoltScript Extensions to support a variety of processes:</p> <ul> <li>Data access over HTTP to specific or generic REST services and handling of JSON data.</li> <li>Operating System extensions for interacting with the operating system and files.</li> <li>Managing input parameters, whether that be command line arguments or standard input.</li> <li>MD5 and SHA hashes.</li> </ul>"},{"location":"topicguides/voltscript-extensions/data-access.html","title":"Web-based Access","text":"<p>As middleware, the standard data transfer format will be JSON. Accessing and handling that data easily is a core priority of VoltScript.</p>"},{"location":"topicguides/voltscript-extensions/data-access.html#libcurl-and-ssl","title":"libcurl and SSL","text":"<p>All web-based extensions use libcurl to make curl requests. To use HTTPS, libcurl uses SSL Certificate Verification. Typically, the web-based extensions expect a properly verifiable SSL certificate to use HTTPS, but WebVSE has an option to disable this with <code>WebServer.SSLHostValidationOn = False</code>. This is equivalent to the libcurl command <code>curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);</code> or the curl command line option <code>-k/--insecure</code>.</p> <p>It is the responsibility of the systems administrator to ensure the relevant self-signed certificates to the relevant cert store.</p> <p>Alternatively, all extensions have a <code>certificatePath</code> property to pass a path to a certificate to use to validate SSL.</p>"},{"location":"topicguides/voltscript-extensions/data-access.html#web","title":"Web","text":"<p>The Web VoltScript Extension provides low-level functions for making HTTP requests using libcurl.</p> <p>The <code>WebServer</code> class is the entrypoint, intended to provide a standard and reusable object for managing requests to a base URL. It can also be used to URL encode or decode strings. The <code>WebRequest</code> class handles data and file requests to a specific endpoint. It can also base64  The <code>WebResponse</code> class handles verifying and processing the response.</p> <p>With WebVSE, files can be downloaded either synchronously or asynchronously. Only synchronous download is supported for other VSEs. <code>.zip</code> files can be manipulated using ZipVSE.</p> <p>Note</p> <p>Developers should bear in mind that a file is always created for a download, regardless of HTTP response. If a non-200 HTTP response is received, the file will contain the HTML response.</p> <p>You can find out more information in the API docs and the following how-to documents:</p> <ul> <li>Make HTTP REST JSON request</li> <li>Download files</li> </ul>"},{"location":"topicguides/voltscript-extensions/data-access.html#domino-access","title":"Domino Access","text":""},{"location":"topicguides/voltscript-extensions/data-access.html#voltscript-vs-lotusscript","title":"VoltScript vs LotusScript","text":"<p>While VoltScript has its origins in LotusScript, and while they share similar syntax, the way you approach writing applications in VoltScript is fundamentally different than the way you would write an application in LotusScript.</p> <p>LotusScript is a hosted language, meaning it lives as a part of a parent platform, that uses and event-driven programming model. Everything is driven by events that occur - the click of a button, the saving of a document, etc. Code is scattered throughout the application, usually within the event being triggered.</p> <p>VoltScript is a standalone language that may be available in applications such as Foundry, but it can also be written and executed without a hosted application. VoltScript is \"stateless\", meaning that each execution of code is independent of any other code, state, or event.</p> <p>LotusScript is often coded within UI objects such as forms, views, etc. It also has front-end (UI) and back-end (data) classes available for working with Notes/Domino objects (since it's a hosted language).</p> <p>VoltScript is strictly back-end - there is no UI component. It is able to work with various servers and databases through the use of REST APIs or VoltScript Extensions specifically written to work with a back-end, such as Domino or CouchDB.</p>"},{"location":"topicguides/voltscript-extensions/data-access.html#drapivse","title":"DrapiVSE","text":"<p>DrapiVSE leverages the same libcurl libraries as the Web VoltScript Extension and wraps much of that functionality. This integrates with Domino REST API and provides VoltScript classes and methods for making Domino REST API data calls.</p> <p>DrapiVSE just creates curl requests to Domino REST APIs. It's important to remember that VoltScript Extensions have different rules to receiving arguments compared to REST APIs. A REST API can receive query parameters in any order, omitting any not required. VoltScript methods must include required parameters first, and optional parameters can only be omitted if no subsequent optional parameter is needed. This may make calls more verbose than corresponding REST API calls.</p> <p>The <code>DrapiServer</code> contains the entrypoint to the Domino REST API running on a server, providing login and generic Domino REST API server info. Access to a specific scope is via a <code>DrapiRequest</code>. APIs that return multiple documents will return a String of JSON in <code>DrapiResponse.ContentBody</code>. APIs that always return a specific single document will return a DrapiDocument. The JSON content corresponding to the document can be accessed via <code>DrapiDocument.JSONValue</code>.</p> <p>Many methods take or return strings where the developer might expect some form of JSON object or VoltScript object along the lines of NotesViewEntryCollection, NotesDocument etc. This provides greater reliability against multiple versions of Domino REST API and flexibility on version migration.</p> <p>It's strongly recommended that you are familiar with Domino REST API calls, documentation, and usage via other methods, such as Postman. This will provide understanding of expected schema of JSON data received, direct access to the data being received, providing sample data that can be used to help coding, for unit testing parts of VoltScript code, and for troubleshooting unexpected data-related failures in deployed code.</p> <p>Warning</p> <p>DrapiVSE isn't intended for scope or schema configuration, the Domino REST web configuration UI should be used for that purpose. DrapiVSE also doesn't support proxy server access, it expects either direct or VPN access to the data. Of course any DrapiVSE call can be created manually using WebVSE.</p>"},{"location":"topicguides/voltscript-extensions/data-access.html#couchdb","title":"CouchDb","text":"<p>The Couch VoltScript Extension also leverages libcurl to provide access to CouchDB. This was developed as a research project and is provided as a proof of technology. CouchVSE provides low-level CRUD access to a Couch server without enforcing the kind of control Domino Developers and Administrators have and expect. As a result, the extension is more permissive.</p>"},{"location":"topicguides/voltscript-extensions/data-access.html#json","title":"JSON","text":"<p>The JSON VoltScript Extension provides utilities for parsing and build JSON. As well as receiving a JSON string from an HTTP call, the parser can also be passed a file (useful for unit testing or debugging without accessing the production environment) or a JsonObject. For ease of use and briefer code, a single class (<code>JsonObject</code>) is used for JSON objects and arrays. It can contain a scalar value, a JSON object, or an array of scalars or other JSON objects. The <code>shortValue</code> property can be used for debugging or logging purposes, returning the first 16 characters. Any JSON object can be converted to a string, using the <code>toString()</code> method.</p> <p>You can find more information in the API docs and the following how-to documents:</p> <ul> <li>Building JSON</li> <li>Parsing JSON</li> <li>Make HTTP REST JSON request</li> </ul> <p>The VoltScript JSON Converter library provides classes for configured deserialization from JSON to VoltScript object, and serialization vice versa.</p>"},{"location":"topicguides/voltscript-extensions/data-access.html#iso-8601-dates","title":"ISO 8601 Dates","text":"<p>To support JSON parsing, Zulu provides parsing of dates in ISO 8601 format, accepting either \"Z\" or offset in \"hh:mm\" format. Portions of the date can be retrieved, and the DateTimeObject can be converted to UTC format. The class does not provide functions for manipulating the timezone. This is expected to be done in the client application, using client functions to display in the user's preferred timezone.</p> <p>You can find more information in the API docs and Processing ISO 8601 dates.</p> <p>Note</p> <p>A Zulu DateTimeObject cannot be passed to the core VoltScript <code>Format()</code> function. Core language functions cannot receive VoltScript Extension objects.</p> <p>Warning</p> <p>The DateTime variant does not contain a timezone, so cannot receive a JSON date in UTC format.</p>"},{"location":"topicguides/voltscript-extensions/hash.html","title":"Hashes","text":"<p>The extension enables creating MD5 and SHA hashes, which can be used for verification purposes.</p>"},{"location":"topicguides/voltscript-extensions/input.html","title":"Managing input parameters","text":"<p>Middleware functions rarely perform the same action each time on an internally-configured dataset. Typically they will be triggered from user interaction, with contextual information to use to determine what to do, and sometimes with a payload to pass to a database.</p> <p>VoltScript code needs to be able to receive those input parameters. Two VoltScript Extensions have different ways to achieve this requirement.</p>"},{"location":"topicguides/voltscript-extensions/input.html#context-and-context-option","title":"Context and --context Option","text":"<p>In this scenario, the input parameters are passed at the same time as starting the VoltScript file.</p> <p>The VoltScript runtime has a <code>--context</code> option which accepts a string of data from the command line call. This is good for small, basic content. This can be accessed with the following code:</p> <p>Note</p> <p>Command line calls have restrictions around what can be passed in a string. There may also be limitations on different platforms for length of the command line call. Be aware of what restrictions are in place before using.</p>"},{"location":"topicguides/voltscript-extensions/input.html#stream-and-stdio","title":"Stream and STDIO","text":"<p>In this scenario, the VoltScript file will be started in an interactive mode and input parameters passed subsequently. The VoltScript code is responsible for pausing and awaiting the input, then continuing after all expected input is received.</p> <p>This uses StreamVSE, which has the ability to connect to standard input and output (STDIO) and process input parameters via that mechanism. This is initiated with the following code:</p> <pre><code>UseVSE \"*StreamVSE\"\nDim pipestream as New Stream()\nCall pipestream.open(\"\", \"STDIO\")</code></pre> <p>Input can then be read from standard input using <code>.readText()</code>. Content can be written to standard output using the normal <code>Print</code> statement of VoltScript or the Stream's <code>.writeText()</code> method.</p> <p>It's the responsibility of the calling code to run the VoltScript file in an interactive manner and handle output.</p> <p>For more details on both, see Receive input.</p>"},{"location":"topicguides/voltscript-extensions/os.html","title":"Operating System Management","text":""},{"location":"topicguides/voltscript-extensions/os.html#os","title":"OS","text":"<p>The VoltScript language has low-level functions for interacting with the operating system. However, some functions have behaviors which, although well-documented, are nonetheless not intuitive. For example, when creating a directory, the code throws an error if the directory can't be created, such as when it already exists, and it can't create directories recursively.</p> <p>The OSUtils VoltScript Extension was designed to support developers with such functions. The OSUtils class provides simple, easy-to-use functions to:</p> <ul> <li>identify the current platform.</li> <li>access temp and user home directories.</li> <li>get and set environment variables.</li> <li>identify is a directory or file exists at a given path.</li> <li>identify if a file is readable, writable or executable.</li> <li>create or remove directories.</li> <li>get an array of files in a directory.</li> </ul> <p>The extension also includes a class for building a path as an array by adding a single directory or delimited path. The path can be returned as either an array of directories or a string.</p> <p>You can find additional information in API docs and the following how-to guides:</p> <ul> <li>Understanding CurDir()</li> <li>Environment variables</li> <li>Finding files and managing directories</li> <li>Read and write files</li> <li>Processing zip files</li> </ul>"},{"location":"topicguides/voltscript-extensions/os.html#stream","title":"Stream","text":"<p>The Stream VoltScript Extension provides functions for easy reading and writing of files, similar to the NotesStream class but extended to also read from standard input and output.</p> <p>You can find additional information in the API docs and Read and write files.</p>"},{"location":"topicguides/voltscript-extensions/os.html#zip","title":"Zip","text":"<p>The Zip VoltScript Extension provides functions for creating and processing <code>.zip</code> files, and managing the files contained by the <code>.zip</code>.</p> <p>Note</p> <p>Because of the platform libraries used, this extension can only be used to process <code>.zip</code> files. It can't be used to process <code>.tar</code> or <code>.tar.gz</code> files.</p> <p>You can find more information in API docs and Processing zip files.</p>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<p>The tutorials give hands-on introduction on how to use VoltScript core functions and VoltScript Extensions.</p> <ul> <li>Visual Studio Code setup</li> <li>Intro to VoltScript</li> <li>Volt Foundry installation</li> <li>Intro to VoltScript for Volt Foundry</li> <li>Intro to Writing VoltScript in Volt Foundry</li> </ul>"},{"location":"tutorials/index.html#voltscript-libraries","title":"VoltScript Libraries","text":"<p>For tutorials on VoltScript Libraries, see:</p> <ul> <li>VoltScript Testing</li> <li>VoltScript Collections</li> <li>VoltScript JSON Converter</li> <li>VoltScript Logging</li> </ul>"},{"location":"tutorials/usinglists.html","title":"Lists","text":""},{"location":"tutorials/usinglists.html#1-introduction","title":"1 Introduction","text":"<p>A list is a one-dimensional collection of elements. The size of the list is not defined at compile-time but grows and shrinks dynamically as entries are added or removed. The elements are accessed via a unique string tag. Lists are highly performant for iterating or accessing elements, but are not designed for anything more sophisticated than random or sequential access.</p>"},{"location":"tutorials/usinglists.html#2-creating-lists","title":"2 Creating Lists","text":"<p>Lists can be declared in modules, classes or procedures, but not in types. They are created using the <code>List</code> keyword after the variable name. Lists are declared with a data type, which can be any of the scalar data types or a custom class.</p> <pre><code>Dim countries List as String</code></pre> <p>If you wish to add content consisting of multiple data types to a list, declare it as a List of Variants.</p> <pre><code>Dim complexList List as Variant</code></pre>"},{"location":"tutorials/usinglists.html#21-list-data-types","title":"2.1 List Data Types","text":"<p>The TypeName check on a list returns the data type suffixed with \" LIST\". The DataType function returns 2048 + the corresponding integer for the data type of the list.</p> <pre><code>Dim countries List as String\n\nPrint TypeName(countries)   'Prints \"STRING LIST\"\nPrint DataType(countries)   'Prints \"2056 = 2048 + 8</code></pre>"},{"location":"tutorials/usinglists.html#3-handling-lists","title":"3 Handling Lists","text":""},{"location":"tutorials/usinglists.html#31-adding-elements","title":"3.1 Adding Elements","text":"<p>A List is initially created empty. Elements are added by specifying a string key and a value corresponding to the list declaration:</p> <pre><code>countries(\"United States\") = \"US\"\ncountries(\"United Kingdom\") = \"UK\"</code></pre> <p>If a key is re-used, it will overwrite the value assigned in the list. Keys are matched depending on the Option Compare case sensitivity applied. By default, that is <code>Option Compare Case</code> - case-sensitive matching. Thus <code>countries(\"united states\")</code> and <code>countries(\"United States\")</code> would be different elements in the list.</p>"},{"location":"tutorials/usinglists.html#32-testing-size-of-the-list","title":"3.2 Testing Size of the List","text":"<p>Testing the size of a list must be done by iterating the list. There is no single function for checking if a list is empty.</p> <pre><code>Dim countries List as String\n\nPrint isEmpty(countries)    'Prints \"false\" - isEmpty cannot be used to test the list has values\n\nDim listIsEmpty as Boolean\nlistIsEmpty = True\n\nForAll elem in countries\n    listIsEmpty = False\n    Exit ForAll\nEnd ForAll\n\nPrint listIsEmpty   'Print \"true\"\n\ncountries(\"United States\") = \"US\"\ncountries(\"United Kingdom\") = \"UK\"\n\nDim elemCount as Integer\n\nForAll elem in countries\n    elemCount ++\nEnd ForAll\n\nPrint elemCount     'Prints \"2\"</code></pre>"},{"location":"tutorials/usinglists.html#33-accessing-content","title":"3.3 Accessing Content","text":"<p>Content can be accessed by iterating elements using a <code>ForAll</code> loop, as shown already. Or specific elements can be accessed by using the key. When doing so, be aware that using a key that does not exist will throw an error.</p> <pre><code>Dim countries List as String\n\ncountries(\"United States\") = \"US\"\n\nPrint countries(\"United States\")    ' Prints \"US\"\nPrint countries(\"United Kingdom\")\n</code></pre> <p>Line 6 will throw an error, \"List item does not exist\", error code 120. To avoid this, use IsElement.</p> <pre><code>Dim countries List as String\n\ncountries(\"United States\") = \"US\"\n\nPrint countries(\"United States\")    ' Prints \"US\"\nIf IsElement(countries(\"United Kingdom\")) Then Print countries(\"United Kingdom\")</code></pre> <p>When iterating the list using a <code>ForAll</code> loop, if you require the current key, use ListTag.</p> <pre><code>Dim countries List as String\n\ncountries(\"United States\") = \"US\"\n\nForAll elem in countries\n    Print ListTag(elem) &amp; \" - \" &amp; elem  'Prints \"United States - US\"\nEnd ForAll</code></pre>"},{"location":"tutorials/usinglists.html#cleanup","title":"Cleanup","text":"<p>Individual entries can be removed from the list using Erase. This will also reclaim the memory allocated for that element.</p> <pre><code>Dim countries List as String\n\ncountries(\"United States\") = \"US\"\n\nErase(countries(\"United States\"))</code></pre> <p>Passing just the list variable itself will remove all entries from the list and reclaim memory.</p> <pre><code>Dim countries List as String\n\ncountries(\"United States\") = \"US\"\ncountries(\"United Kingdom\") = \"UK\"\n\nErase(countries)</code></pre> <p>It is best practice to call Erase on the list at the end of your code.</p>"},{"location":"tutorials/foundry/index.html","title":"Introduction to VoltScript for Volt Foundry","text":"<p>This workshop is designed to walk through creating integration services and pre/postprocessors in Volt Foundry.</p> <ul> <li>Lab 01 creates a simple integration service to return a message element \"Hello World\".</li> <li>Lab 02 creates an integration service to echo the username passed and error if nothing is passed.</li> <li>Lab 03 creates an integration service to talk to Domino REST API.</li> <li>Lab 04 is a pre/postprocessor to validate input parameters and modify the output.</li> </ul>"},{"location":"tutorials/foundry/lab-01.html","title":"Foundry Lab 01 - Hello World Integration Service","text":""},{"location":"tutorials/foundry/lab-01.html#duration-20-min","title":"Duration 20 Min","text":""},{"location":"tutorials/foundry/lab-01.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to create a simple integration service to return a JSON object including a message element that says \"Hello World\".</p>"},{"location":"tutorials/foundry/lab-01.html#prerequisites","title":"Prerequisites","text":"<ul> <li>This exercise assumes you are familiar with dependency management, as covered in Intro to VoltScript Lab 03a.</li> </ul>"},{"location":"tutorials/foundry/lab-01.html#steps","title":"Steps","text":""},{"location":"tutorials/foundry/lab-01.html#atlasjson","title":"atlas.json","text":"<ol> <li>Click File \u2192 Open Folder.</li> <li>Create a new folder in your user directory called \"foundry-lab\".</li> <li>Right-click in the empty pane and select New File from the context menu.</li> <li>Name the file \"atlas.json\".</li> <li>Type \"foundry-atlas\" and accept the snippet.</li> <li>Set name to \"foundry-lab\".</li> <li>Set description to \"Simple Hello World Foundry Lab\".</li> <li>Set displayName to \"foundry-lab\".</li> <li>Complete publisher and authors.</li> <li>Delete repo and library elements.</li> <li>Set version to \"1.0.0\".</li> <li>Change array element in mainScripts to \"helloWorld.vss\"</li> <li>Add the usual repositories to the repositories array for VSEs and Library Modules.</li> <li>In dependencies array, add VoltScript VoltMX Middleware:<ol> <li>Set library to \"voltscript-voltmx-middleware\".</li> <li>Set version to \"latest\".</li> <li>Set module to \"VoltMXObjects.vss\".</li> <li>Set repository to \"hcl-github\".</li> </ol> </li> <li>Delete unitTestScripts, integrationTestScripts, testDependencies, and vseDependencies elements.</li> <li> <p>Save the atlas.json.</p> The final atlas.json should look like this: <pre><code>{\n    \"name\": \"foundry-lab\",          // REQUIRED: Enter a short name for your VoltScript project, e.g. \"Demo1\"\n    \"description\": \"Simple Hello World Foundry Lab\",    // REQUIRED: Enter a longer description, e.g. \"My first demo project\"\n    \"displayName\": \"foundry-lab\",  // A longer name to refer to the project, e.g. \"Demo 1\"\n    \"license\": \"Apache 2.0\",    // A license to publish the project under.\n                                // If you want this to be used by others, Apache 2.0 or MIT are recommended\n    \"publisher\": \"HCL America, Inc.\",   // Copyright owner\n    \"authors\": [        // REQUIRED: An array of authors, can be names or emails\n        \"Paul Withers\"\n    ],\n    \"version\":\"1.0.0\",  // REQUIRED: Current version for this project, used with dependency management to find the modules\n    \"sourceDir\": \"src\", // REQUIRED: Directory where mainScripts are located\n    \"testDir\": \"test\",  // Directory where unitTestScripts and integrationTestScripts are located\n    \"libsDir\": \"libs\",  // Directory where VoltScript Library Modules and shared scripts are located\n    \"vsesDir\": \"vses\",  // Directory where VoltScript Extensions are located\n    \"mainScripts\": [    // REQUIRED: Main scripts with Sub Initialize. Used to sync any additional files between\n                        // sourceDir and testDir, if libsDir not set\n        \"helloWorld.vss\"\n    ],\n    \"repositories\": [       // Repositories in which to search for any dependencies\n        {\n            \"id\": \"volt-mx-marketplace\",\n            \"type\": \"marketplace\",\n            \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n        },\n        {\n            \"id\": \"hcl-github\",     // REQUIRED: Unique ID matching \"repository\" in a dependency in this file.\n                            // Also matches label of a JSON object in atlas-settings, which gives any credentials to use to access this repository\n            \"type\": \"github\",   // REQUIRED: Currently \"github\" or \"webserver\" are supported\n            \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\" // REQUIRED: Base URL of the repository\n        }\n    ],\n    \"dependencies\": [\n        {\n            \"library\": \"voltscript-voltmx-middleware\",  // REQUIRED: Folder to be appended to the base URL when dependency management tries to download modules\n            \"version\": \"latest\",  // REQUIRED: Version number of modules to download. Currently only supports explicit version or \"latest\"\n            \"module\": \"VoltMXObjects.vss\",   // REQUIRED: Filename of a VoltScript Library Module to download\n            \"repository\": \"hcl-github\"\n        }\n    ]\n}\n</code></pre> </li> </ol>"},{"location":"tutorials/foundry/lab-01.html#voltscript-dependency-manager","title":"VoltScript Dependency Manager","text":"<ol> <li>From the Command Palette, run \"VoltScript: Install Dependencies\".</li> <li>Enter the project directory, confirm atlas-settings.json and atlas.json locations.</li> </ol> <p>Success</p> <p>Your project should now have \"src\", \"test\", \"libs\" and \"vses\" directories.</p> <ul> <li>The src directory is empty.</li> <li>The test directory is empty.</li> <li>The libs directory has been populated with <code>VoltMXObjects.vss</code> and <code>VoltScriptCollections.vss</code>. VoltScriptCollections is a downstream dependency of VoltMXObjects.</li> <li>The vses directory has been populated with ddl and so files for ContextVSE and JsonVSE - these are downstream dependencies used by VoltMXObjects, automatically picked up because of its atlas.json.</li> <li>A new file, <code>seti.ini</code>, has been created. This contains mapping for the VoltScript Extensions (VSEs) and will be used for mapping <code>UseVSE</code> statements.</li> <li>A new file, <code>effective-atlas.json</code>, has been added to the root of the directory. This contains the aggregated settings for the project.</li> </ul>"},{"location":"tutorials/foundry/lab-01.html#helloworldvss","title":"helloWorld.vss","text":"<ol> <li>Create a file \"helloWorld.vss\" in src directory.</li> <li>Type \"foundry\" and accept the Foundry Boilerplate snippet.</li> <li> <p>Between the two comment blocks, enter the following code:</p> <pre><code>Call VoltMxResult.result.insertValue(\"message\", \"Hello World!\")</code></pre> </li> <li> <p>Save the file.</p> </li> </ol> <p>Success</p> <p>A message element with the value \"Hello World!\" is added to the result's JSON object.</p>"},{"location":"tutorials/foundry/lab-01.html#package-for-volt-foundry","title":"Package for Volt Foundry","text":"<ol> <li>From the Command Palette, run \"VoltScript: Package for Foundry\".</li> <li>Enter the project directory, confirm atlas.json locations and continue with nothing entered for additional files to package.</li> </ol> <p>Success</p> <p>A file is created in the root of the project called \"foundry-lab.1.0.0.zip\". The zip name comprises the project name and the project version from the atlas.json.</p>"},{"location":"tutorials/foundry/lab-01.html#create-volt-foundry-integration-service","title":"Create Volt Foundry Integration Service","text":"<ol> <li>Log into Volt Foundry.</li> <li> <p>On the Apps page, click ADD NEW.</p> <p></p> </li> <li> <p>On Configure Services tab, click the Integration tab and then click CONFIGURE NEW.</p> <p></p> </li> <li> <p>Set the Name to \"foundry-lab-vs\".</p> </li> <li>Select \"VoltScript\" under Service Type.</li> <li> <p>Click Upload New and select the zip file you just created (<code>foundry-lab.1.0.0.zip</code>).</p> <p></p> </li> <li> <p>Click SAVE &amp; ADD OPERATION at the bottom of the page.</p> <p></p> </li> <li> <p>Set the name to \"helloWorld\".</p> </li> <li>Select \"helloWorld.vss\" as the file.</li> <li> <p>Click ADD OPERATION.</p> <p></p> </li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE button.</p> <p></p> </li> </ol> <p>Warning</p> <p>You need to have an environment set up to test an operation. If you haven't yet configured one, save the operation, follow the steps in Add an Environment, and then come back to the operation to test.</p> <p>Success</p> <p>The Output Result returns:</p> <pre><code>{\n    \"opstatus\": 0,\n    \"message\": \"Hello World!\",\n    \"httpStatusCode\": 0\n}\n</code></pre>"},{"location":"tutorials/foundry/lab-01.html#add-an-environment","title":"Add an Environment","text":"<ol> <li>On the left pane on the Volt Foundry Console, click Environments.</li> <li>On the Environments page, click Add New. The Add a New Environment dialog opens.</li> <li> <p>In the Environment Name text box, enter an environment name.</p> <p>Note</p> <p>Your environment name can only contain letters, numbers, and hyphens (-). A hyphen can't appear at the beginning or at the end of a name. A number can't appear at the beginning of a name. A name should be a minimum of three characters and a maximum of 20 characters long.</p> </li> <li> <p>On the Server tab, enter the URL of your Volt Foundry in the URL text box. The URL format is: <code>&lt;http or https&gt;://&lt;server_host&gt;:&lt;server_port&gt;</code>For example: http://mbaastest30.hcl.net:53504</p> </li> <li>Click Test Connection to verify that the entered URL is correct. If the test is successful, a check mark appears beside the Server tab.</li> <li> <p>Click Save.</p> <p></p> </li> </ol>"},{"location":"tutorials/foundry/lab-02.html","title":"Foundry Lab 02 - Hello Name Integration Service","text":""},{"location":"tutorials/foundry/lab-02.html#duration-15-min","title":"Duration 15 Min","text":""},{"location":"tutorials/foundry/lab-02.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to create an integration with an input parameter, validate the input parameter and error or return a JSON object including a message element that says \"Hello\" to the username sent.</p>"},{"location":"tutorials/foundry/lab-02.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 01 completed</li> </ul>"},{"location":"tutorials/foundry/lab-02.html#steps","title":"Steps","text":""},{"location":"tutorials/foundry/lab-02.html#hellonamevss","title":"helloName.vss","text":"<ol> <li>For completeness, in <code>atlas.json</code>, add a second element to mainScripts called \"helloName.vss\".</li> <li>Create a file \"helloName.vss\" in the src directory.</li> <li>Type \"foundry\" and accept the Foundry Boilerplate snippet.</li> <li> <p>Between the two comment blocks, enter the following code:</p> <pre><code>If (VoltMxRequest.getInputParam(\"username\") = \"\") Then\n    Call VoltMxResult.setErrorMessage(\"Please enter username\")\nElse\n    Call VoltMxResult.result.insertValue(\"message\", \"Hello \" &amp; VoltMxRequest.getInputParam(\"username\"))\nEnd If</code></pre> </li> <li> <p>Save the file.</p> </li> </ol>"},{"location":"tutorials/foundry/lab-02.html#package-for-volt-foundry","title":"Package for Volt Foundry","text":"<ol> <li>From the Command Palette, run \"VoltScript: Package for Foundry\".</li> <li>Enter the project directory, confirm atlas.json locations and continue with nothing entered for additional files to package.</li> </ol> <p>Success</p> <p>A file is created in the root of the project called \"foundry-lab.1.0.0.zip\". The zip name comprises the project name and the project version from the atlas.json.</p>"},{"location":"tutorials/foundry/lab-02.html#update-volt-foundry-integration-service","title":"Update Volt Foundry Integration Service","text":"<ol> <li>Log into Volt Foundry.</li> <li>On the Apps page, select the app you created in Foundry Lab 01.</li> <li>On Configure Services tab, click the Integration tab.</li> <li>Click the Service Definition tab for the \"foundry-lab-vs\" integration service.</li> <li>Click Upload New and select the zip file you just created. You will receive a warning that this will update the endpoint operations. Click OK.</li> <li>Set the Name to \"helloName\".</li> <li>Click SAVE &amp; ADD OPERATION.</li> <li>Select \"helloName.vss\" as the file.</li> <li> <p>Click ADD OPERATION.</p> <p></p> </li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</p> <p></p> <p>Success</p> <p>The Output Result shows the following JSON object:</p> <pre><code>{\n    \"ErrorCode\": \"7060\",\n    \"ErrorMessage\": \"Error occurred while processing the VoltScript. Cause Please enter username.\"\n}\n</code></pre> </li> <li> <p>On the Request Input tab of the operation, click + Add Parameter.</p> </li> <li>Set the NAME to \"username\".</li> <li>Set the TEST VALUE to \"John Doe\".</li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</p> <p></p> <p>Success</p> <p>The output result shows the following JSON object:</p> <pre><code>{\n    \"opstatus\": 0,\n    \"message\": \"Hello John Doe\",\n    \"httpStatusCode\": 0\n}\n</code></pre> </li> </ol>"},{"location":"tutorials/foundry/lab-03.html","title":"Foundry Lab 03 - Domino REST API Integration Service","text":""},{"location":"tutorials/foundry/lab-03.html#duration-40-min","title":"Duration 40 Min","text":""},{"location":"tutorials/foundry/lab-03.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to perform actions on data from Domino.</p> <p>The first endpoint will be to populate a Domino database with demo data, which could subsequently be used as a REST service to bulk create documents based on a similar format - a process that might historically have been done by emailing a CSV file to the Domino developer who would run an import agent.</p> <p>The next endpoint will change the company name on a Company document and update the name on related Contact documents. In Notes Client, this would be performed in a PostSave event. In a traditional Domino web interface, this would be completed in a WebQuerySave agent. In an XPages application, the PostSave event could be used, but more experienced developers would follow a similar approach to what we build here - write code to update the Company and update the related Contact documents. A completely coded approach could also be taken in Notes Client, but would use NotesUIWorkspace's Prompt or DialogBox to retrieve the new company name. But as we've explained, interaction with the end user is not possible from Volt Foundry.</p> <p>Note</p> <p>The key difference with code running on a Domino server is the approach for updating related documents: in LotusScript / SSJS / Java the developer will retrieve a view, get all documents based on a key and iterate the collection. Obviously that is a sub-optimal approach when the code is running anywhere other than the Domino server - separate HTTP requests are required for retrieving the collection and updating each document. DQL allows updates on multiple documents and this is the process used by Domino REST API's bulk update endpoints. This is the best-practice approach because the query for related documents and update is performed on the Domino server.</p>"},{"location":"tutorials/foundry/lab-03.html#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>This exercise assumes that:</p> <ul> <li>You're familiar with creating VoltScript integration services, as covered in Foundry Labs 01 and 02.</li> <li>You have a Domino server configured with Domino REST API running and OAuth enabled.<ul> <li>The oauth.nsf has been set up.</li> <li>The oauth.json has been added to keepconfig.d.</li> </ul> </li> <li>You're familiar with creating a scope, schema and application in Domino REST API.</li> </ul> </li> </ul>"},{"location":"tutorials/foundry/lab-03.html#steps","title":"Steps","text":""},{"location":"tutorials/foundry/lab-03.html#schema-scope","title":"Schema / Scope","text":"<p>Note</p> <p>The following steps assume you're familiar with creating schemas and scopes using Domino REST API. For more information, see the Domino REST API tutorials.</p> <p>If you have have already completed Intro to VoltScript &gt; Lab 04 - Connecting to a DRAPI Scope, go ahead and skip to the next section: Application and Oauth.</p> <ol> <li>Download the Demo Companies and Contacts Template and save it locally.  </li> <li>Create a New Database instance from the template on the HCL Domino server upon which your HCL Domino REST API is installed, and set the ACL appropriately for your DRAPI instance.  </li> <li>Create a Scope called <code>companiesandcontacts</code>, and associate it with the <code>demo_companies_and_contacts</code> Schema in your newly created database.</li> </ol>"},{"location":"tutorials/foundry/lab-03.html#application","title":"Application","text":"<ol> <li>Log into Volt Foundry.</li> <li> <p>In the Apps page, click ADD NEW.</p> <p></p> </li> </ol>"},{"location":"tutorials/foundry/lab-03.html#integration-service","title":"Integration Service","text":"<ol> <li> <p>Create a new VS Code VoltScript Workspace folder called foundry-domino.</p> <ol> <li>Open Visual Studio Code.</li> <li> <p>From the Explorer view, click Open Folder.</p> <p></p> </li> <li> <p>Create a new folder in your user directory, with the name stated above.</p> </li> <li>Select the newly created folder to open in VS Code.</li> </ol> </li> </ol>"},{"location":"tutorials/foundry/lab-03.html#atlasjson","title":"atlas.json","text":"<ol> <li>Right-click in the empty pane and select New File from the context menu.</li> <li>Name the file \"atlas.json\".</li> <li>Type \"foundry-atlas\" and accept the snippet.</li> <li>Set name to \"foundry-lab-domino\".</li> <li>Set description to \"DRAPI in Foundry Lab\".</li> <li>Set displayName to \"foundry-lab-domino\".</li> <li>Complete publisher and authors.</li> <li>Delete repo and library elements.</li> <li>Set version to \"1.0.0\".</li> <li>Add array elements in mainScripts for \"populate.vss\" and \"update.vss\".</li> <li>Add the usual repositories to the repositories array for VSEs and Library Modules.</li> <li>In the dependencies array, add VoltScript JSON Converter and VoltScript VoltMX Middleware:<ol> <li>Set library to \"voltscript-voltmx-middleware\".</li> <li>Set version to \"latest\".</li> <li>Set module to \"VoltMXObjects.vss\".</li> <li>Set repository to \"hcl-github\".</li> <li>Set library to \"voltscript-json-converter\".</li> <li>Set version to \"latest\".</li> <li>Set module to \"VoltScriptJsonConverter.vss\".</li> <li>Set repository to \"hcl-github\".</li> </ol> </li> <li>Add an entry to the vseDependencies object.<ol> <li>Create a JSON element with the label DrapiVSE.</li> <li>Refer to the DrapiVSE Dependency Documentation for the current <code>library</code>, <code>version</code>, <code>module</code>, and <code>repository</code> values.</li> </ol> </li> <li>Delete unitTestScripts, integrationTestScripts, and testDependencies elements.</li> <li> <p>Save the atlas.json.</p> The final atlas.json should look like this: <pre><code>{\n    \"name\": \"foundry-lab-domino\",           // REQUIRED: Enter a short name for your VoltScript project, e.g. \"Demo1\"\n    \"description\": \"DRAPI in Foundry Lab\",  // REQUIRED: Enter a longer description, e.g. \"My first demo project\"\n    \"displayName\": \"foundry-lab-domino\",  // A longer name to refer to the project, e.g. \"Demo 1\"\n    \"license\": \"Apache 2.0\",    // A license to publish the project under.\n                                // If you want this to be used by others, Apache 2.0 or MIT are recommended\n    \"publisher\": \"HCL America, Inc.\",   // Copyright owner\n    \"authors\": [        // REQUIRED: An array of authors, can be names or emails\n        \"YOUR NAME HERE\"\n    ],\n    \"version\":\"1.0.0\",  // REQUIRED: Current version for this project, used with dependency management to find the modules\n    \"sourceDir\": \"src\", // REQUIRED: Directory where mainScripts are located\n    \"testDir\": \"test\",  // Directory where unitTestScripts and integrationTestScripts are located\n    \"libsDir\": \"libs\",  // Directory where VoltScript Library Modules and shared scripts are located\n    \"vsesDir\": \"vses\",  // Directory where VoltScript Extensions are located\n    \"mainScripts\": [    // REQUIRED: Main scripts with Sub Initialize. Used to sync any additional files between\n                        // sourceDir and testDir, if libsDir not set\n        \"populate.vss\",\n        \"update.vss\"\n    ],\n    \"repositories\": [       // Repositories in which to search for any dependencies\n        {\n            \"id\": \"hcl-github\",     // REQUIRED: Unique ID matching \"repository\" in a dependency in this file.\n                            // Also matches label of a JSON object in atlas-settings, which gives any credentials to use to access this repository\n            \"type\": \"github\",   // REQUIRED: Currently \"github\" or \"webserver\" are supported\n            \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\" // REQUIRED: Base URL of the repository\n        },\n        {\n            \"id\": \"volt-mx-marketplace\",\n            \"type\": \"marketplace\",\n            \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n        }\n    ],\n    \"dependencies\": [\n        {\n            \"library\": \"voltscript-voltmx-middleware\",  // REQUIRED: Folder to be appended to the base URL when dependency management tries to download modules\n            \"version\": \"latest\",  // REQUIRED: Version number of modules to download. Currently only supports explicit version or \"latest\"\n            \"module\": \"VoltMXObjects.vss\",   // REQUIRED: Filename of a VoltScript Library Module to download\n            \"repository\": \"hcl-github\"\n        },\n        {\n            \"library\": \"voltscript-json-converter\",\n            \"version\": \"latest\",\n            \"module\": \"VoltScriptJsonConverter.vss\",\n            \"repository\": \"hcl-github\"\n        }\n    ],\n    \"vseDependencies\": {    // VoltScript Extension dependencies. NOTE: These also require a label\n        \"DrapiVSE\": {        // REQUIRED: This label will be what you use in \"UseVSE\" statements\n            \"library\": \"DrapiVSE VoltScript Extension\",  // REQUIRED: Folder to be appended to the base URL when dependency management tries to download modules\n            \"version\": \"1.0.0\",  // REQUIRED: Version number of modules to download. Currently only supports explicit version or \"latest\"\n            \"module\": \"drapivse\",   // REQUIRED: Filename of a VoltScript Library Module to download\n            \"repository\": \"volt-mx-marketplace\"\n        }\n    }\n}\n</code></pre> </li> </ol>"},{"location":"tutorials/foundry/lab-03.html#voltscript-dependency-manager","title":"VoltScript Dependency Manager","text":"<ol> <li> <p>From the Command Palette in VS Code, run \"VoltScript: Run Dependency Setup\". This will ensure that (among other things) a .vss folder is created within your VoltScript workspace.  </p> </li> <li> <p>From the Command Palette, run \"VoltScript: Install Dependencies\".</p> </li> <li>Enter the project directory, confirm atlas-settings.json and atlas.json locations.</li> </ol> <p>Success</p> <p>Your project should now have \"src\", \"test\", \"libs\", and \"vses\" directories.</p> <ul> <li>The src directory is empty.</li> <li>The test directory is empty.</li> <li>The libs directory has been populated with <code>VoltScriptJsonConverter.vss</code>, <code>VoltMXObjects.vss</code> and <code>VoltScriptCollections.vss</code>. VoltScriptCollections is a downstream dependency of VoltMXObjects.</li> <li>The vses directory has been populated with ddl and so files for DrapiVSE, ContextVSE, JsonVSE - these are downstream dependencies used by VoltMXObjects, automatically picked up because of its atlas.json.</li> <li>A new file, <code>seti.ini</code>, has been created. This contains mapping for the VoltScript Extensions (VSEs) and will be used for mapping <code>UseVSE</code> statements.</li> <li>A new file, <code>effective-atlas.json</code>, has been added to the root of the directory. This contains the aggregated settings for the project.</li> </ul>"},{"location":"tutorials/foundry/lab-03.html#demo-data","title":"demo data","text":"<ol> <li>Create a file in the src directory called <code>demodata.json</code>.</li> <li>Paste in the JSON from company-contacts.json.</li> <li>Save the file.</li> </ol>"},{"location":"tutorials/foundry/lab-03.html#contact-class","title":"Contact class","text":"<ol> <li>Create a file in libs directory called <code>functions.vss</code>. This will hold reusable code.</li> <li>Set <code>Option Public</code> and <code>Option Declare</code>.</li> <li>Add <code>Use \"VoltMXObjects\"</code> and <code>Use \"VoltScriptJsonConverter\"</code> directives.</li> <li>Create a class called <code>Contact</code>.</li> <li>Declare four public string variables - <code>firstName</code>, <code>lastName</code>, <code>email</code> and <code>company</code>.</li> </ol>"},{"location":"tutorials/foundry/lab-03.html#company-class","title":"Company class","text":"<ol> <li>In <code>functions.vss</code> create a class called <code>Company</code>.</li> <li>Declare two public string variables - <code>company</code> and <code>address</code>.</li> <li>Declare a public variant variable - <code>contacts</code>.</li> <li>Add a sub called <code>addToJsonArray</code> taking a single argument <code>jsonArr as JsonObject</code>.</li> <li> <p>Add the following code:</p> <pre><code>Dim childDoc as JsonObject\nDim mainDoc as New JsonObject()\n\nCall mainDoc.insertValue(\"Form\", \"Company\")\nCall mainDoc.insertValue(\"Company\", Me.company)\nCall mainDoc.insertValue(\"Address\", me.address)\nCall jsonArr.appendToJsonArray(mainDoc)\n\nForAll contact in contacts\n    Set childDoc = new JsonObject()\n    Call childDoc.insertValue(\"Form\", \"Contact\")\n    Call childDoc.insertValue(\"Company\", Me.company)\n    Call childDoc.insertValue(\"FirstName\", contact.firstName)\n    Call childDoc.insertValue(\"LastName\", contact.lastName)\n    Call childDoc.insertValue(\"Email\", contact.email)\n    Call jsonArr.appendToJsonArray(childDoc)\nEnd ForAll</code></pre> </li> </ol>"},{"location":"tutorials/foundry/lab-03.html#convertjson-function","title":"convertJson function","text":"<ol> <li>In <code>functions.vss</code> create a function called <code>convertJson()</code> that takes no arguments and returns a JsonObject.</li> <li> <p>For the body of the function, enter:</p> <pre><code>Dim jsonObj as JsonObject\nDim temp as JsonObject\nDim company as Company\n\nDim parser as New JsonParser()\nDim docs as New JsonObject(True)\nDim helper as New JsonConversionHelper()\nDim contactConverter as New JsonBasicObjectArrayConverter(\"Contact\", \"../libs/functions\")\n\n' Load file\nCall parser.loadFromFile(PROJECT_DIR &amp; \"/src/demodata.json\")\nSet jsonObj = parser.getRootObject()\n\n'Deserialize Customers\nCall helper.withCustomConverter(\"contacts\", contactConverter)\nForAll child in jsonObj.getChildren()\n    Set temp = child\n    Set company = helper.toObject(temp, \"Company\", \"../libs/functions\").fromJson(temp)\n    Call company.addToJsonArray(docs)\nEnd ForAll\n\nReturn docs</code></pre> </li> <li> <p>Save the file.</p> </li> </ol> <p>The code loads the JSON and seeds a <code>JsonConversionHelper</code> with a <code>BasicObjectArrayConverter</code> to convert the <code>contacts</code> array to <code>Contact</code> objects. This only populates the first name, last name, and email. The code iterates each JSON object and creates a <code>Company</code> object for each, populating company, address and the contacts.</p>"},{"location":"tutorials/foundry/lab-03.html#populatevss","title":"populate.vss","text":"<ol> <li>Create a file called <code>populate.vss</code> in src directory.</li> <li>Type \"foundry\" and accept the Foundry Boilerplate snippet.</li> <li>Add a directive to use the <code>DrapiVSE</code> VoltScript Extension</li> <li>Add a directive to use functions library you just saved.</li> <li> <p>Add the following declarations at the top of the <code>Sub Initialize</code>:</p> <pre><code>Dim docs as JsonObject\nDim request as DrapiRequest\nDim responseObj as JsonObject\n\nDim payload as New JsonObject()\nDim server as New DrapiServer()\nDim parser as new JsonParser()\n\nDim response as DrapiResponse\n\nDim username as String \nDim password as String </code></pre> </li> <li> <p>Add the following code between the <code>START OF FOUNDRY HANDLER</code> and <code>END OF FOUNDRY HANDLER</code>:</p> <pre><code>server.serverURL = VoltMXRequest.getInputParam(\"serverURL\")\nusername = VoltMXRequest.getInputParam(\"username\")\npassword = VoltMXRequest.getInputParam(\"password\")\n\nCall server.login(username, password)\n\nSet request = server.createRequest(\"companiesandcontacts\")\nSet docs = convertJson()\nCall payload.insertValue(\"documents\", docs)\n\nSet response = request.bulkCreateDocuments(payload.toString(false))\nCall parser.loadFromJson(response.ContentBody)\nSet responseObj = parser.getRootObject()\n\nVoltMxResult.httpStatusCode = 200\nCall VoltMXResult.result.insertValue(\"result\", responseObj.childCount &amp; \" docs created\")</code></pre> </li> <li> <p>Save the file.</p> </li> </ol> <p>Info</p> <p>In this exercise we will be logging into Foundry with named credentials. This simulates authenticating with a service account. These credentials could be provided in multiple ways:</p> <ul> <li>passed into each request (not recommended).</li> <li>session variables set during a basic authentication call to Foundry.</li> <li>request variables retrieved during a preprocessor from environment variables or other stored location.</li> <li>session variables lazy-loaded during a preprocessor.</li> <li>hard-coded credentials in the script, as done here. Admins may wish to add more restricted access to Foundry console to secure the credentials.</li> </ul> <p>If you want to run as the current user, the better approach would be to use an Identity Service, as you would have done if you have configured Domino Adapter for other Volt MX Go tutorials. This will be done in the Identity Service and DRAPI tutorial.</p>"},{"location":"tutorials/foundry/lab-03.html#package-for-volt-foundry","title":"Package for Volt Foundry","text":"<ol> <li>From the Command Palette, run \"VoltScript: Package for Foundry\".</li> <li>Enter the project directory.</li> <li>Confirm atlas.json locations.</li> <li>Enter <code>src/demodata.json</code> for additional files to package.</li> </ol> <p>Success</p> <p>A file will be created in the root of the project called \"foundry-lab.1.0.0.zip\". The zip name comprises the project name and the project version from the atlas.json.</p>"},{"location":"tutorials/foundry/lab-03.html#create-volt-foundry-integration-service","title":"Create Volt Foundry Integration Service","text":"<ol> <li>Log into Volt Foundry.</li> <li>On the Apps page, click ADD NEW.</li> <li> <p>On Configure Services tab, click the Integration tab and then click CONFIGURE NEW.</p> <p></p> </li> <li> <p>Set the Name to \"foundry-drapi-vs\".</p> </li> <li>Select \"VoltScript\" for Service Type.</li> <li>Click Upload New and select the zip file you just created.</li> <li>Click SAVE &amp; ADD OPERATION.</li> <li>Set the name to \"populate\".</li> <li>Select \"populate.vss\" as the file.</li> <li>Click ADD OPERATION.</li> <li>Scroll down to the Request Input tab and click + Add Parameter.</li> <li>Set the NAME to <code>serverURL</code>.</li> <li> <p>Set the TEST VALUE to your domino server's Domino REST API base url, for example <code>http://localhost:8880/api/v1</code>.</p> <p>Note</p> <p>The URL needs to end with <code>/api/v1</code>.</p> </li> <li> <p>Add a parameter for <code>username</code> and set the TEST VALUE to your username for your DRAPI Server.  </p> </li> <li>Add a parameter for <code>password</code> and set the TEST VALUE to your password for your DRAPI Server.</li> <li>Verify that the ENCODE checkbox for all parameters is checked.</li> <li>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</li> <li> <p>On Identity Backed Response tab, click AUTHORIZE to authenticate to the Domino REST API.</p> <p>Success</p> <p>The output result shows the following JSON object:</p> <pre><code>{\n    \"result\": \"739 docs created\",\n    \"opstatus\": 0,\n    \"httpStatusCode\": 200\n}\n</code></pre> <p>Tip</p> <p>Verify by opening the database with Notes Client / Nomad Web. The \"companies\" view will have Company documents in it. The \"contacts\" view will have Contact documents which have the company name. This process can be used to seed a test database with demo documents or, by passing a JSON payload, it can be used to replace an import agent with a REST service endpoint.</p> <p>Advanced</p> <p>Further enhancements are possible:</p> <ul> <li>Add proper error handling.</li> <li>Unit testing could be added to test the <code>convertJson</code> function.</li> <li>You could test the main code to populate the database. You would move it into a function, with the <code>DrapiServer()</code> object and variables passed. The <code>DrapiServer</code> would need to be manually logged in using <code>DrapiServer.login(*username*,*password*)</code> before being passed to the function.</li> <li>The REST service can be enhanced further to validate the incoming JSON, in the same way that an import agent would validate each line of a CSV file. VoltScript Testing Framework can be used to perform validation</li> </ul> </li> </ol>"},{"location":"tutorials/foundry/lab-03.html#updatevss","title":"update.vss","text":"<ol> <li>Create a file called <code>update.vss</code> in src directory.</li> <li>Type \"foundry\" and accept the Foundry Boilerplate snippet.</li> <li>Add directives to use the <code>DrapiVSE</code> VoltScript Extension and the functions library.</li> <li> <p>Add the following declarations at the top of the <code>Sub Initialize</code>:</p> <pre><code>Dim request as DrapiRequest\nDim doc as DrapiDocument\nDim companyPayload as JsonObject\n\nDim parser as New JsonParser()\nDim server as New DrapiServer()\nDim replaceItems as New JsonObject()\n\nDim response as DrapiResponse\nDim newCompanyName As String\nDim oldCompanyName As String\nDim query as String\nDim unid as String\n\nDim username as String \nDim password as String</code></pre> </li> <li> <p>Between the two comment blocks, enter the following code:</p> <pre><code>unid = VoltMXRequest.getInputParam(\"unid\")\nnewCompanyName = VoltMXRequest.getInputParam(\"CompanyName\")\nserver.serverURL = VoltMXRequest.getInputParam(\"serverURL\")\nusername = VoltMXRequest.getInputParam(\"username\")\npassword = VoltMXRequest.getInputParam(\"password\")\nCall server.login(username, password)\n\nSet request = server.createRequest(\"foundrycontacts\")\nSet doc = request.getDocument(unid)\n\nCall parser.loadFromJson(doc.JsonValue)\nSet companyPayload = parser.getRootObject()\noldCompanyName = companyPayload.getChild(\"Company\").scalarValue\nCall companyPayload.insertValue(\"Company\", newCompanyName)\ndoc.JsonValue = companyPayload.toString(false)\nCall VoltMxResult.result.insertValue(\"companyUpdated\", doc.put(\"\", \"default\"))\n\nquery = \"Form = 'Contact' and Company = '\" &amp; oldCompanyName &amp; \"'\"\nCall replaceItems.insertValue(\"Company\", newCompanyName)\nSet response = request.bulkPatchDocuments(query, replaceItems.toString(false), \"html\", \"default\", 5000, True, True)\nCall parser.loadFromJson(response.ContentBody)\nVoltMxResult.httpStatusCode = 200\nCall VoltMxResult.result.insertValue(\"contactsUpdated\", parser.getRootObject())</code></pre> </li> <li> <p>Save the file.</p> </li> </ol>"},{"location":"tutorials/foundry/lab-03.html#re-package-for-volt-foundry","title":"Re-Package for Volt Foundry","text":"<ol> <li>From the Command Palette, run \"VoltScript: Package for Foundry\".</li> <li>Enter the project directory.</li> <li>Confirm atlas.json locations.</li> <li>Enter <code>src/demodata.json</code> for additional files to package.</li> </ol> <p>Success</p> <p>A file is created in the root of the project called \"foundry-lab.1.0.0.zip\". The zip name comprises the project name and the project version from the atlas.json.</p>"},{"location":"tutorials/foundry/lab-03.html#update-the-integration-service","title":"Update the Integration Service","text":"<ol> <li>Log into Volt Foundry.</li> <li>On the Apps page, select the app you created.</li> <li>On Configure Services tab, click the Integration tab.</li> <li>Click the Service Definition tab for the \"foundry-drapi-vs\" integration service.</li> <li>Click Upload New and select the zip file you just created. You will receive a warning that this will update the endpoint operations. Click OK.</li> <li>Click SAVE &amp; ADD OPERATION.</li> <li>Set the name to \"update\".</li> <li>Select \"update.vss\" as the file.</li> <li>Click ADD OPERATION.</li> <li>Scroll down to the Request Input tab and click + Add Parameter.</li> <li>Add the parameters for <code>serverURL</code>, <code>username</code>, and <code>password</code> in the same manner as you did for the populate service.</li> <li>Click + Add Parameter and set the NAME to <code>unid</code>.</li> <li>Copy the UNID of a Company document in the Domino database.</li> <li>Set the TEST VALUE to the UNID.</li> <li>Click + Add Parameter and set the NAME to <code>CompanyName</code>.</li> <li>Set the TEST VALUE to a modified company name.</li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</p> <p>Success</p> <p>The output result shows a JSON object with:</p> <ul> <li><code>httpStatusCode</code> set to 200.</li> <li><code>companyUpdated</code> set to <code>true</code>.</li> <li><code>contactsUpdated</code> containing a JSON object of results for each contact update - UNID, success message, and status details.</li> </ul> </li> </ol>"},{"location":"tutorials/foundry/lab-04.html","title":"Foundry Lab 04 - VoltScript pre/postprocessors","text":""},{"location":"tutorials/foundry/lab-04.html#duration-15-min","title":"Duration 15 Min","text":""},{"location":"tutorials/foundry/lab-04.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to create a JSON integration service, manipulate / validate input parameters in a VoltScript preprocessor and manipulate the output in VoltScript postprocessor.</p>"},{"location":"tutorials/foundry/lab-04.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 03 completed</li> </ul>"},{"location":"tutorials/foundry/lab-04.html#steps","title":"Steps","text":""},{"location":"tutorials/foundry/lab-04.html#create-integration-service","title":"Create Integration Service","text":"<ol> <li>Log into Volt Foundry.</li> <li>On the Apps page, click ADD NEW</li> <li> <p>On Configure Services tab, click the Integration tab and then click CONFIGURE NEW.</p> <p></p> </li> <li> <p>Set the Name to \"petstore\".</p> </li> <li>Select \"JSON\" under Service Type.</li> <li>Set the Base URL to \"https://petstore.swagger.io/v2/\".</li> <li>Click SAVE &amp; ADD OPERATION.</li> <li>On the NewOperation tab, set the Name to \"getPets\".</li> <li> <p>Set the Target URL to \"pet/findByStatus?status=$status\".</p> <p>Note</p> <p>The <code>$status</code> means it will pick up an input parameter called \"status\".</p> </li> <li> <p>Scroll down to the Request Input tab and click + Add Parameter.</p> </li> <li>Set the NAME to \"status\".</li> <li>Set the TEST VALUE to \"available\".</li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</p> <p>Success</p> <p>A JSON payload of available pets is returned.</p> </li> </ol>"},{"location":"tutorials/foundry/lab-04.html#create-preprocessor","title":"Create preprocessor","text":"<ol> <li>On the NewOperation tab, expand the Advanced section.</li> <li>On the Custom Code Invocation tab, select the VoltScript radio button under Preprocessor.</li> <li>Select the Validate Input Parameter code snippet. This shows how to retrieve and check input parameters, using <code>return false</code> to abort execution.</li> <li> <p>Replace the code with the following VoltScript code:</p> <pre><code>Dim status as String\nstatus = VoltMxRequest.getInputParam(\"status\")\n\nSelect Case status\n\nCase \"0\":\n    Call VoltMxResult.addInputParam(\"status\",\"available\")\nCase \"1\":\n    Call VoltMxResult.addInputParam(\"status\",\"pending\")\nCase \"2\":\n    Call VoltMxResult.addInputParam(\"status\",\"sold\")\nCase Else\n    Call VoltMxResult.setErrorMessage(\"Unexpected status passed - \" &amp; status)\n    return false\nEnd Select</code></pre> <p>This manipulates the incoming parameter, switching from a number to a corresponding string.</p> </li> <li> <p>Change the test value to <code>0</code>.</p> </li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</p> <p>Note</p> <p>The output result just includes opstatus and httpStatusCode. This is because nothing has been mapped from the backend response (the response from the JSON service) to the output result (the Foundry response).</p> </li> <li> <p>On the Backend Response, click [0] to create a response.</p> <p></p> <p>If you scroll down the operation and look at the Response Output tab, you'll see a <code>responseList</code> collection has been added to the output, along with all the JSON elements.</p> <p></p> </li> <li> <p>On the Test tab, change the status passed in the JSON object to \"available\".</p> <p></p> </li> <li> <p>Click Save and Retest.</p> <p>Success</p> <p>You've ran validation and manipulated an input parameter. Although this particular use case is unlikely, two of the most common use cases for a preprocessor will be validating an input parameter and setting an input parameter, which we've done here.</p> </li> </ol>"},{"location":"tutorials/foundry/lab-04.html#create-postprocessor","title":"Create postprocessor","text":"<ol> <li>On the NewOperation tab, expand the Advanced section.</li> <li>On Custom Code Invocation tab, select the \"VoltScript\" radio button under Postprocessor.</li> <li> <p>Paste the following VoltScript code:</p> <pre><code>Dim child as JsonObject\nDim responseList as JsonObject\nDim newResponseList as New JsonObject()\nSet responseList = VoltMXResult.result.getChild(\"responseList\")\nForAll jsonObj in responseList.getChildren()\n    Set child = jsonObj\n    If (child.isChild(\"name\")) Then\n        Call child.insertValue(\"name\", StrConv(child.getChild(\"name\").scalarValue, 3))\n        Call newResponseList.appendToJsonArray(child)\n    End If\nEnd ForAll\nCall VoltMxResult.result.insertValue(\"responseList\", newResponseList)</code></pre> <p>This gets the <code>responseList</code> element in the <code>VoltMxResult</code> result. \"responseList\" was the name the response was mapped to on the Response Output tab. We then iterate the children and, for those with a \"name\" element, proper case the name and add to a new JsonObject array. We then replace the <code>responseList</code> element with the new JSON array.</p> </li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</p> <p>Success</p> <p>You've manipulated the response from a third-party integration service. This is one of the most common use cases for a postprocessor.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/index.html","title":"Enabling VoltScript in Volt Foundry","text":"<p>With the release of Volt MX Go v10.0, VoltScript can now be enabled in Volt Foundry using the VoltScript Plugin Installer, which adds VoltScript plugins to Volt Foundry.</p> <p>For more information, see the Enable VoltScript in Volt Foundry how-to guide in the Volt MX Go documentation.</p>"},{"location":"tutorials/foundryinstall/downloadhelmchart.html","title":"Install Domino REST API","text":"<p>The procedure guides you in downloading the Domino REST API Helm chart and deploying Domino REST API.</p>"},{"location":"tutorials/foundryinstall/downloadhelmchart.html#1-download-the-domino-rest-api-helm-chart","title":"1. Download the Domino REST API Helm chart","text":"<ol> <li> <p>Run the following command to make sure that the chart information for the repositories is up-to-date.</p> <pre><code>helm repo update\n</code></pre> </li> <li> <p>Run the following command to download the chart:</p> <pre><code>helm pull hclcr/drapi\n</code></pre> <p>The file <code>drapi-1.n.n.tgz</code> is downloaded.</p> </li> <li> <p>Run the following commands to unpack the chart and make the DRAPI directory your current directory:</p> <pre><code>tar -xzvf drapi-1.n.n.tgz\ncd drapi\n</code></pre> <p>Note</p> <p>Ensure the version number specified here with tar matches the version you downloaded, such as <code>drapi-1.0.7.tgz</code>.</p> </li> <li> <p>Edit the <code>values.yaml</code> file using your preferred editor to update the file with your HCL Container Repository credentials, and the DNS name settings.</p> <ol> <li> <p>Locate the following lines in the file and replace <code>your-email</code> and <code>your-authentication-token</code> with your email and authentication token used with the HCL Container Repository:</p> <pre><code>imageCredentials:\n    username: your-email\n    password: your-authentication-token\n</code></pre> <p>Note</p> <p>Use the CLI secret value you saved from obtaining authentication token from HCL Container Repository as your authentication token or password.</p> </li> <li> <p>Locate the following lines in the file and add your DNS hostname settings:</p> <pre><code>ingress:\n    drapiDnsName:\n    drapiManagementDnsName:\n</code></pre> <p>Example</p> <p>The example names used are <code>drapi.mymxgo.com</code> and <code>drapi-management.mymxgo.com</code> respectively. <pre><code># The DNS host names that users will access the Domino REST API with.\ndrapiDnsName: \"drapi.mymxgo.com\"\n\n# The DNS host name administrators will access the REST API management\n# interface with.\ndrapiManagementDnsName: \"drapi-management.mymxgo.com\"\n</code></pre></p> <p>Hostnames must be resolvable</p> <p>Whatever hostnames you specify here, you need to ensure that they are resolvable. Make sure you have completed the relevant steps to update your hosts file for your relevant Operating system setup</p> </li> <li> <p>Locate the following lines in the file for the Administrator's first name, last name, and password. Set values for each of these settings. In our example we're using \"mxgo\", \"admin\" and \"password\". However, if you use your own values, remember the values and use them when required. Remember that the values of <code>dominoAdminFirstName</code> and <code>dominoAdminLastName</code> are combined, but separated by a space, to form the username.</p> <pre><code>dominoAdminFirstName: \"mxgo\"\ndominoAdminLastName: \"admin\"\ndominoAdminPassword: \"password\"\n</code></pre> <p>The following fields may be of interest to you as well and may be customized to suite your deployment:</p> <pre><code>dominoServerDomainName: \"ocp\"\ndominoOrgName: \"ocp\"\ndominoServerName: \"drapi\"\ndominoNetworkHostname: \"\"\n</code></pre> <p>Optional Use Existing Domino Environment</p> <p>Consult the Table of variables in Run Domino REST API with a Docker image in the  Domino REST API documentation to determine if you need to revise these settings. The mapping of <code>values.yaml</code> settings to variables is as follows:</p> <ul> <li><code>dominoServerDomainName = SERVERSETUP_SERVER_DOMAINNAME</code></li> <li><code>dominoOrgName = SERVERSETUP_ORG_ORGNAME</code></li> <li><code>dominoServerName = SERVERSETUP_SERVER_NAME</code></li> <li><code>dominoNetworkHostname = SERVERSETUP_NETWORK_HOSTNAME</code></li> </ul> </li> <li> <p>Determine how you want to expose the Domino server to Notes clients by setting the value of the <code>exposeNRPC</code> parameter to any of the following options:</p> <ul> <li><code>do-not-expose</code>: Set this value to prevent exposure of TCP port 1352 to the network.</li> <li> <p><code>HostPort</code>: Set this value to use TCP port 1352 on your machine for the Notes client to communicate with Domino using the Notes Remote Procedure Call (NRPC) protocol. This is only recommended when using Rancher Desktop for Kubernetes.</p> </li> <li> <p><code>NodePort</code>: Set this value if you want Kubernetes to allocate a random port in a specified range, by default 30000 to 32767, that's available on every worker node in the cluster. Kubernetes automatically routes traffic on this port from the Kubernetes node to the back-end Domino pod. This is the recommended option if you want to expose NRPC to your Notes Clients when deploying into a non Rancher Desktop cluster. See Create a new server connection under Procedure for instructions on how to obtain the random port number.</p> </li> <li> <p><code>LoadBalancer</code>: Set this value if you want an external load balancer to be provisioned by a cloud provider which supports external load balancers. Traffic from the external load balancer is directed at the Domino pod, and the cloud provider decides how it is load balanced. Kubernetes typically starts off by making the changes that are equivalent to you requesting NodePort. The cloud-controller-manager component then configures the external load balancer to forward traffic to that assigned node port.</p> </li> </ul> <p>You can read more about these options in the Service topic in the Kubernetes documentation.</p> </li> </ol> </li> <li> <p>(Optional) If you would like to configure Ingress for Domino REST API, proceed to Configure Kubernetes Ingress for Domino REST API.</p> </li> <li> <p>Save the file and exit.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/downloadhelmchart.html#2-deploy-domino-rest-api","title":"2. Deploy Domino REST API","text":"<ol> <li> <p>Deploy Domino REST API by running the following Helm install command:</p> <pre><code>helm install domino . -f values.yaml -n mxgo\n</code></pre> <p>Note</p> <p>The images must be pulled. It might take awhile, 90 seconds or longer, for the pod to start.</p> </li> <li> <p>Run the following command to wait for the Domino pod to be running and in the ready state:</p> <pre><code>kubectl get pods -o wide -w --namespace mxgo\n</code></pre> <p>Note</p> <p>The <code>-w</code> flag tells the kubectl command to wait, and updates the output over time with any changes.</p> <p>Eventually you should see 3/3 in the READY column as shown below:</p> <pre><code>NAME                           READY   STATUS              RESTARTS   AGE\ndomino-drapi-68596f98fd-bkpdz  0/3     ContainerCreating   0          34s\ndomino-drapi-68596f98fd-bkpdz  3/3     Running             0          72s\n</code></pre> </li> <li> <p>Once you see the READY column showing 3/3, press <code>Ctrl-c</code> to cancel the command.</p> </li> <li> <p>To connect to Domino server from your Notes client, see Connect to Domino server from your Notes client.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/downloadhelmchart.html#next-step","title":"Next step","text":"<p>Proceed to Install MySql for Volt Foundry.</p>"},{"location":"tutorials/foundryinstall/faqs.html","title":"Helm and Kubernetes FAQs","text":""},{"location":"tutorials/foundryinstall/faqs.html#why-does-not-my-pod-have-a-running-status","title":"Why does not my pod have a \"Running\" status?","text":"<p>The <code>kubectl describe pods NAME</code> command can give you more information about the status of the pod. This includes any errors, such as insufficient memory.</p>"},{"location":"tutorials/foundryinstall/faqs.html#why-is-the-host-name-not-resolved","title":"Why is the host name not resolved?","text":"<p>Ensure you have updated the hosts file correctly. Also ensure kube-dns has been restarted, either by restarting Rancher Desktop or issuing the terminal command <code>kubectl delete pod -n kube-system -l k8s-app=kube-dns</code>.</p>"},{"location":"tutorials/foundryinstall/faqs.html#why-dont-i-see-any-pods-running","title":"Why don't I see any pods running?","text":"<p>Pods are added to a namespace. The Volt Foundry pods were added to the mxgo namespace. You may be in the wrong namespace, possibly the default namespace. Run the terminal command <code>kubectl get pods</code>. It will give the message \"No resources found in NAME namespace\", where NAME is replaced by the current context. Run the <code>kubectl config set-context --current --namespace=mxgo</code> command to set the current namespace context correctly.</p>"},{"location":"tutorials/foundryinstall/installfoundry.html","title":"Install Volt Foundry","text":"<p>The procedures will guide you in the installation of Volt Foundry.</p>"},{"location":"tutorials/foundryinstall/installfoundry.html#1-download-volt-foundry-charts","title":"1. Download Volt Foundry charts","text":"<ol> <li> <p>Run the following command to make sure that the chart information for the repositories is up-to-date.</p> <pre><code>helm repo update\n</code></pre> </li> <li> <p>Run the following commands to download the Volt Foundry chart, unpack the files, change directory, and add execute permission:</p> <pre><code>helm pull hclcr/foundry-all\ntar -xzf foundry-all-0.6.0.tgz\ncd foundry-all\nchmod +x init-guids.sh\n</code></pre> <p>Note</p> <p>The chart name has a version string in the filename. The <code>helm pull</code> command will pull down the latest version of the chart. Ensure your tar command uses the correct matching filename, such as <code>foundry-all-0.6.0.tgz</code>.</p> </li> <li> <p>Volt Foundry uses several Global Unique IDs to distinguish different installations of Volt Foundry. Invoke the init-guids script to generate the IDs using the following command:</p> <pre><code>./init-guids.sh --new\n</code></pre> </li> <li> <p>Edit the <code>values.yaml</code> file to update the <code>imageCredentials</code> by replacing <code>your-email</code> and   <code>your-authentication-token</code> with your email and authentication token used with the HCL Container Repository.</p> <pre><code>imageCredentials:\n  username: your-email\n  password: your-authentication-token\n</code></pre> <p>Note</p> <p>Use the CLI secret value you saved from obtaining authentication token from HCL Container Repository as your authentication token or password.</p> </li> <li> <p>Locate the following line in the file and add your Volt Foundry server domain name setting:</p> <pre><code>serverDomainName:\n</code></pre> <p>Example</p> <p>The example name used is <code>foundry.mymxgo.com</code>. <pre><code>### Application Server Details ###\n\n# Domain name for Volt Foundry (String)\n# This value should not be IP address or 'localhost'\n# This value should be hostname of the LoadBalancer\nserverDomainName: \"foundry.mymxgo.com\"\n</code></pre></p> <p>Hostnames must be resolvable</p> <p>Whatever hostnames you specify here, you need to ensure that they are resolvable. Make sure you have completed the relevant steps to update your hosts file for your relevant Operating system setup</p> </li> <li> <p>Locate the following lines in the file and add your Volt Foundry database details. Use the example values as they match the values used for the MySQL install in the Install MySQL for Volt Foundry.</p> <pre><code>### Database details ###\n\n# Database type which you want to use for Volt Foundry (String)\n# Possible values:\n#   \"mysql\" for MySQL DB server\n#   \"sqlserver\" for Azure MSSQL or SQLServer\n#   \"oracle\" for Oracle DB server\ndbType: \"mysql\"\n\n# Database server hostname (String)\ndbHost: \"mysql\"\n\n# Database server port number (Number). This can be empty for cloud managed service.\ndbPort: 3306\n\n# Database User and password - you may set a single general userid/password here,\n# or you may set specific userid/password combinations below.  If set, the\n# specific values override the general dbUser/dbPass.\n\n# Database server user (String)\ndbUser: \"root\"\n\n# Database server password (String) enclosed in quotes\ndbPass: \"Password123!\"\n</code></pre> <p>See Installing_Containers_With_Helm.html for more details.</p> </li> <li> <p>(Optional) If you would like to install the <code>Engagement</code> component, you can do so by locating the following line in the file and setting the value to <code>true</code>.</p> <pre><code>engagementEnabled: true\n</code></pre> </li> <li> <p>Save the file and exit.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/installfoundry.html#2-install-volt-foundry","title":"2. Install Volt Foundry","text":"<ol> <li> <p>Run the following Helm install command to deploy Volt Foundry:</p> <pre><code>helm install foundry . -f values.yaml\n</code></pre> <p>Important</p> <p>The deployment process takes several minutes (more than 5 minutes based on tests). Kindly wait for the process to complete. Once done, you receive a notification that the application has been deployed successfully, including release, build, database, and application information. Otherwise, you will receive an error notification that the deployment is unsuccessful.</p> <p>Installation Failure</p> <p></p> <p>If an installation failure occurs, perform the following steps:</p> <ol> <li>Issue the command <code>helm uninstall foundry</code>. This gives you a clean slate for installation. </li> <li>Verify all configuration information is correct. </li> <li>Double check that you do not have another running Foundry (such as a prior development version) container.</li> <li>Ensure your Rancher Desktop is up to date. </li> <li>Ensure your Kubernetes version used by Rancher Desktop is up to date. </li> <li>Ensure you have enough resources (memory / processors) assigned to Rancher Desktop. </li> <li>Restart your Rancher desktop and try the installation again.</li> </ol> </li> <li> <p>Run the following command to verify when the Volt Foundry install is ready:</p> <pre><code>kubectl get pods -o wide -w\n</code></pre> <p>The output should be similar to the following and will update over time:</p> <p></p> </li> <li> <p>Monitor all the foundry pods except for the foundry-db-update pod as it has already been completed. Once the other foundry pods have a 1/1 state in the READY column, press <code>Ctrl-c</code> to stop the kubectl command.</p> </li> </ol> <p>Volt Foundry is now available at http://foundry.mymxgo.com/mfconsole/.</p> <p>Note</p> <ul> <li>If you defined a different Volt Foundry hostname, the Volt Foundry URL would be the defined Volt Foundry hostname concatenated with <code>/mfconsole/</code>.</li> <li> <p>If you want to access this deployment from a remote machine, you most likely need to update the <code>/etc/hosts</code> file on the remote machine as well. Specify the IPv4 address for the Windows system where Volt Foundry is installed. If using a wired connection, use the IPv4 Address under Ethernet adapter Ethernet 3. If using a wireless connection, use the IPv4 Address under Wireless LAN adapter Wi-Fi.</p> </li> <li> <p>To create an account, see Create a Volt Foundry administrator account.</p> </li> </ul>"},{"location":"tutorials/foundryinstall/installmysqlfoundry.html","title":"Install MySQL for Volt Foundry","text":"<p>The procedure guides you in installing MySQL for Volt Foundry.</p>"},{"location":"tutorials/foundryinstall/installmysqlfoundry.html#procedure","title":"Procedure","text":"<ol> <li> <p>Run the following commands to create a Volt Foundry directory in the proper location, and make the Volt Foundry directory the current directory:</p> <pre><code>cd ..\nmkdir foundry\ncd foundry\n</code></pre> </li> <li> <p>Run the following command to make sure that the chart information for the repositories is up-to-date.</p> <pre><code>helm repo update\n</code></pre> </li> <li> <p>Run the following commands to install the Bitnami MySQL Helm chart to use for the Volt Foundry database storage:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm install mysql bitnami/mysql --version \"9.6.0\" --set image.tag=\"8.0.32-debian-11-r17\",auth.rootPassword=\"Password123\\!\",auth.createDatabase=false,auth.username=dbclient,auth.password=\"Password123\\!\" -n mxgo\n</code></pre> <p>Note</p> <p>The command is specifying a simple password (Password123!) for the root account. You may want to change this password. If you do, make note of it, as the correct password must be specified again when you install Volt Foundry.</p> </li> <li> <p>Run the following command to verify when the database is in the ready state:</p> <pre><code>kubectl get pods -o wide -w --namespace mxgo\n</code></pre> <p>mysql-0 should show 1/1 in the READY column as shown in the following output example to indicate that the database is in the ready state.</p> <pre><code>NAME                              READY   STATUS    RESTARTS   AGE\ndomino-drapi-5c65d76c6c-rkfml     3/3     Running   0          11m\nmysql-0                           1/1     Running   0          45s\n</code></pre> </li> <li> <p>Once the database is in the ready state, press <code>Ctrl-c</code> to stop the command.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/installmysqlfoundry.html#next-step","title":"Next step","text":"<p>Proceed to Install Volt Foundry.</p>"},{"location":"tutorials/foundryinstall/obtainauthenticationtoken.html","title":"Obtain authentication token from HCL Container Repository","text":""},{"location":"tutorials/foundryinstall/obtainauthenticationtoken.html#about-this-task","title":"About this task","text":"<p>The binary images and Helm charts for Volt MX Go server components are pulled from the HCL Container Repository. This requires you to get your authentication token from the HCL Container Repository. This task guides you on how to obtain your authentication token.</p>"},{"location":"tutorials/foundryinstall/obtainauthenticationtoken.html#procedure","title":"Procedure","text":"<ol> <li> <p>Go to the HCL Container Repository.</p> </li> <li> <p>On the login page, click LOGIN VIA OIDC Provider, and then login using your corporate email address.</p> </li> <li> <p>On the Projects page, click your username and select User Profile.</p> <p></p> </li> <li> <p>On the User Profile dialog, copy the value of the CLI secret by clicking the copy icon.</p> <p></p> </li> <li> <p>Save the CLI secret value as it's required in the next steps.</p> <p>Note</p> <p>You will use the CLI secret value as your authentication token or password when using Docker or Helm CLI to access HCL Container Repository.</p> </li> <li> <p>Take note of exactly how your email address is written in the User Profile dialog as authentication is case sensitive on the user email.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/obtainauthenticationtoken.html#next-step","title":"Next step","text":"<p>Complete preparatory procedure for installation of Volt Foundry.</p>"},{"location":"tutorials/foundryinstall/prereqs/index.html","title":"Prerequisites","text":"<p>Installing Volt Foundry uses Helm and some flavor of Kubernetes. If you use Rancher Desktop, this comes with both Helm and k3s, a slimmed-down version of Kubernetes. This is the easiest option and is available for Windows and Mac.</p> <p>Rancher Desktop Information</p> <ul> <li>For more information on Rancher Desktop, see Introduction in the Rancher Desktop documentation.</li> <li>Rancher Desktop installation instructions for Windows can be found here.</li> <li>Rancher Desktop installation instructions for MacOS can be found here.</li> </ul> <p>Follow the platform-specific steps depending on your operating system and setup:</p> <ul> <li>Windows without Rancher Desktop</li> <li>Windows with Rancher Desktop</li> <li>Intel Mac with Rancher Desktop</li> <li>Ubuntu or VM</li> </ul>"},{"location":"tutorials/foundryinstall/prereqs/mac.html","title":"Mac with Rancher Desktop","text":""},{"location":"tutorials/foundryinstall/prereqs/mac.html#operating-system","title":"Operating System","text":"<ul> <li>MacOS Ventura (version 13) or greater</li> </ul>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#hardware","title":"Hardware","text":"Spec Minimum CPU 4 core (Intel) RAM 16 GB"},{"location":"tutorials/foundryinstall/prereqs/mac.html#additional-requirements","title":"Additional requirements","text":"<p>Rancher Desktop requires the following on MacOS:</p> <ul> <li>Apple Silicon (M1) or Intel CPU with VT-x (virtualization capabilities).</li> <li>Persistent internet connection.</li> </ul> <p>If you do not already have Rancher Desktop installed, follow the installation instructions for MacOS here.</p> <p>Note</p> <p>It is recommended to use Rancher Desktop version 1.15.1.</p> <p>Most of the default settings will be adequate. However, the default virtual machine size of 4GB is insufficient for Volt Foundry.</p> <ol> <li>Cick on the Rancher Desktop icon in the system tray.</li> <li>Click Open preferences dialog.</li> <li>On the Virtual Machines tab change \"Memory (GB)\" to 8.</li> </ol> <p>Note</p> <p>If you have the Rancher Desktop main window open, you can access the preferences dialog by clicking on the \"cog\" icon.</p>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#additional-information","title":"Additional information","text":"<p>When run for the first time or when changing versions, Kubernetes container images are downloaded. It may take a little time to load on the first run for a new Kubernetes version.</p> <p>After Rancher Desktop installation, users have access to these supporting utilities:</p> <ul> <li>Helm</li> <li>kubectl</li> <li>nerdctl</li> <li>Moby</li> <li>Docker Compose</li> </ul>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#export-username-and-authentication-token","title":"Export username and authentication token","text":"<p>The binary images and Helm charts for Volt MX Go server components are pulled from the HCL Container Repository. You must obtain your authentication token from the HCL Container Repository before running the commands.</p> <p>Run the following commands to export the username and authentication token.</p> <p>Note</p> <ul> <li>Replace <code>&lt;your hclcr username&gt;</code> with your email address as shown in the User Profile dialog. Take note of exactly how your email address is written in the User Profile dialog as authentication is case sensitive on the user email.</li> <li>Replace <code>&lt;your hclcr authentication token&gt;</code> with the CLI secret value you copied from the User Profile dialog.</li> </ul> <pre><code>export HCLCR_USERNAME=&lt;your hclcr username&gt;\n</code></pre> <pre><code>export HCLCR_TOKEN=&lt;your hclcr authentication token&gt;\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#configure-helm-to-pull-from-hcl-container-repository","title":"Configure Helm to pull from HCL Container Repository","text":"<p>The procedure sets up Helm with the details necessary to authenticate with the HCL Container Repository. You will need your email and authentication token used with the HCL Container Repository.</p> <p>Warning</p> <p>If you have previously used <code>hclcr</code> with https://hclcr.io/chartrepo/voltmxgo, execute the following command to remove the old repository.</p> <pre><code>helm repo remove hclcr \n</code></pre> <p>Run the following command to set up Helm:</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username &lt;your hclcr username&gt; --password &lt;your CLI secret&gt;\n</code></pre> <p>Warning</p> <p>Use the CLI secret value you saved from obtaining authentication token from HCL Container Repository as your authentication token or password. Do not use the password you use for logging in. <code>helm</code> commands use the CLI secret.</p> <p>Example</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username user.name@example.com --password xx3ds2w\n</code></pre> <p>Failure</p> <p>If you get an error message similar to the following:</p> <pre><code>Error: looks like https://hclcr.io/chartrepo/voltmxgo is not a valid chart repository or cannot be reached: failed to fetch https://hclcr.io/chartrepo/voltmxgo/index.yaml : 401 Unauthorized\n</code></pre> <p>Most likely, you haven't specified your username or authentication token correctly. Make sure the case and content matches exactly what's listed on the HCL Container Repository site and retry.</p>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#create-a-namespace-for-mxgo","title":"Create a namespace for MXGO","text":"<p>Run the following commands to create a namespace and set the current context to mxgo:</p> <pre><code>kubectl create namespace mxgo\n</code></pre> <pre><code>kubectl config set-context --current --namespace=mxgo\n</code></pre> <p>Note</p> <p>You must run the <code>kubectl config set-context --current --namespace=mxgo</code> command to set the current namespace context after each restart of Windows or Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#ensure-volt-foundry-hostnames-are-resolvable","title":"Ensure Volt Foundry hostnames are resolvable","text":"<p>You must ensure the url used to access Volt Foundry and Domino REST API are resolvable by all systems that will be accessing it including Kubernetes and any browsers that you use. This can be done by adding DNS host names and IP addresses to your corporate DNS configuration, or by modifying the hosts file for all systems.</p> <p>In the examples that follow we're going to use these hostnames as examples:</p> <pre><code>drapi.mymxgo.com - used to access Domino REST API.\ndrapi-management.mymxgo.com - used to access the Domino REST API Management interface.\nfoundry.mymxgo.com - used to access HCL Volt Foundry\n</code></pre> <p>Note</p> <p>If you are using a Domino REST API installation on an existing server, you only need to set <code>foundry.mymxgo.com</code> hostname.</p> <p>You can either provide your own hostnames, or use these example names. Either the name to IP address mapping must be made in your DNS configuration, or you must modify your system hosts file. Further documentation here assumes you aren't using a DNS system and configuration and are therefore modifying local hosts file entries.</p>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#update-hosts-file","title":"Update hosts file","text":"<ol> <li> <p>Edit your\u00a0<code>/etc/hosts</code>\u00a0file to associate this IPV4 address with the *.mymxgo.com domian entries</p> <p>For example:</p> <pre><code># Foundry in Rancher\n127.0.0.1 drapi.mymxgo.com drapi-management.mymxgo.com foundry.mymxgo.com\n</code></pre> </li> <li> <p>Save the file and exit the editor.</p> </li> <li> <p>Run the following command to force the restart of the coredns pod:</p> <pre><code>kubectl delete pod -n kube-system -l k8s-app=kube-dns\n</code></pre> </li> <li> <p>Restart Rancher Desktop:</p> <p>Click on the Rancher Desktop icon in your workspace and choose \"Quit Rancher Desktop\"</p> <p></p> <p>Once it has completely shut down (it may take a few minutes) you can start it again from your Applications Launcher.</p> </li> </ol> <p>Note</p> <p>You must run the <code>kubectl config set-context --current --namespace=mxgo</code> command to set the current namespace context after each restart of Windows or Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#create-a-temp-directory-for-the-charts","title":"Create a temp directory for the charts","text":"<p>Run the following commands to create a temp directory for the charts and make it the current directory:</p> <pre><code>mkdir ~/mxgo\ncd ~/mxgo\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/mac.html#next-step","title":"Next step","text":"<p>If you are using a pre-existing implementation of Domino REST API, proceed to Install MySQL for Volt Foundry. Otherwise proceed to Install Domino REST API.</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html","title":"Ubuntu or VM","text":"<p>These instructions are for deploying Volt Foundry using K3s on an Ubuntu, RHEL, SLES machine, or VM</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#operating-system","title":"Operating System","text":"<ul> <li>RHEL9</li> <li>Ubuntu</li> <li>SLES</li> </ul>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#hardware","title":"Hardware","text":"Spec Minimum CPU 4 cores RAM 16 GB"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#install-and-configure-k3s","title":"Install and configure K3s","text":"<p>Volt Foundry is deployable with Kubernetes using K3s on an Ubuntu, RHEL, SLES machine or VM.</p> <p>K3s is a fully compliant Kubernetes distribution. For more information, see K3s - Lightweight Kubernetes.</p> <p>Caution</p> <p>In all the following instructions, it's assumed you are running commands as a non-root user. However, there are certain commands that must with sudo permissions. For these commands, you need to configure your non-root user with sudo. To do this, see Using sudo to allow non-root users to perform root level functions.</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#install-k3s","title":"Install K3s","text":"<p>Before installing K3s, make sure you have met any operating system configuration required by K3s, specifically for RHEL and CENTOS.</p> <ol> <li> <p>Run the following command:</p> <pre><code>sudo sh -c 'curl -sfL https://get.k3s.io |  K3S_KUBECONFIG_MODE=\"644\" sh -s -'\n</code></pre> </li> <li> <p>Review the output and verify that there is no error or warning.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#enable-non-root-user-to-use-kube-commands","title":"Enable non-root user to use kube commands","text":"<ol> <li> <p>Replace <code>&lt;username&gt;</code> in the following command with your Linux username, which you will use to install and work on Volt MX Go. Run the command:</p> <pre><code>export K3SUSER=&lt;username&gt;\n</code></pre> </li> <li> <p>Make sure the environment variable is set by running the command:</p> <pre><code>echo $K3SUSER\n</code></pre> </li> <li> <p>Copy the K3s configuration file into your user's home directory and make it accessible by running the following commands:</p> <pre><code>sudo mkdir /home/$K3SUSER/.kube\nsudo cp -f /etc/rancher/k3s/k3s.yaml  /home/$K3SUSER/.kube/config\nsudo chown -R $K3SUSER:$K3SUSER /home/$K3SUSER/.kube\nsudo chmod -R 700 /home/$K3SUSER/.kube\n</code></pre> </li> </ol>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#update-the-kubeconfig-environment-variable","title":"Update the KUBECONFIG environment variable","text":"<p>Note</p> <p>If you are using bash for your login shell, update your <code>.bashrc</code> to export the KUBECONFIG variable. Make the appropriate change if you use a different shell.</p> <p>Run the commands to update the KUBECONFIG environment variable:</p> <pre><code>echo export KUBECONFIG=~/.kube/config &gt;&gt; /home/$K3SUSER/.bashrc\nexport KUBECONFIG=~/.kube/config\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#install-helm","title":"Install Helm","text":"<p>Helm is the package manager for Kubernetes and is used to install Volt MX Go. For more information, see Helm.</p> <p>To install Helm, run the following commands:</p> <pre><code>sudo wget https://get.helm.sh/helm-v3.11.2-linux-386.tar.gz\nsudo tar -xzf helm-v3.11.2-linux-386.tar.gz\nsudo mv linux-386/helm  /usr/local/bin/helm\nsudo rm -rf helm-v3.11.2-linux-386.tar.gz linux-386\n</code></pre> <p>For more information, see Installing Helm and Helm releases.</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#ensure-k3s-is-active-and-ready","title":"Ensure K3s is active and ready","text":"<ol> <li> <p>Run the following command to check if K3s has an active status:</p> <pre><code>sudo systemctl status k3s\n</code></pre> </li> <li> <p>Review the output. The example image shows K3s as active:</p> <p></p> </li> <li> <p>Run the following command to check if K3s is ready:</p> <pre><code>kubectl get nodes\n</code></pre> <p>The result should be similar as below:</p> <pre><code>NAME                   STATUS   ROLES                  AGE   VERSION\nvm1.example.com        Ready    control-plane,master   25h   v1.23.15+k3s1\n</code></pre> </li> </ol>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#export-username-and-authentication-token","title":"Export username and authentication token","text":"<p>The binary images and Helm charts for Volt MX Go server components are pulled from the HCL Container Repository. You must obtain your authentication token from the HCL Container Repository before running the commands.</p> <p>Run the following commands to export the username and authentication token.</p> <p>Note</p> <ul> <li>Replace <code>&lt;your hclcr username&gt;</code> with your email address as shown in the User Profile dialog. Take note of exactly how your email address is written in the User Profile dialog as authentication is case sensitive on the user email.</li> <li>Replace <code>&lt;your hclcr authentication token&gt;</code> with the CLI secret value you copied from the User Profile dialog.</li> </ul> <pre><code>export HCLCR_USERNAME=&lt;your hclcr username&gt;\n</code></pre> <pre><code>export HCLCR_TOKEN=&lt;your hclcr authentication token&gt;\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#configure-helm-to-pull-from-hcl-container-repository","title":"Configure Helm to pull from HCL Container Repository","text":"<p>The procedure sets up Helm with the details necessary to authenticate with the HCL Container Repository. You will need your email and authentication token used with the HCL Container Repository.</p> <p>Warning</p> <p>If you have previously used <code>hclcr</code> with https://hclcr.io/chartrepo/voltmxgo, execute the following command to remove the old repository.</p> <pre><code>helm repo remove hclcr \n</code></pre> <p>Run the following command to set up Helm:</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username &lt;your hclcr username&gt; --password &lt;your CLI secret&gt;\n</code></pre> <p>Warning</p> <p>Use the CLI secret value you saved from obtaining authentication token from HCL Container Repository as your authentication token or password. Do not use the password you use for logging in. <code>helm</code> commands use the CLI secret.</p> <p>Example</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username user.name@example.com --password xx3ds2w\n</code></pre> <p>Failure</p> <p>If you get an error message similar to the following:</p> <pre><code>Error: looks like https://hclcr.io/chartrepo/voltmxgo is not a valid chart repository or cannot be reached: failed to fetch https://hclcr.io/chartrepo/voltmxgo/index.yaml : 401 Unauthorized\n</code></pre> <p>Most likely, you haven't specified your username or authentication token correctly. Make sure the case and content matches exactly what's listed on the HCL Container Repository site and retry.</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#create-a-namespace-for-mxgo","title":"Create a namespace for MXGO","text":"<p>Run the following commands to create a namespace and set the current context to mxgo:</p> <pre><code>kubectl create namespace mxgo\n</code></pre> <pre><code>kubectl config set-context --current --namespace=mxgo\n</code></pre> <p>Note</p> <p>You must run the <code>kubectl config set-context --current --namespace=mxgo</code> command to set the current namespace context after each restart of Windows or Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#ensure-volt-foundry-hostnames-are-resolvable","title":"Ensure Volt Foundry hostnames are resolvable","text":"<p>You must ensure the url used to access Volt Foundry and Domino REST API are resolvable by all systems that will be accessing it including Kubernetes and any browsers that you use. This can be done by adding DNS host names and IP addresses to your corporate DNS configuration, or by modifying the hosts file for all systems.</p> <p>In the examples that follow we're going to use these hostnames as examples:</p> <pre><code>drapi.mymxgo.com - used to access Domino REST API.\ndrapi-management.mymxgo.com - used to access the Domino REST API Management interface.\nfoundry.mymxgo.com - used to access HCL Volt Foundry\n</code></pre> <p>Note</p> <p>If you are using a Domino REST API installation on an existing server, you only need to set <code>foundry.mymxgo.com</code> hostname.</p> <p>You can either provide your own hostnames, or use these example names. Either the name to IP address mapping must be made in your DNS configuration, or you must modify your system hosts file. Further documentation here assumes you aren't using a DNS system and configuration and are therefore modifying local hosts file entries.</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#update-hosts-file","title":"Update hosts file","text":"<p>Tip</p> <p>Obtain your machine's IP ADDRESS as you will need it in the following step.</p> <ol> <li> <p>Add the hostnames that you have chosen to use in your <code>/etc/hosts</code> file together with your IP ADDRESS and dns domain name. As an example:</p> <pre><code>10.190.252.181 drapi.mymxgo.com drapi-management.mymxgo.com foundry.mymxgo.com\n</code></pre> <p>Note</p> <p>If you are using a Domino REST API installation on an existing server, you only need to set <code>foundry.mymxgo.com</code> hostname.</p> <p>Note</p> <p>If you will be accessing this deployment from other remote machines, you need to apply this same <code>/etc/hosts</code> file change on those machines as well.</p> </li> <li> <p>Run the following command to make these name/IP address matches available within the Kubernetes:</p> <pre><code>kubectl edit configmap -n kube-system coredns\n</code></pre> </li> <li> <p>Locate the segment that looks like the following:</p> <pre><code>    import /etc/coredns/custom/*.server\nNodeHosts: |\n    10.190.252.181 vm1.example.com\nkind: ConfigMap\n</code></pre> </li> <li> <p>Before the line that starts with <code>kind: ConfigMap</code>, add a new line that uses the same IP address, but adds the hostnames you have chosen to use. When done, the segment of the file looks like the following code, but with your IP address and your own hostname. The previously hard-coded values are shown in this example:</p> <pre><code>    import /etc/coredns/custom/*.server\nNodeHosts: |\n    10.190.252.181 vm1.example.com\n    10.190.252.181 drapi.mymxgo.com drapi-management.mymxgo.com foundry.mymxgo.com\nkind: ConfigMap\n</code></pre> </li> <li> <p>Save the file and exit the editor.</p> </li> <li> <p>Run the following command to force the restart of the coredns pod:</p> <pre><code>kubectl delete pod -n kube-system -l k8s-app=kube-dns\n</code></pre> </li> </ol>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#create-a-temp-directory-for-the-charts","title":"Create a temp directory for the charts","text":"<p>Run the following commands to create a temp directory for the charts and make it the current directory:</p> <pre><code>mkdir ~/mxgo\ncd ~/mxgo\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#install-wget-and-curl-into-your-linux-environment","title":"Install wget and curl into your Linux environment","text":"<p>If wget and curl are not alreay installed to your Linux environment, there are numerous websites containing detailed instructions on how to do so.</p>"},{"location":"tutorials/foundryinstall/prereqs/ubuntu.html#next-step","title":"Next step","text":"<p>If you are using a pre-existing implementation of Domino REST API, proceed to Install MySQL for Volt Foundry. Otherwise proceed to Install Domino REST API.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html","title":"Windows without Rancher Desktop","text":""},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#operating-system","title":"Operating System","text":"<ul> <li>Windows 10 build 1909 or higher</li> <li>Windows 11</li> </ul>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#hardware","title":"Hardware","text":"Spec Minimum CPU 4 cores RAM 32 GB"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#install-and-configure-k3s","title":"Install and configure K3s","text":"<p>Volt Foundry is deployable with Kubernetes using K3s on an Ubuntu, RHEL, SLES machine or VM.</p> <p>K3s is a fully compliant Kubernetes distribution. For more information, see K3s - Lightweight Kubernetes.</p> <p>Caution</p> <p>In all the following instructions, it's assumed you are running commands as a non-root user. However, there are certain commands that must with sudo permissions. For these commands, you need to configure your non-root user with sudo. To do this, see Using sudo to allow non-root users to perform root level functions.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#install-k3s","title":"Install K3s","text":"<p>Before installing K3s, make sure you have met any operating system configuration required by K3s, specifically for RHEL and CENTOS.</p> <ol> <li> <p>Run the following command:</p> <pre><code>sudo sh -c 'curl -sfL https://get.k3s.io |  K3S_KUBECONFIG_MODE=\"644\" sh -s -'\n</code></pre> </li> <li> <p>Review the output and verify that there is no error or warning.</p> </li> </ol>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#enable-non-root-user-to-use-kube-commands","title":"Enable non-root user to use kube commands","text":"<ol> <li> <p>Replace <code>&lt;username&gt;</code> in the following command with your Linux username, which you will use to install and work on Volt MX Go. Run the command:</p> <pre><code>export K3SUSER=&lt;username&gt;\n</code></pre> </li> <li> <p>Make sure the environment variable is set by running the command:</p> <pre><code>echo $K3SUSER\n</code></pre> </li> <li> <p>Copy the K3s configuration file into your user's home directory and make it accessible by running the following commands:</p> <pre><code>sudo mkdir /home/$K3SUSER/.kube\nsudo cp -f /etc/rancher/k3s/k3s.yaml  /home/$K3SUSER/.kube/config\nsudo chown -R $K3SUSER:$K3SUSER /home/$K3SUSER/.kube\nsudo chmod -R 700 /home/$K3SUSER/.kube\n</code></pre> </li> </ol>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#update-the-kubeconfig-environment-variable","title":"Update the KUBECONFIG environment variable","text":"<p>Note</p> <p>If you are using bash for your login shell, update your <code>.bashrc</code> to export the KUBECONFIG variable. Make the appropriate change if you use a different shell.</p> <p>Run the commands to update the KUBECONFIG environment variable:</p> <pre><code>echo export KUBECONFIG=~/.kube/config &gt;&gt; /home/$K3SUSER/.bashrc\nexport KUBECONFIG=~/.kube/config\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#install-helm","title":"Install Helm","text":"<p>Helm is the package manager for Kubernetes and is used to install Volt MX Go. For more information, see Helm.</p> <p>To install Helm, run the following commands:</p> <pre><code>sudo wget https://get.helm.sh/helm-v3.11.2-linux-386.tar.gz\nsudo tar -xzf helm-v3.11.2-linux-386.tar.gz\nsudo mv linux-386/helm  /usr/local/bin/helm\nsudo rm -rf helm-v3.11.2-linux-386.tar.gz linux-386\n</code></pre> <p>For more information, see Installing Helm and Helm releases.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#ensure-k3s-is-active-and-ready","title":"Ensure K3s is active and ready","text":"<ol> <li> <p>Run the following command to check if K3s has an active status:</p> <pre><code>sudo systemctl status k3s\n</code></pre> </li> <li> <p>Review the output. The example image shows K3s as active:</p> <p></p> </li> <li> <p>Run the following command to check if K3s is ready:</p> <pre><code>kubectl get nodes\n</code></pre> <p>The result should be similar as below:</p> <pre><code>NAME                   STATUS   ROLES                  AGE   VERSION\nvm1.example.com        Ready    control-plane,master   25h   v1.23.15+k3s1\n</code></pre> </li> </ol> <p>Important</p> <p>You must use an Ubuntu terminal session to run all the commands in this section and the other subsequent sections. To access the Ubuntu terminal, enter \"Ubuntu\" in the Windows search box and select the Ubuntu for Windows App. An Ubuntu terminal session opens with your home directory set as your current directory.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#export-username-and-authentication-token","title":"Export username and authentication token","text":"<p>The binary images and Helm charts for Volt MX Go server components are pulled from the HCL Container Repository. You must obtain your authentication token from the HCL Container Repository before running the commands.</p> <p>Run the following commands to export the username and authentication token.</p> <p>Note</p> <ul> <li>Replace <code>&lt;your hclcr username&gt;</code> with your email address as shown in the User Profile dialog. Take note of exactly how your email address is written in the User Profile dialog as authentication is case sensitive on the user email.</li> <li>Replace <code>&lt;your hclcr authentication token&gt;</code> with the CLI secret value you copied from the User Profile dialog.</li> </ul> <pre><code>export HCLCR_USERNAME=&lt;your hclcr username&gt;\n</code></pre> <pre><code>export HCLCR_TOKEN=&lt;your hclcr authentication token&gt;\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#configure-helm-to-pull-from-hcl-container-repository","title":"Configure Helm to pull from HCL Container Repository","text":"<p>The procedure sets up Helm with the details necessary to authenticate with the HCL Container Repository. You will need your email and authentication token used with the HCL Container Repository.</p> <p>Warning</p> <p>If you have previously used <code>hclcr</code> with https://hclcr.io/chartrepo/voltmxgo, execute the following command to remove the old repository.</p> <pre><code>helm repo remove hclcr \n</code></pre> <p>Run the following command to set up Helm:</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username &lt;your hclcr username&gt; --password &lt;your CLI secret&gt;\n</code></pre> <p>Warning</p> <p>Use the CLI secret value you saved from obtaining authentication token from HCL Container Repository as your authentication token or password. Do not use the password you use for logging in. <code>helm</code> commands use the CLI secret.</p> <p>Example</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username user.name@example.com --password xx3ds2w\n</code></pre> <p>Failure</p> <p>If you get an error message similar to the following:</p> <pre><code>Error: looks like https://hclcr.io/chartrepo/voltmxgo is not a valid chart repository or cannot be reached: failed to fetch https://hclcr.io/chartrepo/voltmxgo/index.yaml : 401 Unauthorized\n</code></pre> <p>Most likely, you haven't specified your username or authentication token correctly. Make sure the case and content matches exactly what's listed on the HCL Container Repository site and retry.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#create-a-namespace-for-mxgo","title":"Create a namespace for MXGO","text":"<p>Run the following commands to create a namespace and set the current context to mxgo:</p> <pre><code>kubectl create namespace mxgo\n</code></pre> <pre><code>kubectl config set-context --current --namespace=mxgo\n</code></pre> <p>Note</p> <p>You must run the <code>kubectl config set-context --current --namespace=mxgo</code> command to set the current namespace context after each restart of Windows or Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#ensure-volt-foundry-hostnames-are-resolvable","title":"Ensure Volt Foundry hostnames are resolvable","text":"<p>You must ensure the url used to access Volt Foundry and Domino REST API are resolvable by all systems that will be accessing it including Kubernetes and any browsers that you use. This can be done by adding DNS host names and IP addresses to your corporate DNS configuration, or by modifying the hosts file for all systems.</p> <p>In the examples that follow we're going to use these hostnames as examples:</p> <pre><code>drapi.mymxgo.com - used to access Domino REST API.\ndrapi-management.mymxgo.com - used to access the Domino REST API Management interface.\nfoundry.mymxgo.com - used to access HCL Volt Foundry\n</code></pre> <p>Note</p> <p>If you are using a Domino REST API installation on an existing server, you only need to set <code>foundry.mymxgo.com</code> hostname.</p> <p>You can either provide your own hostnames, or use these example names. Either the name to IP address mapping must be made in your DNS configuration, or you must modify your system hosts file. Further documentation here assumes you aren't using a DNS system and configuration and are therefore modifying local hosts file entries.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#update-hosts-file","title":"Update hosts file","text":"<p>Tip</p> <p>Obtain your machine's IP ADDRESS as you will need it in the following step.</p> <ol> <li> <p>Add the hostnames that you have chosen to use in your <code>/etc/hosts</code> file together with your IP ADDRESS and dns domain name. As an example:</p> <pre><code>10.190.252.181 drapi.mymxgo.com drapi-management.mymxgo.com foundry.mymxgo.com\n</code></pre> <p>Note</p> <p>If you are using a Domino REST API installation on an existing server, you only need to set <code>foundry.mymxgo.com</code> hostname.</p> <p>Note</p> <p>If you will be accessing this deployment from other remote machines, you need to apply this same <code>/etc/hosts</code> file change on those machines as well.</p> </li> <li> <p>Run the following command to make these name/IP address matches available within the Kubernetes:</p> <pre><code>kubectl edit configmap -n kube-system coredns\n</code></pre> </li> <li> <p>Locate the segment that looks like the following:</p> <pre><code>    import /etc/coredns/custom/*.server\nNodeHosts: |\n    10.190.252.181 vm1.example.com\nkind: ConfigMap\n</code></pre> </li> <li> <p>Before the line that starts with <code>kind: ConfigMap</code>, add a new line that uses the same IP address, but adds the hostnames you have chosen to use. When done, the segment of the file looks like the following code, but with your IP address and your own hostname. The previously hard-coded values are shown in this example:</p> <pre><code>    import /etc/coredns/custom/*.server\nNodeHosts: |\n    10.190.252.181 vm1.example.com\n    10.190.252.181 drapi.mymxgo.com drapi-management.mymxgo.com foundry.mymxgo.com\nkind: ConfigMap\n</code></pre> </li> <li> <p>Save the file and exit the editor.</p> </li> <li> <p>Run the following command to force the restart of the coredns pod:</p> <pre><code>kubectl delete pod -n kube-system -l k8s-app=kube-dns\n</code></pre> </li> </ol>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#create-a-temp-directory-for-the-charts","title":"Create a temp directory for the charts","text":"<p>Run the following commands to create a temp directory for the charts and make it the current directory:</p> <pre><code>mkdir ~/mxgo\ncd ~/mxgo\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#install-wget-and-curl-into-your-linux-environment","title":"Install wget and curl into your Linux environment","text":"<p>If wget and curl are not alreay installed to your Linux environment, there are numerous websites containing detailed instructions on how to do so.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-basic.html#next-step","title":"Next step","text":"<p>If you are using a pre-existing implementation of Domino REST API, proceed to Install MySQL for Volt Foundry. Otherwise proceed to Install Domino REST API.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html","title":"Windows with Rancher Desktop","text":""},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#operating-system","title":"Operating System","text":"<ul> <li>Windows 10 build 1909 or higher</li> <li>Windows 11</li> </ul>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#hardware","title":"Hardware","text":"Spec Minimum CPU 4 cores RAM 32 GB"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#additional-requirements","title":"Additional requirements","text":"<p>Rancher Desktop requires the following on Windows:</p> <ul> <li>Running on a machine with virtualization capabilities.</li> <li>Persistent internet connection.</li> <li>Windows Subsystem for Linux on Windows. This will automatically be installed as part of the Rancher Desktop setup. Manually downloading a distribution isn't necessary.</li> </ul> <p>Note</p> <p>You can use Rancher Desktop as a Non-Admin user on a Windows machine. However, an Admin's intervention is required during the installation process for the following components:</p> <ul> <li>WSL2 - Rancher Desktop requires Windows Subsystem for Linux (WSL2) on Windows. You need Admin privileges to install WSL2, which is an essential component of Rancher Desktop.</li> <li>Rancher Desktop Privileged Service - You need Admin privileges to install the Rancher Desktop privileged service, which is required to expose applications/services, running inside containers, on all interfaces on the host machine. However, you can skip the installation of the Rancher Desktop Privileged Service with the limitation that you will not be able to expose applications/services on any interface except 127.0.0.1.</li> </ul>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#install-or-update-wsl2","title":"Install or Update WSL2","text":"<p>Before installing Rancher Desktop, make sure you have an up-to-date installation of WSL2. If you are already using WSL2, update WSL2. Otherwise, install WSL2.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#update-wsl2","title":"Update WSL2","text":"<p>If you are already using WSL2, open PowerShell or Windows Command Prompt in administrator mode by right-clicking and selecting Run as administrator. Run the following command to make sure WSL2 is up-to-date:</p> <pre><code>wsl --update\n</code></pre> <p>Follow any instructions given by the WSL update process. Afterward, from a Windows command prompt or PowerShell window, run the following command to make sure Ubuntu is the default distribution:</p> For Ubuntu-22.04For Ubuntu-24.04 <pre><code>wsl --set-default Ubuntu-22.04\n</code></pre> <pre><code>wsl --set-default Ubuntu-24.04\n</code></pre> <p>Proceed to install Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#install-wsl2","title":"Install WSL2","text":"<p>Open PowerShell or Windows Command Prompt in administrator mode by right-clicking and selecting Run as administrator. Run the following command to install WSL2 using either Ubuntu-22.04 or Ubuntu-24.04 as the Linux distribution. </p> For Ubuntu-22.04For Ubuntu-24.04 <pre><code>wsl --install -d Ubuntu-22.04\n</code></pre> <pre><code>wsl --install -d Ubuntu-24.04\n</code></pre> <p>Important</p> <p>Restart your machine after this initial installation to complete the setup. Once the restart has completed, return to this documentation and complete the steps that follow.</p> <p>Enter <code>Ubuntu</code> on the Windows search box and open the Ubuntu on Windows App. You should be prompted to create a username and password.</p> <p>Tip</p> <p>Use the first letter of your first name and your full last name as your username such as jdoe. Use a password that's easy for you to remember.</p> <p>If you aren't prompted to create a username and password, run the following command to do so, adding your username such as sudo adduser jdoe:</p> <pre><code>sudo adduser\n</code></pre> <p>It's not required to enter more information, simply hit the Enter key and respond <code>Y</code> when prompted Is the information correct?.</p> <p>Important</p> <p>Make certain that Ubuntu-22.04 or Ubuntu-24.04 is your default WSL distribution. From a Windows command prompt or PowerShell window, run the following command:</p> For Ubuntu-22.04For Ubuntu-24.04 <pre><code>wsl --set-default Ubuntu-22.04\n</code></pre> <pre><code>wsl --set-default Ubuntu-24.04\n</code></pre> <p>You are now ready to install Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#install-rancher-desktop","title":"Install Rancher Desktop","text":"<ol> <li> <p>Download the latest version of the Windows installer from the Rancher Desktop Releases page.</p> <p>Note</p> <p>It is recommended to use Rancher Desktop version 1.15.1.</p> </li> <li> <p>Navigate to the directory where you downloaded the installer to and run the installer. This is usually the Downloads folder.</p> </li> <li>Review the License Agreement, and then click I Agree to proceed with the installation.</li> <li>If prompted, choose between installing for everyone on the machine or installing just for the current user. Installing for everyone is preferred to installing the Rancher Desktop Privileged Service.</li> <li>Follow the prompts to confirm installation.</li> <li>When the installation completes, click Finish to close the installation wizard.</li> <li> <p>Make sure that Ubuntu is selected under WSL in Rancher Desktop:</p> <ol> <li> <p>Open Rancher Desktop, and then click Preferences.</p> <p></p> </li> <li> <p>On the Rancher Desktop - Preferences dialog, click WSL and then click the Integrations tab.</p> </li> <li> <p>Select the Ubuntu checkbox.</p> <p></p> </li> <li> <p>On the Virtual Machines tab change \"Memory (GB)\" to 8.</p> </li> <li>Click Apply.</li> </ol> </li> </ol> <p>Important</p> <p>Use an Ubuntu terminal session to run all the commands in future sections. To access the Ubuntu terminal, enter \"Ubuntu\" in the Windows search box and select the Ubuntu for Windows App. An Ubuntu terminal session opens with your home directory set as your current directory.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#additional-information","title":"Additional information","text":"<p>When run for the first time or when changing versions, Kubernetes container images are downloaded. It may take a little time to load on the first run for a new Kubernetes version.</p> <p>After Rancher Desktop installation, users have access to these supporting utilities:</p> <ul> <li>Helm</li> <li>kubectl</li> <li>nerdctl</li> <li>Moby</li> <li>Docker Compose</li> </ul> <p>Important</p> <p>You must use an Ubuntu terminal session to run all the commands in this section and the other subsequent sections. To access the Ubuntu terminal, enter \"Ubuntu\" in the Windows search box and select the Ubuntu for Windows App. An Ubuntu terminal session opens with your home directory set as your current directory.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#export-username-and-authentication-token","title":"Export username and authentication token","text":"<p>The binary images and Helm charts for Volt MX Go server components are pulled from the HCL Container Repository. You must obtain your authentication token from the HCL Container Repository before running the commands.</p> <p>Run the following commands to export the username and authentication token.</p> <p>Note</p> <ul> <li>Replace <code>&lt;your hclcr username&gt;</code> with your email address as shown in the User Profile dialog. Take note of exactly how your email address is written in the User Profile dialog as authentication is case sensitive on the user email.</li> <li>Replace <code>&lt;your hclcr authentication token&gt;</code> with the CLI secret value you copied from the User Profile dialog.</li> </ul> <pre><code>export HCLCR_USERNAME=&lt;your hclcr username&gt;\n</code></pre> <pre><code>export HCLCR_TOKEN=&lt;your hclcr authentication token&gt;\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#configure-helm-to-pull-from-hcl-container-repository","title":"Configure Helm to pull from HCL Container Repository","text":"<p>The procedure sets up Helm with the details necessary to authenticate with the HCL Container Repository. You will need your email and authentication token used with the HCL Container Repository.</p> <p>Warning</p> <p>If you have previously used <code>hclcr</code> with https://hclcr.io/chartrepo/voltmxgo, execute the following command to remove the old repository.</p> <pre><code>helm repo remove hclcr \n</code></pre> <p>Run the following command to set up Helm:</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username &lt;your hclcr username&gt; --password &lt;your CLI secret&gt;\n</code></pre> <p>Warning</p> <p>Use the CLI secret value you saved from obtaining authentication token from HCL Container Repository as your authentication token or password. Do not use the password you use for logging in. <code>helm</code> commands use the CLI secret.</p> <p>Example</p> <pre><code>helm repo add hclcr https://hclcr.io/chartrepo/voltmxgo-ea --username user.name@example.com --password xx3ds2w\n</code></pre> <p>Failure</p> <p>If you get an error message similar to the following:</p> <pre><code>Error: looks like https://hclcr.io/chartrepo/voltmxgo is not a valid chart repository or cannot be reached: failed to fetch https://hclcr.io/chartrepo/voltmxgo/index.yaml : 401 Unauthorized\n</code></pre> <p>Most likely, you haven't specified your username or authentication token correctly. Make sure the case and content matches exactly what's listed on the HCL Container Repository site and retry.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#create-a-namespace-for-mxgo","title":"Create a namespace for MXGO","text":"<p>Run the following commands to create a namespace and set the current context to mxgo:</p> <pre><code>kubectl create namespace mxgo\n</code></pre> <pre><code>kubectl config set-context --current --namespace=mxgo\n</code></pre> <p>Note</p> <p>You must run the <code>kubectl config set-context --current --namespace=mxgo</code> command to set the current namespace context after each restart of Windows or Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#ensure-volt-foundry-hostnames-are-resolvable","title":"Ensure Volt Foundry hostnames are resolvable","text":"<p>You must ensure the url used to access Volt Foundry and Domino REST API are resolvable by all systems that will be accessing it including Kubernetes and any browsers that you use. This can be done by adding DNS host names and IP addresses to your corporate DNS configuration, or by modifying the hosts file for all systems.</p> <p>In the examples that follow we're going to use these hostnames as examples:</p> <pre><code>drapi.mymxgo.com - used to access Domino REST API.\ndrapi-management.mymxgo.com - used to access the Domino REST API Management interface.\nfoundry.mymxgo.com - used to access HCL Volt Foundry\n</code></pre> <p>Note</p> <p>If you are using a Domino REST API installation on an existing server, you only need to set <code>foundry.mymxgo.com</code> hostname.</p> <p>You can either provide your own hostnames, or use these example names. Either the name to IP address mapping must be made in your DNS configuration, or you must modify your system hosts file. Further documentation here assumes you aren't using a DNS system and configuration and are therefore modifying local hosts file entries.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#update-hosts-file","title":"Update hosts file","text":"<ol> <li> <p>From a Command Prompt on either Windows 10 or Windows 11, obtain the IPv4 Address for the Ethernet adapter vEthernet (WSL) via the\u00a0<code>ipconfig</code>\u00a0command.</p> <p></p> <p>Important</p> <ul> <li>Select the correct IPv4 Address under Ethernet adapter vEthernet (WSL (Hyper-V firewall)), which by default starts with 172. Placing the correct IPv4 address in the Windows host file ensures deployment is reachable from within WSL2 and Windows.</li> <li>If you want to access this deployment from a remote machine, you most likely need to update the <code>/etc/hosts</code> file on the remote machine as well. Specify the IPv4 address for the Windows system where Volt Foundry is installed. If using a wired connection, use the IPv4 Address under Ethernet adapter Ethernet 3. If using a wireless connection, use the IPv4 Address under Wireless LAN adapter Wi-Fi. </li> </ul> </li> <li> <p>Add the hostnames that you have chosen to use in your\u00a0<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>\u00a0file together with your\u00a0IPv4 ADDRESS\u00a0and\u00a0dns domain name.</p> <p>For example:</p> <pre><code>172.23.208.1 drapi.mymxgo.com drapi-management.mymxgo.com foundry.mymxgo.com\n</code></pre> </li> <li> <p>Save the file and exit the editor.</p> </li> <li> <p>Run the following command to force the restart of the coredns pod:</p> <pre><code>kubectl delete pod -n kube-system -l k8s-app=kube-dns\n</code></pre> </li> <li> <p>Restart Rancher Desktop:</p> <ol> <li>Select File \u2192 Exit to close the current session.</li> <li>Open a new session by opening Rancher Desktop via the desktop icon.</li> </ol> </li> </ol> <p>Note</p> <p>You must run the <code>kubectl config set-context --current --namespace=mxgo</code> command to set the current namespace context after each restart of Windows or Rancher Desktop.</p>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#create-a-temp-directory-for-the-charts","title":"Create a temp directory for the charts","text":"<p>Run the following commands to create a temp directory for the charts and make it the current directory:</p> <pre><code>mkdir ~/mxgo\ncd ~/mxgo\n</code></pre>"},{"location":"tutorials/foundryinstall/prereqs/windows-rancher.html#next-step","title":"Next step","text":"<p>If you are using a pre-existing implementation of Domino REST API, proceed to Install MySQL for Volt Foundry. Otherwise proceed to Install Domino REST API.</p>"},{"location":"tutorials/ide/index.html","title":"Introduction","text":"<p>The IDE for VoltScript development is Visual Studio Code. After installing it on your local machine, use the following instructions to configure Visual Studio Code for VoltScript development:</p> <ul> <li>Windows</li> <li>MacOS</li> <li>Docker</li> </ul> <p>After configuring Visual Studio Code:</p> <ul> <li>see Visual Studio Code extensions to learn more about VS Code extensions that support VoltScript project development.</li> <li>complete the Introduction to Voltscript workshop to learn working with VoltScript from creating a simple script to a full project, including unit tests.</li> </ul>"},{"location":"tutorials/ide/devcontainer.html","title":"VoltScript using a Docker Container","text":"<p>Docker Development is done using a Visual Studio Code Dev Container. This is a standard Visual Studio Code approach that mounts your folder inside a container. For more details see the Visual Studio Code documentation.</p> <p>Visual Studio Code is installed locally. The folder that opens in Visual Studio Code's Explorer view is physically on your host machine, but it has been injected into the Linux Docker container inside the \"/workspaces\" directory. Although Visual Studio Code has access to all extensions installed locally, effectively it believes it's running within the container: the terminal sees only the container, File \u2192 Open commands look for files in the container.</p> <p></p> <p>Note</p> <p>If the folder you're opening is within a git repository, Visual Studio Code seems to inject the whole git repository into the container and the same container seems to be shared across all folders opened in dev containers.</p> <p>Warning</p> <p>atlas-settings still needs to be in ~/.vss directory in the container. It will persist between uses of the container. But using the \"Dev Containers: Rebuild Container without Cache\" will delete the container, and thus the contents of the ~/.vss directory. You may wish to keep a copy locally, or investigate mounting a local .vss directory into the container.</p>"},{"location":"tutorials/ide/devcontainer.html#prerequisites","title":"Prerequisites","text":"<p>The pre-requisites for using Dev Containers are:</p> <ul> <li>Installing Docker Desktop (or Rancher Desktop).</li> <li>Installing Visual Studio Code.</li> <li>Installing the Dev Containers extension in Visual Studio code.</li> </ul> <p>This is covered in the Getting Started documentation, so you will need to go through the Installation section.</p> <p>The prerequisites only need to be installed once per laptop.</p>"},{"location":"tutorials/ide/devcontainer.html#docker-image","title":"Docker Image","text":"<p>You will need to load the docker image for VoltScript downloaded from Harbor. This includes the VoltScript executable, the VoltScript extensions for Visual Studio Code and VoltScript_Archipelago build manager code.</p> <ol> <li>Navigate to Harbor and login.</li> <li>On the Projects page, enter \"voltmxgo-ea\" in the search field, and then click \"voltscript-devcontainer\" on the search result.</li> <li>On the voltscript-devcontainer project page, click your username and select User Profile.</li> <li>Take note of exactly how your email address is shown.</li> <li> <p>Copy the CLI secret to your clipboard.</p> <p></p> <p>Note</p> <p>You will use the CLI secret as your authentication token when using Docker CLI to access the HCL Container Repository.</p> </li> <li> <p>Open up a Terminal window.</p> </li> <li>Type <code>docker login https://hclcr.io</code> and press enter.</li> <li>Enter the email address from your user profile as the username.</li> <li>Paste the CLI secret as the password.</li> <li> <p>Once login is successful, enter the command <code>docker pull hclcr.io/voltmxgo/voltscript-devcontainer:10.0.0_GA</code> and press enter.</p> <p>Warning</p> <p>Do not click the copy icon in the \"Pull Command\" column on the voltscript-devcontainer project page. This uses the SHA hash instead, so the Docker image will come down untagged.</p> <p></p> </li> <li> <p>The image should now be available. You can confirm by issuing the command <code>docker images</code>, where you should find an image named \"hclcr.io/voltmxgo/voltscript-devcontainer\" with a tag 10.0.0_GA.</p> </li> </ol>"},{"location":"tutorials/ide/devcontainer.html#creating-the-dev-container","title":"Creating the Dev Container","text":"<p>To instruct VS Code to open a folder in a container, you need to add a devcontainer.json file in the folder. This can be done either:</p> <ul> <li>In the root of your VS Code workspace, as .devcontainer.json.</li> <li>In a folder within your VS Code workspace, as .devcontainer/devcontainer.json.</li> </ul> <p>Note</p> <p>Remember to add the path to your .gitignore file, to avoid polluting other developers' environments.</p> <p>At the minimum, the JSON file must have the following content:</p> <pre><code>{\n    \"image\": \"hclcr.io/voltmxgo/voltscript-devcontainer:10.0.0_GA\",\n    // Configure tool-specific properties.\n    \"customizations\": {\n        // Configure properties specific to VS Code.\n        \"vscode\": {\n            \"extensions\": [\n                \"/tmp/vscode-voltscript.vsix\",\n                \"/tmp/vscode-voltscript-archipelago.vsix\"\n            ]\n        }\n    }\n}\n</code></pre> <p>This uses the image loaded and adds into VS Code the Linux VSIX, which is part of the image. Additional extensions can be added to the container, as required.</p> <p>Once the <code>devcontainer.json</code> is created and saved, you can bring up the Command Palette (View \u2192 Command Palette or the relevant platform keyboard shortcut) and navigate to \"Reopen in Container\" command. When you open VS Code and choose File \u2192 Open Recent, you will subsequently see entries appended with \"[Dev Container]\", which will automatically open the folder in the devcontainer.</p> <p>Note</p> <p>Any files added outside the workspace folder will be cached between sessions. So if you close VS Code and come back later, the atlas-settings.json file you create will still be available. However, if you use the command \"Dev Containers: Rebuild Container Without Cache\", it will delete the container and create a new one.</p> <p>Note</p> <p>A folder can only be opened in one devcontainer at a time. If you want to launch content in another container, that can be done with a standard <code>docker run --rm -it...</code> command from a terminal.</p> <p>Info</p> <p>The container will run as a non-root user, with limited access to the Linux filesystem. If you need to connect as root, this can be done with normal Docker commands for connecting to an existing running container: <code>docker exec -it --user root CONTAINER_NAME /bin/bash</code>. To find the container name, click on the \"Remote Explorer\" tab in the left-hand gutter. The container name will be displayed against the relevant dev container and in the attributes area of the middle panel.</p> <p>Warning</p> <p>If you open VS Code from a folder in Finder, linkages to Docker may not be created correctly. For consistent results, launch VS Code or a new window of VS Code, and open the folder from the File menu.</p>"},{"location":"tutorials/ide/devcontainer.html#advanced-dev-container-configuration","title":"Advanced Dev Container configuration","text":"<p>With the minimum configuration, each dev container will use its own atlas-settings.json and a .vss directory in the home directory of the dev container. There will be no custom environment variables available and no additional extensions installed locally. And if you rebuild the container because an updated image is made available, you'll lose the atlas-settings.json and any VSEs pulled down into the .vss directory by dependency management.</p> <p>However, there are a number of configuration options available for the VS Code devcontainer.json.</p>"},{"location":"tutorials/ide/devcontainer.html#shared-vss-directory","title":"Shared .vss directory","text":"<p>For first use, you'll need to create an atlas-settings.json in ~/.vss, as you do when working locally. To avoid this, you can mount a local .vss directory into the container. This is done with the <code>mounts</code> property. This can take with a string of key-value pairs or a JSON object.</p> <p>First, you'll need a .vss directory to mount in. Best practice, as with developing directly on your host machine, is to create it in your user directory, so ~/.vss. You can create an atlas-settings.json in there, or wait until you're in the dev container. (Hint: you'll get content assist and snippets in the dev container, because you've got the VoltScript VS Code extensions available.)</p> <p>Add one of the following JSON snippets to your devcontainer.json.</p> Using a string<pre><code>\"mounts\": [\n    \"source=${localEnv:HOME}/.vss,target=/home/vs-user/.vss,type=bind\"\n]\n</code></pre> Using an object<pre><code>\"mounts\": [\n    {\n        \"source\": \"${localEnv:HOME}/.vss\",\n        \"target\": \"/home/vs-user/.vss\",\n        \"type\": \"bind\"\n    }\n]\n</code></pre>"},{"location":"tutorials/ide/devcontainer.html#passing-environment-variables-explicitly","title":"Passing environment variables explicitly","text":"<p>You can pass environment variables into the container by using the <code>containerEnv</code> property. To pass in a username for your atlas-settings.json, use the following JSON:</p> <pre><code>\"containerEnv\": {\n    \"USERNAME\": \"YOUR_NAME\"\n}\n</code></pre> <p>You can check if it's been picked up by launching the dev container, opening a terminal and issuing the command <code>echo $USERNAME</code>. It should return the value from the dev container.</p>"},{"location":"tutorials/ide/devcontainer.html#passing-an-environment-file","title":"Passing an environment file","text":"<p>Of course it's not preferable to include passwords in your devcontainer.json, even though it's typically excluded from source control. With the <code>runArgs</code> property, you can use standard Docker commands to pass in an environment file instead. The file uses key-value pairs, as with any Docker env file. a .env file with this syntax will pass the username as above.</p> <pre><code>USERNAME=YOUR_NAME\n</code></pre> <p>Tip</p> <p>Check env file syntax if you need to include non-basic content like values including spaces.</p> <p>You'll probably want to store the file in your user directory and give it a filename that's clear, e.g. \".devcontainerEnv.env\". To use this in your devcontainer.json, you will need to add the following JSON:</p> <pre><code>\"runArgs\": [\n    \"--env-file\", \"${localEnv:HOME}/.devcontainerEnv.env\"\n]\n</code></pre>"},{"location":"tutorials/ide/devcontainer.html#useful-vs-code-variables","title":"Useful VS Code variables","text":"<p>You'll notice we've used some variables here. The VS Code documentation has full details. But two useful ones are:</p> <ul> <li><code>${localEnv:HOME}</code> to get the current user's HOME directory.</li> <li><code>${localWorkspaceFolder}</code> to get the folder opened in VS Code.</li> </ul>"},{"location":"tutorials/ide/devcontainer.html#working-with-the-devcontainer","title":"Working with the devcontainer","text":""},{"location":"tutorials/ide/devcontainer.html#vs-code-terminal","title":"VS Code Terminal","text":"<p>The VS Code terminal is now a Linux shell inside the container. You will usually find the folder from your host machine at \"workspaces/FOLDER_NAME\".</p> <p>Note</p> <p>This seems to differ if the folder is part of a git repository.</p>"},{"location":"tutorials/ide/devcontainer.html#dependency-management","title":"Dependency Management","text":"<p>Dependency management use a settings file in the devcontainer in the usual location, at <code>~/.vss/atlas-settings.json</code>. It's advisable to store a copy on your filesystem when opening additional containers or upgrading to a newer image.</p>"},{"location":"tutorials/ide/devcontainer.html#updating-to-a-new-image","title":"Updating to a New Image","text":"<p>If a new Docker image is released, you will need to pull the new image. You will also need to update the devcontainer.json in any project. After saving the modified devcontainer.json, you will be prompted to rebuild the container (or use \"Dev Containers: Rebuild Container Without Cache\"), to create a new container based on the updated image. Other options will just open the cached container based on the original image.</p> <p>Warning</p> <p>Make sure to backup any files modified in the container, such as in <code>~/.vss directory</code>.</p>"},{"location":"tutorials/ide/devcontainer.html#adding-languages-to-containers","title":"Adding languages to containers","text":"<p>No additional language packs are installed in the docker image. If you wish to use the locale parameters in ZuluVSE, you will need to add language packs. However, the container runs under a user who doesn't have access to change files outside specific locations. So you will need to connect to the container as the root user.</p> <ol> <li>Open the relevant project in its dev container in Visual Studio Code. The docker container needs to be running to connect to it as a different user.</li> <li>In Visual Studio Code, select the \"Remote Explorer\" icon in the left-hand gutter. In the top view, this will list dev containers created. In the middle view, this will list details of the current dev container. From here you can find the name of the docker container you wish to modify.</li> <li>Open a terminal window, outside of Visual Studio Code.</li> <li>Run the command <code>docker exec -it --user root CONTAINER_NAME /bin/bash</code>, using the relevant container name. This connects to the container an interactive session (<code>-it</code>) for bash (<code>/bin/bash</code>) as the root user (<code>--user root</code>).</li> <li>The terminal will now be running within the container, as evidenced by the prefix looking like \"root@8c451a0ea2fd:/#\" - the 12-character hex string is the container ID. Run the command <code>apt-get install language-pack-XX</code>, replacing \"XX\" with the relevant language suffix. This is a standard Linux command, so the relevant language codes are well-documented on the internet.</li> <li>After the language packs have completed, run <code>exit</code> to end the root session into the container.</li> </ol> <p>You don't need to restart Visual Studio Code to pick up the language pack.</p>"},{"location":"tutorials/ide/mac.html","title":"VoltScript on Mac (MacOS)","text":"<p>ARM-based MacOS Development is done using a native Visual Studio Code installation.</p> <p>Warning</p> <p>The current Mac install has only been tested on MacOS running ARM-based processors (Apple Silicon). No work has yet been done to support Intel Mac. For this, you should continue to use the dev container approach.</p>"},{"location":"tutorials/ide/mac.html#prerequisites","title":"Prerequisites","text":"<p>The only pre-requisites for using VoltScript on a Mac are:</p> <ul> <li>A Visual Studio Code installation.</li> </ul>"},{"location":"tutorials/ide/mac.html#installing-on-mac","title":"Installing on Mac","text":"<ol> <li>Download the VoltScript installer file from My HCLSoftware.</li> <li>Run the VoltScript installer, installing to your desired location, for example C:\\Program Files\\VoltScript.</li> </ol>"},{"location":"tutorials/ide/mac.html#installing-the-visual-studio-code-extensions","title":"Installing the Visual Studio Code extensions","text":"<ol> <li>Download the VoltScript VS Code extensions zip from My HCLSoftware and unzip.</li> <li>Open Visual Studio Code.</li> <li> <p>Bring up the Extensions view by using Ctrl + Shift + X or clicking the Extensions icon in the Activity Bar.</p> <p></p> </li> <li> <p>In the title bar of the Extensions editor, click the ellipsis (...) and select \"Install from VSIX...\".</p> <p>Note</p> <p>The search bar allows you to search for an extension in the VS Code Marketplace and not in the folder of installed extensions. The \"VoltScript Language Support\" extension has not yet been published to the VS Code Marketplace.</p> </li> <li> <p>Navigate to the directory into which you unzipped the VoltScript VS Code extensions.</p> </li> <li>Install vscode-voltscript-1.1.0.vsix.</li> <li>Repeat steps 3 - 5 for vscode-voltscript-archipelago-1.2.0.vsix. NOTE: there is a new release for this extension, but not for the VoltScript Language Support extension.</li> <li>Reload Visual Studio Code.</li> </ol> <p>Error mapping path</p> <p>Note that in EA4, if this is the first time you have installed the VoltScript Visual Studio Code Extensions, the VoltScript executable path is not correctly identified. It will find \"HCL VoltScript Early Access 4 Notices and Information.txt\" instead of the VoltScript executable. During EA4 you will need to manually amend the value.</p> <ol> <li>Go to Visual Studio Code's settings (Code &gt; Settings &gt; Settings on Mac, File &gt; Preferences &gt; Settings on Windows).</li> <li>Expand \"Extensions\" and select \"VoltScript Language Support\".</li> <li>Click on \"Edit in settings.json\"</li> <li>Amend the \"voltscript.executablePath\" value. It identifies the correct directory, but the filename needs amending to \"VoltScript.exe\" on Windows and \"VoltScript\" on Mac.</li> <li>Restart VS Code.</li> </ol> <p>You are now ready to start coding with VoltScript in Visual Studio Code.</p>"},{"location":"tutorials/ide/windows.html","title":"VoltScript on Windows","text":"<p>On Windows, you can use VoltScript natively. If Volt Foundry is installed on Windows, it is recommended that you develop also on Windows.</p>"},{"location":"tutorials/ide/windows.html#prerequisites","title":"Prerequisites","text":"<p>The only pre-requisite for using VoltScript is:</p> <ul> <li>Installing Visual Studio Code.</li> </ul> <p>Info</p> <p>On Windows, you do not have to develop in a dev container, but can. The most obvious use case for this will be if Volt Foundry is running on Linux and wanting to develop on the same architecture. If you wish to follow this approach, the steps are the same as for dev containers.</p>"},{"location":"tutorials/ide/windows.html#installing-on-windows","title":"Installing on Windows","text":"<ol> <li>Download the VoltScript installer file from My HCLSoftware.</li> <li>Run the VoltScript installer, installing to your desired location, for example C:\\Program Files\\VoltScript.</li> </ol> <p>Note</p> <p>If you previously installed VoltScript via a zip and manually added the PATH environment variable, you will need to manually remove the old PATH environment variable.</p>"},{"location":"tutorials/ide/windows.html#installing-the-visual-studio-code-extensions","title":"Installing the Visual Studio Code extensions","text":"<ol> <li>Download the VoltScript VS Code extensions zip from My HCLSoftware and unzip.</li> <li>Open Visual Studio Code.</li> <li> <p>Bring up the Extensions view by using Ctrl + Shift + X or clicking the Extensions icon in the Activity Bar.</p> <p></p> </li> <li> <p>In the title bar of the Extensions editor, click the ellipsis (...) and select \"Install from VSIX...\".</p> <p>Note</p> <p>The search bar allows you to search for an extension in the VS Code Marketplace and not in the folder of installed extensions. The \"VoltScript Language Support\" extension has not yet been published to the VS Code Marketplace.</p> </li> <li> <p>Navigate to the directory into which you unzipped the VoltScript VS Code extensions.</p> </li> <li>Install vscode-voltscript-1.1.0.vsix.</li> <li>Repeat steps 3 - 5 for vscode-voltscript-archipelago-1.2.0.vsix. NOTE: there is a new release for this extension, but not for the VoltScript Language Support extension.</li> <li>Reload Visual Studio Code.</li> </ol> <p>Error mapping path</p> <p>Note that in EA4, if this is the first time you have installed the VoltScript Visual Studio Code Extensions, the VoltScript executable path is not correctly identified. It will find \"HCL VoltScript Early Access 4 Notices and Information.txt\" instead of the VoltScript executable. During EA4 you will need to manually amend the value.</p> <ol> <li>Go to Visual Studio Code's settings (Code &gt; Settings &gt; Settings on Mac, File &gt; Preferences &gt; Settings on Windows).</li> <li>Expand \"Extensions\" and select \"VoltScript Language Support\".</li> <li>Click on \"Edit in settings.json\"</li> <li>Amend the \"voltscript.executablePath\" value. It identifies the correct directory, but the filename needs amending to \"VoltScript.exe\" on Windows and \"VoltScript\" on Mac.</li> <li>Restart VS Code.</li> </ol> <p>You are now ready to start coding with VoltScript in Visual Studio Code.</p>"},{"location":"tutorials/vs-in-foundry/index.html","title":"Introduction to Writing VoltScript in Volt Foundry","text":"<p>This workshop is designed to walk through creating integration services by writing the VoltScript code directly in Volt Foundry.</p> <ul> <li>Lab 01 creates a simple integration service to return a message element \"Hello World\".</li> <li>Lab 02 creates an integration service to echo the username passed and error if nothing is passed.</li> <li>Lab 03 creates an integration service to update DRAPI data using an existing identity service for OAuth token.</li> </ul>"},{"location":"tutorials/vs-in-foundry/lab-01.html","title":"VoltScript in Foundry Lab 01 - Hello World Integration Service","text":""},{"location":"tutorials/vs-in-foundry/lab-01.html#duration-20-min","title":"Duration 20 Min","text":""},{"location":"tutorials/vs-in-foundry/lab-01.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to create a simple integration service to return a JSON object including a message element that says \"Hello World\" - all by writing the VoltScript code within Volt Foundry.</p>"},{"location":"tutorials/vs-in-foundry/lab-01.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Familiarity with creating an Integration Service in Volt Foundry.</li> <li>It would be good to have completed the VoltScript Foundry Tutorial Lab 01.</li> </ul>"},{"location":"tutorials/vs-in-foundry/lab-01.html#steps","title":"Steps","text":""},{"location":"tutorials/vs-in-foundry/lab-01.html#create-volt-foundry-integration-service","title":"Create Volt Foundry Integration Service","text":"<ol> <li>Log into Volt Foundry.</li> <li> <p>On the Apps page, click ADD NEW.</p> <p></p> </li> <li> <p>On Configure Services tab, click the Integration tab and then click CONFIGURE NEW.</p> <p></p> </li> <li> <p>Set the Name to \"vs-in-foundry-lab\".</p> </li> <li>Select \"VoltScript\" under Service Type.</li> <li> <p>Click Create New.</p> <p></p> </li> <li> <p>Set the Name to \"helloWorld\".</p> </li> <li>Set the Version to \"1.0\".</li> <li>OPTIONALLY enter a Description if desired.</li> <li> <p>On the VSS Files tab, click Add (+), then select Add New File.</p> <p></p> </li> <li> <p>In the Add New File dialog, enter \"helloWorld.vss\", then click Add.</p> <p></p> </li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-01.html#write-the-integration-service-code","title":"Write the Integration Service Code","text":"<p>Once you've created the <code>helloWorld.vss</code> file in the editor, you'll notice that it's prepopulated with the necessary skeleton code you need for your Integration Service. This includes adding the USE statements for the necessary VoltScript Middleware VSS (<code>VoltMXObject</code>) and VoltScript Context VSE (<code>ContextVSE</code>) libraries, as well as a template for your Initialize subroutine.</p> <p></p> <p>HOWEVER, the <code>VoltMXObjects</code> VSS library and the <code>ContextVSE</code> and <code>JsonVSE</code> VSE extensions are NOT actually loaded yet - so let's add them to our code.</p>"},{"location":"tutorials/vs-in-foundry/lab-01.html#add-necessary-resources","title":"Add Necessary Resources","text":"<p>Note</p> <p>You will need to have login credentials for the Volt MX Marketplace and for GitHub so that you can access the latest resources.</p> <p>Let's add the VSEs we'll need first.</p>"},{"location":"tutorials/vs-in-foundry/lab-01.html#import-vse-extensions","title":"Import VSE Extensions","text":"<ol> <li> <p>Click on the VSE Files tab in the editor, then click the Import button.</p> <p></p> </li> <li> <p>A login prompt will appear. Enter the credentials you created for the Volt MX Marketplace, then click Login.</p> <p></p> </li> <li> <p>After successfully logging in you're presented with a list of the VSEs available for download. Let's begin by selecting the ContextVSE VoltScript Extension, then click IMPORT.</p> <p></p> </li> <li> <p>Now we need to add the <code>JsonVSE</code> extension. Simply click the Import button again, select the JsonVSE VoltScript Extension, then click IMPORT.</p> <p></p> </li> <li> <p>Now you should have the <code>ContextVSE</code> and <code>JsonVSE</code> files loaded in the VSE Files tab. Notice that it automatically added both the Windows and Linux versions of the respective VSE extensions - this ensures that you will have access to these files no matter what OS the Volt Foundry server is using. These files are referenced in your code by their programmatic names - <code>ContextVSE</code> and <code>JsonVSE</code>.</p> <p></p> </li> </ol> <p>Now that we have the VSE files in our Integration Service, we need to add the necessary VSS as well - <code>VoltMXObjects.vss</code></p>"},{"location":"tutorials/vs-in-foundry/lab-01.html#upload-vss-libraries","title":"Upload VSS Libraries","text":"<ol> <li> <p>We need to upload the <code>VoltMXObjects.vss</code> library, so you'll need to log into GitHub and locate the Volt MX Middleware repository.</p> </li> <li> <p>Once there, locate the <code>Releases</code> area, and click on the Latest release.</p> <p></p> </li> <li> <p>We only need the <code>VoltMXObjects.vss</code> file. Click on the filename to download the file.</p> <p></p> </li> <li> <p>In the Integration Service editor, click on the VSS Files tab. Now select the libs directory, then click the Upload button.</p> <p></p> </li> <li> <p>Select the <code>VoltMXObjects.vss</code> file you downloaded earlier, and click Open to upload it into your Integration Service. Once it's uploaded, you should see the file in the libs directory in your editor.</p> <p></p> </li> <li> <p>We need one more VSS library for our Integration Service - VoltScript Collections. Follow the same steps you used to download <code>VoltMXObjects.vss</code> and download <code>VoltScriptCollections.vss</code>, and upload it to the libs directory. Once you've done so you should see these files in your editor.</p> <p></p> </li> </ol> <p>Now that we've successfully uploaded all of the needed resources, let's add some code to test; but before we continue, let's go ahead and save our Integration Service by click the SAVE ZIP button. You should then see a Successfully updated. status at the bottom of the page.</p> <p></p>"},{"location":"tutorials/vs-in-foundry/lab-01.html#write-your-first-integration-service-code","title":"Write Your First Integration Service Code","text":"<ol> <li> <p>Click on the helloWorld.vss file in your Integration Service editor. You should see the boilerplate code added earlier.</p> <p></p> </li> <li> <p>Between the two comment blocks, enter the following code:</p> <pre><code>Call VoltMxResult.result.insertValue(\"message\", \"Hello World!\")</code></pre> <p></p> </li> <li> <p>Now that we have some code to test, click SAVE &amp; ADD OPERATION at the bottom of the page.</p> <p></p> </li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-01.html#add-an-integration-service-operation","title":"Add An Integration Service Operation","text":"<p>When you click SAVE &amp; ADD OPERATION, it takes you to the Operations List tab where you can add an Operation to test your code.</p> <ol> <li>Set the name to \"helloWorld\".</li> <li>Select \"helloWorld.vss\" as the file.</li> <li> <p>Click ADD OPERATION.</p> <p></p> </li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE button.</p> <p></p> </li> </ol> <p>Warning</p> <p>You need to have an environment set up to test an operation. If you haven't yet configured one, save the operation, follow the steps in Add an Environment, and then come back to the operation to test.</p> <p>Success</p> <p>The Output Result returns:</p> <pre><code>{\n    \"opstatus\": 0,\n    \"message\": \"Hello World!\",\n    \"httpStatusCode\": 0\n}\n</code></pre> <p>Congratulations! You've created your first VoltScript Integration Service.</p>"},{"location":"tutorials/vs-in-foundry/lab-01.html#add-an-environment","title":"Add an Environment","text":"<ol> <li>On the left pane on the Volt Foundry Console, click Environments.</li> <li>On the Environments page, click Add New. The Add a New Environment dialog opens.</li> <li> <p>In the Environment Name text box, enter an environment name.</p> <p>Note</p> <p>Your environment name can only contain letters, numbers, and hyphens (-). A hyphen can't appear at the beginning or at the end of a name. A number can't appear at the beginning of a name. A name should be a minimum of three characters and a maximum of 20 characters long.</p> </li> <li> <p>On the Server tab, enter the URL of your Volt Foundry in the URL text box. The URL format is: <code>&lt;http or https&gt;://&lt;server_host&gt;:&lt;server_port&gt;</code>For example: http://mbaastest30.hcl.net:53504</p> </li> <li>Click Test Connection to verify that the entered URL is correct. If the test is successful, a check mark appears beside the Server tab.</li> <li> <p>Click Save.</p> <p></p> </li> </ol> <p>The code for the lab is available on GitHub.</p>"},{"location":"tutorials/vs-in-foundry/lab-02.html","title":"VoltScript in Foundry Lab 02 - Hello Name Integration Service","text":""},{"location":"tutorials/vs-in-foundry/lab-02.html#duration-15-min","title":"Duration 15 Min","text":""},{"location":"tutorials/vs-in-foundry/lab-02.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to create an Integration Service with an input parameter, validate the input parameter and error or return a JSON object including a message element that says \"Hello\" to the username sent.</p>"},{"location":"tutorials/vs-in-foundry/lab-02.html#prerequisites","title":"Prerequisites","text":"<ul> <li>VoltScript in Foundry - Lab 01 completed.</li> </ul>"},{"location":"tutorials/vs-in-foundry/lab-02.html#steps","title":"Steps","text":"<p>We're going to build off of our work in VoltScript in Foundry - Lab 01 to create a second VSS library using the Foundry VoltScript editor.</p>"},{"location":"tutorials/vs-in-foundry/lab-02.html#create-hellonamevss","title":"Create helloName.vss","text":"<p>Since we've already added the VSS and VSE libraries we need when completing Lab 01 we can begin by creating our new library.</p> <ol> <li>Log into your Volt Foundry server.</li> <li>Open the App you created in Lab 01.</li> <li>Click on the Integration tab.</li> <li>Click on your Integration Service.</li> <li> <p>In the VoltScript Editor area, click on the VSS Files tab, click Add (+), then select Add New File.</p> <p></p> </li> <li> <p>In the Add New File dialog, enter \"helloName.vss\", then click Add.</p> <p></p> </li> <li> <p>in the editor, click on the new <code>helloName.vss</code> file. You should see the VoltScript boilerplate code.</p> </li> <li> <p>Between the two comment blocks, enter the following code:</p> <pre><code>If (VoltMxRequest.getInputParam(\"username\") = \"\") Then\n    Call VoltMxResult.setErrorMessage(\"Please enter username\")\nElse\n    Call VoltMxResult.result.insertValue(\"message\", \"Hello \" &amp; VoltMxRequest.getInputParam(\"username\"))\nEnd If</code></pre> </li> <li> <p>Click the SAVE ZIP button.</p> <p></p> </li> <li> <p>Click on SAVE &amp; ADD OPERATION at the bottom of the screen. When you click SAVE &amp; ADD OPERATION, it takes you to the Operations List tab where you can add an Operation to test your code.</p> </li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-02.html#add-an-integration-service-operation","title":"Add An Integration Service Operation","text":"<ol> <li>Set the name to \"helloName\".</li> <li>Select \"helloName.vss\" as the file.</li> <li> <p>Click ADD OPERATION.</p> <p></p> </li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE button.</p> <p>Success</p> <p>The Output Result shows the following JSON object:</p> <pre><code>{\n    \"ErrorCode\": \"7060\",\n    \"ErrorMessage\": \"Error occurred while processing the VoltScript. Cause Please enter username.\"\n}\n</code></pre> </li> <li> <p>On the Request Input tab of the operation, click + Add Parameter.</p> </li> <li>Set the NAME to \"username\".</li> <li>Set the TEST VALUE to \"John Doe\".</li> <li> <p>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</p> <p></p> <p>Success</p> <p>The output result shows the following JSON object:</p> <pre><code>{\n    \"opstatus\": 0,\n    \"message\": \"Hello John Doe\",\n    \"httpStatusCode\": 0\n}\n</code></pre> </li> </ol> <p>The code for the lab is available on GitHub.</p>"},{"location":"tutorials/vs-in-foundry/lab-03.html","title":"VoltScript in Foundry Lab 03 - Foundry Identity Service and DRAPI Integration Service","text":""},{"location":"tutorials/vs-in-foundry/lab-03.html#duration-40-min","title":"Duration 40 Min","text":""},{"location":"tutorials/vs-in-foundry/lab-03.html#what-you-will-learn","title":"What you will learn","text":"<p>In this lab you will create a VoltScript Integration Service in Volt Foundry. You will use a previously created Identity Service for OAuth token authentication, and you will update documents in a previously populated DRAPI instance.  </p> <p>Note</p> <p>The key difference between VoltScript in this lab and code from [previous labs] is in this lab you will write your Voltscript in Volt Foundry.  No VSCode instance is necessary.</p>"},{"location":"tutorials/vs-in-foundry/lab-03.html#prerequisites","title":"Prerequisites","text":"<ul> <li>This exercise assumes that:<ul> <li>You have completed Writing VoltScript in Volt Foundry labs 01 and 02</li> </ul> </li> </ul>"},{"location":"tutorials/vs-in-foundry/lab-03.html#steps","title":"Steps","text":""},{"location":"tutorials/vs-in-foundry/lab-03.html#configure-an-identity-service","title":"Configure an Identity Service","text":"<ol> <li>Log into Volt Foundry.</li> <li>On the Apps page, create a new Foundry app.</li> <li>On the Identity Services tab, follow the steps to create an Identity Service with access to the scope for \"Demo Companies and Contacts\" database.</li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-03.html#configure-a-new-integration-service","title":"Configure a new Integration Service","text":"<ol> <li> <p>On the Configure Services tab, click Integration tab and then click CONFIGURE NEW.</p> <p></p> </li> <li> <p>Set the Name to <code>vs-in-foundry-drapi</code>.</p> </li> <li>Select \"VoltScript\" for Service Type.</li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-03.html#create-a-new-voltscript-connector-zip","title":"Create a New VoltScript Connector Zip","text":"<ol> <li> <p>Instead of selecting an exisiting or uploading a new VoltScript Connector Zip, click the Create New button.</p> <p></p> </li> <li> <p>Set the Name to \"updatecompany\".</p> </li> <li>Set the Version to \"1.0\", and optionally enter a Description.</li> </ol> <p>Warning</p> <p>The Foundry workspace will not allow you to import a VSE Extension or upload a VSS Library into a new VoltScript Connector Zip until you have saved your <code>main.vss</code> file.</p>"},{"location":"tutorials/vs-in-foundry/lab-03.html#add-the-skeleton-code","title":"Add the Skeleton Code","text":"<ol> <li> <p>On the VSS Files tab, click the Add VSS (+) button, then select Add New File.</p> <p></p> </li> <li> <p>In the Add New File dialog, enter \"main.vss\", then click Add. As with Lab 01, your new vss file should be automatically prepopulated with the necessary skeleton code for your Integration Service.  </p> </li> <li> <p>Click the Save VSS () button to save your <code>main.vss</code> file.</p> <p></p> </li> </ol> <p>Before writing any actual code, you will need to add the necessary resources for this lab.</p>"},{"location":"tutorials/vs-in-foundry/lab-03.html#import-vse-extensions","title":"Import VSE Extensions","text":"<p>Note</p> <p>You will need to have login credentials for the Volt MX Marketplace and for GitHub so that you can access the latest resources.</p> <p>In the same manner as you did for Lab 01, you will need to import VSE files for:</p> <ul> <li>ContextVSE</li> <li>JsonVSE</li> <li>DrapiVSE</li> </ul>"},{"location":"tutorials/vs-in-foundry/lab-03.html#upload-vss-libraries","title":"Upload VSS Libraries","text":"<p>Add the following VSS libraries in the same manner as you did in Lab 01.</p> <ul> <li>VoltMXObjects.vss</li> <li>VoltScriptCollections.vss</li> <li>VoltScriptJsonConverter.vss</li> </ul> <p>Now that we have successfully uploaded all of the needed resources, let's add some code to test; but before we continue, let's go ahead and save our Integration Service by click the SAVE ZIP button. You should then see a Successfully updated. status at the bottom of the page.</p>"},{"location":"tutorials/vs-in-foundry/lab-03.html#write-your-integration-service-code","title":"Write Your Integration Service Code","text":"<ol> <li> <p>On the <code>VSS Files</code> tab, open the <code>src</code> folder on <code>main.vss</code> to open it in the editor.</p> </li> <li> <p>After the Options, add the following directives:</p> <pre><code>UseVSE \"*DrapiVSE\"\nUse \"../libs/VoltScriptJsonConverter\" </code></pre> <p>Why no JsonVSE?</p> <p>You may be wondering why we have not added a <code>UseVSE \"*JsonVSE\"</code> statement, even though we imported the VSE. The reason why is that the VoltScriptJsonConverter.vss library includes <code>Option Public</code> and <code>UseVSE \"*JsonVSE\"</code> directives; which brings the JsonVSE into same scope as <code>main.vss</code>.</p> </li> <li> <p>Add the following declarations at the top of the <code>Sub Initialize</code>:</p> <pre><code>Dim request as DrapiRequest\nDim doc as DrapiDocument\nDim companyPayload as JsonObject\n\nDim parser as New JsonParser()\nDim server as New DrapiServer()\nDim replaceItems as New JsonObject()\n\nDim response as DrapiResponse\nDim newCompanyName As String\nDim oldCompanyName As String\nDim query as String\nDim unid as String</code></pre> </li> <li> <p>Add the following code between the START OF FOUNDRY HANDLER and END OF FOUNDRY HANDLER comment blocks:</p> <pre><code>server.serverURL = VoltMXRequest.getInputParam(\"serverURL\")\nSet request = server.createRequest(\"companiesandcontacts\")\n\nunid = VoltMXRequest.getInputParam(\"unid\")\nnewCompanyName = VoltMXRequest.getInputParam(\"CompanyName\")\n\nSet doc = request.getDocument(unid, \"html\", \"default\")\n\nCall parser.loadFromJson(doc.JsonValue)\nSet companyPayload = parser.getRootObject()\noldCompanyName = companyPayload.getChild(\"Company\").scalarValue\nCall companyPayload.insertValue(\"Company\", newCompanyName)\ndoc.JsonValue = companyPayload.toString(false)\nCall VoltMxResult.result.insertValue(\"companyUpdated\", doc.put(\"default\"))\n\nquery = \"Form = 'Contact' and Company = '\" &amp; oldCompanyName &amp; \"'\"\nCall replaceItems.insertValue(\"Company\", newCompanyName)\nSet response = request.bulkPatchDocuments(query, replaceItems.toString(False), \"html\", \"default\", 5000, True, True)\nCall parser.loadFromJson(response.ContentBody)\nVoltMxResult.httpStatusCode = response.ResponseCode\nCall VoltMxResult.result.insertValue(\"contactsUpdated\", parser.getRootObject())</code></pre> </li> <li> <p>Click the Save VSS () button to save your <code>main.vss</code> file.</p> </li> <li>Click the SAVE ZIP button to save the Zip file.</li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-03.html#get-a-company-universalid","title":"Get a Company UniversalID","text":"<ol> <li>Open the Demo Companies and Contacts database in either your Notes or your Nomad Client, and go to the Contacts\\by Company view.</li> <li>Make a note of a Company that has 1 or more contacts.</li> <li> <p>Switch to the Companies view and find the Company document. Use the Properties dialog to copy the UniversalID of the document.</p> <p></p> </li> <li> <p>Return to your Foundry interface.</p> </li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-03.html#identity-service","title":"Identity Service","text":"<ol> <li>Locate the Identity Service for Backend Token field.</li> <li> <p>Select the Identity Service you created in VoltScript for Foundry - Lab 03</p> <p></p> </li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-03.html#add-an-integration-service-operation","title":"Add An Integration Service Operation","text":"<ol> <li>Click SAVE &amp; ADD OPERATION.</li> <li>Set the name to \"update\".</li> <li>Select \"main.vss\" as the file.</li> <li>Click ADD OPERATION.</li> <li>Scroll down to the Request Input tab and click + Add Parameter.</li> <li>Set the NAME to <code>serverURL</code>.</li> <li> <p>Set the TEST VALUE to your domino server's Domino REST API base url, for example <code>http://localhost:8880/api/v1</code>.</p> <p>Note</p> <p>The URL needs to end with <code>/api/v1</code>.</p> </li> <li> <p>Click + Add Parameter and set the NAME to <code>unid</code>.</p> </li> <li>Set the TEST VALUE to the UniversalID you copied from the Companies and Contacts database.</li> <li>Click + Add Parameter and set the NAME to <code>CompanyName</code>.</li> <li>Set the TEST VALUE to a new value of your choosing.</li> <li>Verify that the ENCODE checkbox for all parameters is checked.</li> <li>Scroll down to the bottom of the operation and click SAVE AND FETCH RESPONSE.</li> <li>On Identity Backed Response tab, click the AUTHORIZE button to begin the OAuth2 dance.</li> <li> <p>You should then be presented with an Authentication Dialog.  You will need to enter the appropriate userid and password for the identity service.</p> <p></p> Failure <p>If your integration service fails you should receive JSON content to help identify the failure.  </p> <p>You can also click the Identity Backend Response - Log tab to view detailed log information about the failure.</p> <p></p> Success <p>The output result shows a JSON object with:</p> <ul> <li><code>httpStatusCode</code> set to 200.</li> <li><code>companyUpdated</code> set to <code>true</code>.</li> <li><code>contactsUpdated</code> containing a JSON object of results for each contact update - UNID, success message, and status details.</li> </ul> </li> </ol>"},{"location":"tutorials/vs-in-foundry/lab-03.html#verify-in-client","title":"Verify in Client","text":"<p>Even though the returned JSON indicates that the operation was successful, you can perform an additional verification:</p> <ol> <li>Open the Demo Companies and Contacts database in either your Notes or your Nomad Client, and go to the Companies view.</li> <li>You should be able to find a document for the new Company Name you provided earlier.</li> <li> <p>If you go to the Contacts\\by Company view, you should be able to find Contact documents for the new Company Name.</p> <p></p> </li> </ol> <p>The code for the lab is available on GitHub.</p> <p>Congratulations</p> <p>You have successfully used a VoltScript Integration Service to update DRAPI content while authenticating using an OAuth2 Token from a Volt Foundry Identity Service.  </p>"},{"location":"tutorials/walkthrough/index.html","title":"Introduction to VoltScript","text":"<p>This workshop is designed to walk through working with VoltScript from creating a simple script to a full project, including unit tests.</p> <ul> <li>Lab 01 creates a simple script to print \"Hello World\".</li> <li>Lab 02 creates a project with recommended structuring and including an external library module.</li> <li>Lab 03a leverages dependency management to build a project that downloads VoltScript Extensions and Library Modules.</li> <li>Lab 03b continues Lab 03a; using VoltScript Extensions to parse raw JSON into objects, followed by writing and using unit tests.</li> <li>Lab 04 demonstrates authenticating with an HCL Domino REST API instance and connecting to a named Scope. (Requires DRAPI instance)</li> <li>Lab 05 uses the <code>VoltScriptJsonConverter</code> Extension to process raw JSON data into JSON document records.  </li> <li>Lab 06 builds on the skills from Lab 04 and Lab 05 in order to create Customer and Contact records in an HCL Domino REST API database. (Requires DRAPI instance)</li> </ul> <p>Note</p> <p>This workshop covers writing code to be run locally, without requirement for a Volt Foundry server or payload.</p>"},{"location":"tutorials/walkthrough/lab-01.html","title":"Lab 01 - VoltScript simple program","text":""},{"location":"tutorials/walkthrough/lab-01.html#duration-10-min","title":"Duration 10 min","text":""},{"location":"tutorials/walkthrough/lab-01.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to use the Visual Studio Code extension to compile and run basic scripts.</p>"},{"location":"tutorials/walkthrough/lab-01.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Visual Studio Code installed.</li> <li>VoltScript runtime and VS Code Extensions installed.</li> </ul>"},{"location":"tutorials/walkthrough/lab-01.html#steps","title":"Steps","text":""},{"location":"tutorials/walkthrough/lab-01.html#the-ide","title":"The IDE","text":"<ol> <li> <p>Create a new VS Code VoltScript Workspace folder called lab-01:</p> <ol> <li>Open Visual Studio Code.</li> <li> <p>From the Explorer view, click Open Folder.</p> <p></p> </li> <li> <p>Create a new folder in your user directory, with the name stated above.</p> </li> <li>Select the newly created folder to open in VS Code.</li> </ol> </li> </ol>"},{"location":"tutorials/walkthrough/lab-01.html#helloworldvss","title":"helloworld.vss","text":"<ol> <li>Click the New File icon above the empty pane for the folder. You can also right-click in the empty pane and select New File from the context menu.</li> <li> <p>Name the file \"helloworld.vss\".</p> <p>Warning</p> <p>A notification might be received \"An error was thrown while processing document\" in the bottom right of VS Code. This is normal. The file has been identified as a VoltScript file, but cannot be parsed by the language support at this time.</p> <p>Info</p> <p>Note the information at the right side in the status bar at the bottom of VS Code. The file is automatically identified as UTF-8, CRLF is used as the line ending, and the language has been identified as \"VoltScript\". To ensure compatibility with Linux, you should change line endings to LF.</p> </li> <li> <p>Type <code>Print \"Hello World\"</code>.</p> <p>Info</p> <p>The language support extension doesn't contribute content assist (typehead) or formatting at this time. However, VoltScript code is compiled as you type. Errors are underlined in red and hovering will provide the compilation error. You can also find them in the Problems view by going to View \u2192 Problems, or pressing Ctrl+Shift+M.</p> </li> <li> <p>Press Ctrl+Shift+P (Cmd+Shift+P on Mac), then select VoltScript: Save &amp; Run Script. (You can start typing \"VoltScript\" to filter the available commands).</p> </li> <li> <p>Press the <code>Enter</code> key to confirm your input (no script arguments are necessary).</p> <p>Success</p> <p>A VoltScript terminal will open in your workspace and display the result of your script. </p> <p>Tip</p> <p>VoltScript code doesn't have to be in a Sub. However, some language features, such as <code>Try...Catch</code> can only be used within a sub or function. A best practice is to start your code within a <code>Sub Initialize</code> method; as LotusScript developers will be familiar with that pattern.  In order to keep this lab as simple as possible that pattern was intentionally not followed.  </p> <p>Options settings can also used, such as <code>Option Declare</code> or <code>Option Public</code>.  Unfortunately at this time Visual Studio Code cannot be configure to add these automatically. </p> </li> </ol>"},{"location":"tutorials/walkthrough/lab-01.html#how-to-check","title":"How to check","text":"<p>Print to console:</p> <pre><code>[xxxxxx lab-01]$ VoltScript \"/workspaces/lab-01/helloworld.vss\"\nHello World\n[xxxxxx lab-01]$ \n</code></pre> <p>The completed lab is available on GitHub.</p>"},{"location":"tutorials/walkthrough/lab-01.html#things-to-explore","title":"Things to explore","text":"<ul> <li>Put your code in <code>Sub Initialize</code> and run it.</li> <li>Add Option settings.</li> <li>Try alternate string delimiters <code>{}</code> and <code>||</code>. Note syntax highlighting is as expected.</li> <li>Try other language functions. <code>MsgBox</code> has become an alias to <code>Print</code>. As there is no UI and as VoltScript is intended for server-side processing only, so <code>MsgBox</code> makes no sense. Similarly, <code>InputBox()</code> is unsupported.</li> </ul>"},{"location":"tutorials/walkthrough/lab-01.html#next-step","title":"Next step","text":"<p>Proceed to Lab 02 - VoltScript Project with VoltScript Library Module.</p>"},{"location":"tutorials/walkthrough/lab-02.html","title":"Lab 02 - VoltScript Project with VoltScript Library Module","text":""},{"location":"tutorials/walkthrough/lab-02.html#duration-15-min","title":"Duration 15 min","text":""},{"location":"tutorials/walkthrough/lab-02.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to use <code>atlas.json</code> and structure a VoltScript project. You'll also learn how to integrate external library modules with a <code>Use</code> statement.</p>"},{"location":"tutorials/walkthrough/lab-02.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 01 completed</li> </ul>"},{"location":"tutorials/walkthrough/lab-02.html#steps","title":"Steps","text":""},{"location":"tutorials/walkthrough/lab-02.html#the-ide","title":"The IDE","text":"<ol> <li> <p>Create a new VS Code VoltScript Workspace folder called lab-02.</p> <ol> <li>Open Visual Studio Code.</li> <li> <p>From the Explorer view, click Open Folder.</p> <p></p> </li> <li> <p>Create a new folder in your user directory, with the name stated above.</p> </li> <li>Select the newly created folder to open in VS Code.</li> </ol> </li> </ol>"},{"location":"tutorials/walkthrough/lab-02.html#atlasjson","title":"atlas.json","text":"<ol> <li> <p>Create a new <code>atlas.json</code> file:</p> <p>Note</p> <p>The atlas.json file is the VoltScript equivalent of Node.js's <code>package.json</code>, Maven's <code>pom.xml</code> or Rust's <code>cargo.toml</code>. It defines metadata about your project (name, version, authors, license), dependencies, structure, and scripts.</p> <ol> <li>Right-click in the empty pane and select New File from the context menu.</li> <li>Name the file <code>atlas.json</code>.</li> <li>Type an opening curly brace \"{\" and press enter. VS Code automatically adds the closing curly brace \"}\".</li> <li> <p>If the PROBLEMS view isn't visible, select View \u2192 Problems. Note the validation errors, which will identify any required properties which are missing.</p> <p></p> </li> </ol> </li> <li> <p>Set name to \"lab02\".</p> </li> <li>Set version to \"1.0.0\".</li> <li>Set description to \"Lab Number 2\".</li> <li>Add the authors array. Add an array element with your name.</li> <li>Set sourceDir as \"src\". Set mainScripts as <code>main.vss</code>.</li> <li>Use content assist (Ctrl + space) to see other elements that can be added.</li> <li>Set libsDir as \"libs\".</li> <li>Save the <code>atlas.json</code>.</li> </ol> <p></p>"},{"location":"tutorials/walkthrough/lab-02.html#libs-directory","title":"libs directory","text":"<p>Note</p> <p>In the same way that you can create Script Libraries and use them in Domino Designer with the <code>Use</code> instruction, the same can be done in VoltScript. The terminology used to refer to these is \"VoltScript Library Module\".</p> <ol> <li>Right-click in the empty pane and select New Folder from the context menu. Name the directory \"src\".</li> <li>Right-click in the empty pane and select New Folder from the context menu. Name the directory \"libs\".</li> <li>Right-click the \"libs\" directory and select New File from the context menu. Name the file \"Lab2Functions.vss\".</li> <li>In the <code>.vss</code> file, add <code>Option Declare</code> and <code>Option Public</code>.</li> <li> <p>Type Sub. Snippets will offer you \"Sub...\". Press Enter to select the snippet. The following code will be inserted.</p> <pre><code>Sub ProcedureName(ParameterList)\n\nEnd Sub</code></pre> </li> <li> <p><code>ProcedureName</code> is selected. Rename the sub \"PrintMessage\" and press tab to move to the next variable.</p> </li> <li><code>ParameterList</code> is selected. Overtype it with <code>message as String</code>.</li> <li>Move down to the body of the sub, and type <code>Print message</code>.</li> <li>Move out of the sub, type \"fun\", and select the \"Function...\" snippet by pressing Enter.</li> <li><code>FunctionName</code> is selected. Rename the function \"Square\". Press tab to move to the next variable.</li> <li><code>ParameterList</code> is selected. Overtype it with <code>value as Integer</code>.</li> <li><code>ReturnType</code> is selected. Overtype it with <code>Integer</code>. Only the first instance of this will be replaced and a compilation error will remain \"Variable not declared RETURNVALUE\".</li> <li> <p>On the first line of the function, type <code>value *= value</code>.</p> <p>Tip</p> <p>Additional mathematical assignment operators have been added to the VoltScript language. In addition to the obvious <code>++</code> and <code>--</code> options, <code>+=</code>, <code>-=</code>, <code>*=</code> and <code>/=</code> (with its alias <code>\\=</code>) have also been added.</p> </li> <li> <p>Amend the last line of the function to <code>Square = value</code>.</p> </li> <li>Save the file.</li> </ol>"},{"location":"tutorials/walkthrough/lab-02.html#main-script","title":"Main script","text":"<ol> <li>Right-click the \"src\" directory and select New File from the context menu. Name the file <code>main.vss</code>.</li> <li>In the <code>.vss</code> file, add <code>Option Declare</code> and <code>Option Public</code>.</li> <li> <p>Add the statement <code>Use \"../libs/Lab2Functions\"</code>.  </p> <p>Warning</p> <p>VS Code might try to help you out here by providing typeahead here.  If so, be sure to remove the <code>.vss</code> from the end of the library name! </p> <p>Note</p> <p>We can use relative paths in the <code>Use</code> statement. Using forward slashes make the <code>Use</code> statements cross-platform. Paths to Library Modules and downstream Library Modules (modules used in other Library Modules) need to work from any script opened. So all Library Modules should be at the same level of the hierarchy.</p> </li> <li> <p>Add a <code>Sub Initialize</code>.</p> </li> <li>Add <code>Call PrintMessage(\"Hello World\")</code>.</li> <li>Add <code>Call PrintMessage(\"4 x 4 = \" &amp; Square(4))</code>.</li> <li>Press Ctrl+Shift+P (Cmd+Shift+P on Mac), then select VoltScript: Save &amp; Run Script. (You can start typing \"VoltScript\" to filter the available commands).</li> <li> <p>Press the <code>Enter</code> key to confirm your input (no script arguments are necessary).</p> <p>Success</p> <p>A VoltScript terminal will open in your workspace and display the result of your script. </p> </li> </ol>"},{"location":"tutorials/walkthrough/lab-02.html#how-to-check","title":"How to check","text":"<p>Print to console:</p> <pre><code>Hello World\n4 x 4 = 16\n</code></pre> <p>The completed lab is available on GitHub.</p>"},{"location":"tutorials/walkthrough/lab-02.html#things-to-explore","title":"Things to explore","text":"<ul> <li> <p>Change the content of the Square() function to <code>Return value * value</code>.</p> <p>Note</p> <p>The Return keyword is used to immediately cease operations and exit a method (Sub, Function or Property).  It the method is a Function or Property Get, the Return keyword will also return the subsequent value to the calling code.</p> </li> <li> <p>Test downstream VoltScript Library Modules (one module that uses another).</p> </li> <li>Test to understand how relative paths need to work from all levels of the hierarchy.</li> </ul>"},{"location":"tutorials/walkthrough/lab-02.html#next-step","title":"Next step","text":"<p>Proceed to Lab 03a - Using VoltScript Dependency Management for VSEs and VSS Libraries.</p>"},{"location":"tutorials/walkthrough/lab-03a.html","title":"Lab 03a - Using VoltScript Dependency Management for VSEs and VSS Libraries","text":""},{"location":"tutorials/walkthrough/lab-03a.html#duration-20-min","title":"Duration 20 min","text":""},{"location":"tutorials/walkthrough/lab-03a.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to use dependency management, how it creates a <code>seti.ini</code>, and how to use <code>UseVSE</code> to include the VoltScript Extensions.</p>"},{"location":"tutorials/walkthrough/lab-03a.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 02 completed</li> </ul>"},{"location":"tutorials/walkthrough/lab-03a.html#steps","title":"Steps","text":""},{"location":"tutorials/walkthrough/lab-03a.html#the-ide","title":"The IDE","text":"<ol> <li> <p>Create a new VS Code VoltScript Workspace folder called lab-03.</p> <ol> <li>Open Visual Studio Code.</li> <li> <p>From the Explorer view, click Open Folder.</p> <p></p> </li> <li> <p>Create a new folder in your user directory, with the name stated above.</p> </li> <li>Select the newly created folder to open in VS Code.</li> </ol> </li> </ol>"},{"location":"tutorials/walkthrough/lab-03a.html#atlasjson","title":"atlas.json","text":"<ol> <li> <p>Create a new <code>atlas.json</code> file:</p> <p>Note</p> <p>The atlas.json file is the VoltScript equivalent of Node.js's <code>package.json</code>, Maven's <code>pom.xml</code> or Rust's <code>cargo.toml</code>. It defines metadata about your project (name, version, authors, license), dependencies, structure, and scripts.</p> <ol> <li>Right-click in the empty pane and select New File from the context menu.</li> <li>Name the file <code>atlas.json</code>.</li> <li>Type an opening curly brace \"{\" and press enter. VS Code automatically adds the closing curly brace \"}\".</li> <li> <p>If the PROBLEMS view isn't visible, select View \u2192 Problems. Note the validation errors, which will identify any required properties which are missing.</p> <p></p> </li> </ol> </li> <li> <p>Set name to \"lab03\".</p> </li> <li>Set version to \"1.0.0\".</li> <li>Set description to \"Lab Number 3\".</li> <li>Add the authors array. Add an array element with your name.</li> <li>Set sourceDir as \"src\".</li> <li>Set testDir as \"test\".</li> <li>Set mainScripts as \"main.vss\".</li> <li>Set libsDir as \"libs\".</li> <li>Set vsesDir as \"vses\".</li> <li>Add repositories array.<ol> <li>Add a JSON object. Required properties for it will appear in the Problems view.</li> <li>Set id to \"volt-mx-marketplace\".</li> <li>Set type to \"marketplace\".</li> <li>Set url to \"https://community.demo-hclvoltmx.com/marketplace\".</li> <li>Add another JSON object. Required properties for it will appear in the Problems view.</li> <li>Set id to \"hcl-github\".</li> <li>Set type to \"github\".</li> <li>Set url to \"https://api.github.com/repos/hcl-tech-software\".</li> </ol> </li> <li>Add dependencies array. Add a JSON object. Required properties for it will appear in the Problems view.<ol> <li>Set library to \"voltscript-testing\".</li> <li>Set version to \"1.0.1\".</li> <li>Set module to \"VoltScriptTesting.vss\".</li> <li>Set repository to \"hcl-github\".</li> </ol> </li> <li>Add another JSON object to the dependencies array.<ol> <li>Set library to \"voltscript-json-converter\".</li> <li>Set version to \"latest\".</li> <li>Set module to \"VoltScriptJsonConverter.vss\".</li> <li>Set repository to \"hcl-github\".</li> </ol> </li> <li>Add vseDependencies object. This is an object, because each element needs a label that will be used in the <code>UseVSE</code> statement.</li> <li>Add a label \"StreamVSE\". For the value, then add an empty JSON object.<ol> <li>Set library to \"StreamVSE VoltScript Extension\".</li> <li>Set version to \"1.0.4\".</li> <li>Set module to \"streamvse\".</li> <li>Set repository to \"volt-mx-marketplace\".</li> </ol> </li> <li>Save the atlas.json. The final atlas.json should look like this:</li> </ol> <pre><code>{\n    \"name\": \"lab03\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Lab Number 3\",\n    \"authors\": [\"YOUR_NAME\"],\n    \"sourceDir\": \"src\",\n    \"testDir\": \"test\",\n    \"mainScripts\": [\n        \"main.vss\"\n    ],\n    \"libsDir\": \"libs\",\n    \"vsesDir\": \"vses\", \n    \"repositories\": [\n        {\n            \"id\": \"volt-mx-marketplace\",\n            \"type\": \"marketplace\",\n            \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n        },\n        {\n            \"id\": \"hcl-github\",\n            \"type\": \"github\",\n            \"url\": \"https://api.github.com/repos/hcl-tech-software\"\n        }\n    ], \n    \"dependencies\": [\n        {\n            \"library\": \"voltscript-testing\",\n            \"version\": \"1.0.1\",\n            \"module\": \"VoltScriptTesting.vss\",\n            \"repository\": \"hcl-github\"\n        },\n        {\n            \"library\": \"voltscript-json-converter\",\n            \"version\": \"latest\",\n            \"module\": \"VoltScriptJsonConverter.vss\",\n            \"repository\": \"hcl-github\"\n        }\n    ], \n    \"vseDependencies\": {\n        \"StreamVSE\": {\n            \"library\": \"StreamVSE VoltScript Extension\",\n            \"version\": \"1.0.4\",\n            \"module\": \"streamvse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n    }\n}\n</code></pre> <p>Info</p> <p>VoltScript dependencies are, as with other dependency management systems, downloaded into a local repository in your user directory.  For Maven, it is <code>.m2</code>, for Rust, it is <code>.cargo</code>, and for VoltScript, it is .vss. This allows dependencies to be built from local artifacts whenever possible, rather than pulling from remote locations. You can restrict which platform's VSE files get built into your product by using the <code>runtimePlatforms</code> element in atlas.json. For more details, see How to Structure an atlas.json.</p> <ol> <li>From the Command Palette in VS Code, run \"VoltScript: Run Dependency Setup\". This will ensure that (among other things) a .vss folder is created within your VoltScript workspace.  </li> </ol>"},{"location":"tutorials/walkthrough/lab-03a.html#atlas-settingsjson","title":"atlas-settings.json","text":"<p>Within the <code>.vss</code> directory, an <code>atlas-settings.json</code> file holds a single JSON object containing other JSON objects, whose labels match the repositories listed in the <code>atlas.json</code> file. Each of these objects specify the type and necessary authentication credentials for the repository.</p> <ul> <li>For github types, this is a Personal Access Token.  </li> <li> <p>For webserver types, there are two options:</p> <ul> <li>Unauthenticated / Open Web Servers: the credentials should be an empty string.  </li> <li>Authenticated / Controlled Access : the credentials should be a Base64 encoded username and password.  </li> </ul> </li> <li> <p>For marketplace types, this is a username and password.  </p> </li> </ul> <p>Info</p> <p>While this authentication information can be hard-coded directly into the <code>atlas-settings.json</code> file, VoltScipt Dependency Manager respects security concerns about having this hard-coded information accessible.  Therefore, if this information is stored in the format of \"${env.FOO}\", the VoltScript Dependency Manager will retrieve the information from the appropriate environment variable (for this example \"FOO\").  </p> <p>Warning</p> <p>There is no intention to support retrieving credentials from credential stores.</p> <ol> <li> <p>Create a text file called <code>atlas-settings.json</code> in your <code>.vss</code> directory:</p> <p>Note</p> <p>WINDOWS ONLY</p> <ol> <li>In Windows Explorer or a terminal, navigate to your user directory and open the <code>.vss</code> directory.  </li> <li>Select File &gt; New File... from the VS Code Menu, and give it the name <code>atlas-settings.json</code>.  The new file should open in your VS Code editor.</li> </ol> <p>Mac / Linux Dev Container ONLY </p> <ol> <li>From the VS Code Terminal (if necessary, open one by selecting Terminal &gt; New Terminal from the VS Code Menu), type in the command: <pre><code>touch ~/.vss/atlas-settings.json\n</code></pre></li> <li>Select File &gt; Open... from the VS Code Menu, type: <pre><code>~/.vss/atlas-settings.json\n</code></pre>  then click the OK button.</li> </ol> </li> <li> <p>After the file opens in your VS Code editor, create an empty JSON object.</p> <p>Info</p> <p>Unlike the <code>atlas.json</code>, you will not immediately get content assistance.  The <code>atlas-settings.json</code> file defines a a JSON object which contains JSON objects for each repository, each with a label. So you will need to add a label whose value is a JSON object, and that JSON object will provide content assistance. Alternatively, there are snippets available by typing <code>atlas-settings</code> which will generate JSON objects with all possible options.</p> </li> <li> <p>Add a label \"hcl-github\". For its value, create a JSON object. Required properties for it will appear in the Problems view.</p> </li> <li>Set type to \"github\".</li> <li> <p>Set token to your GitHub Personal Access Token.</p> <p>If you don't have one yet, follow GitHub's documentation for creating a GitHub Personal Access Token. The value will begin \"ghp_\". For more details see how-to guide.</p> </li> <li> <p>Create another JSON object with the label of \"volt-mx-marketplace\".</p> </li> <li>Set type to \"marketplace\".</li> <li>Set authUrl to \"https://accounts.auth.demo-hclvoltmx.net/login\".</li> <li> <p>Set username and password to your credentials for Volt MX Marketplace.</p> <p>You can create an account or check your login credentials at Volt MX Marketplace. If you are creating a new account, make sure to successfully log in to activate the account before using the credentials in dependency management.</p> <p>A sample atlas-settings file sould look something like this:</p> <pre><code>{\n    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    },\n    \"my-web-server\": {\n        \"type\": \"webserver\",\n        \"credentials\": \"${env.CRED}\"\n    },\n    \"volt-mx-marketplace\": {\n        \"type\": \"marketplace\",\n        \"username\": \"${env.USERNAME}\",\n        \"password\": \"${env.PASSWORD}\",\n        \"authUrl\": \"https://accounts.auth.demo-hclvoltmx.net/login\"\n    }\n}\n</code></pre> </li> <li> <p>Save your atlas-settings.json file.</p> </li> </ol>"},{"location":"tutorials/walkthrough/lab-03a.html#voltscript-dependency-manager","title":"VoltScript Dependency Manager","text":"<p>Info</p> <p>VoltScript Dependency Manager can use any of three repository types, as defined in the atlas-settings.json file.  These types are:  </p> <ul> <li>github A GitHub repository requires a Personal Access Token, associated with the \"token\" element from the atlas-settings object.   </li> <li>webserver A Web Server repository requires Base64 encoded credentials, which are specified in the credentials element.</li> <li>marketplace A specialized form of Web Server repository, the Marketplace is for a (usually a Volt-MX Marketplace) website that accepts a username and password.  These values are passed after a secure SSL connection is made with the remote site defined in the authURL element.  </li> </ul> <p>The VoltScript Dependency Manager requires 4 pieces of information:</p> <ul> <li>The folder for the project (your workspace folder)</li> <li>The location of the atlas.json file, from which to build the dependencies.</li> <li>The location of the atlas-settings.json file, from which to get the necessary authentication information for any repositories defined in atlas.json.</li> <li>A boolean instruction to force reload from remote repositories in the event that local resources already exist.</li> </ul> <p>Tip</p> <p>When you run the VoltScript Dependency Manager, it will ask you for this information one at a time, and will preload the default answer for subsequent questions using the information from your answers.  If you do not answer quickly enough, it will timeout and proceed to the next question.  Therefore it is a good idea to copy your VoltScript workspace filepath to your clipboard (the first question) before proceeding.  </p> <p></p> <ol> <li> <p>From the Command Palette, run \"VoltScript: Install Dependencies\".  </p> <p>This will invoke VoltScript executable and instruct it to run the VoltScript Dependency Manager (archipelago.vss).  Answer the questions one at a time (or just press Enter to accept the default) to proceed.  </p> <p>The VoltScript Dependency Manager will (depending upon your connection speed) take a few moments to complete operations.  If any problems occur they will be listed in the VS Code terminal window.  Nearly All problems that occur are due to either entering the directory incorrectly when prompted, or invalid / incomplete information in the atlas.json file.  It is very common to make a mistake here, methodically check your JSON and VoltScript Workspace folder hierarchy if you have problems.  </p> </li> </ol> <p>Success</p> <p>Assuming the VoltScript Dependency Manager runs to completion, your project should now have \"src\", \"test\", \"libs\" and \"vses\" directories.</p> <ul> <li>The src directory will normally be empty.</li> <li>The test directory will normally empty.</li> <li>The libs directory should now be populated with <code>VoltScriptTesting.vss</code> and <code>VoltScriptJsonConverter.vss</code>.</li> <li>The vses directory should now be populated with dll and so files for StreamVSE and JsonVSE.  JsonVSE is a downstream dependency used by VoltScript JSON Converter, and is automatically picked up because it is listed in the atlas.json for VoltScript JSON Converter.</li> <li>A new file, <code>seti.ini</code>, has been created. This contains mappings for the VoltScript Extensions (VSEs) and will be used when processing <code>UseVSE</code> statements.</li> <li>A new file, <code>effective-atlas.json</code>, has been added to the root of the directory. This contains the aggregated settings for the project.</li> </ul> <p></p> <p>Proceed to Lab 03b - Using a VoltScript Extension to parse JSON</p>"},{"location":"tutorials/walkthrough/lab-03b.html","title":"Lab 03b - Using a VoltScript Extension to parse JSON","text":""},{"location":"tutorials/walkthrough/lab-03b.html#duration-20-min","title":"Duration 20 min","text":""},{"location":"tutorials/walkthrough/lab-03b.html#what-you-will-learn","title":"What you will learn","text":"<p>You'll learn how to do basic JSON parsing using the <code>JsonVSE</code> VoltScript Extension.</p>"},{"location":"tutorials/walkthrough/lab-03b.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 03a completed</li> </ul>"},{"location":"tutorials/walkthrough/lab-03b.html#steps","title":"Steps","text":""},{"location":"tutorials/walkthrough/lab-03b.html#simple-script","title":"Simple Script","text":"<ol> <li>Download functions.vss and save it to the libs folder.  </li> <li>Download main.vss and save it to the src folder.</li> <li> <p>Open src/main.vss and review the script.</p> <ul> <li>The script starts and then reads the first line of text from command line input using StreamVSE and a new Stream (<code>pipeStream</code>).</li> <li>It then tries to convert the data to JSON using JsonVSE (<code>jsonParser</code>).</li> <li>It then tries to convert the JSON to a Variant array of Person objects using VoltScriptJsonConverter (<code>JsonConversionHelper</code>).</li> <li>It then builds a response JSON object using the Person class's <code>getName()</code> function and pretty-prints the output.</li> <li>If an error occurs, it is printed to the console and (in the finally block) the stream is closed.</li> </ul> </li> </ol> <p>Troubleshooting</p> <p>There is a known and as yet to be resolved timing issue with Streams in VoltScript and Standard Input/Output (STDIO) when running in a linux dev container. The processing happens so fast that the I/O will close before buffered content (Print Statements) have completely cleared.  The net effect of this is that Printed output is simply lost. Fortunately there is a relatively simple work-around.  Simply add a Sleep(1) statement to your code after the stream reads content (in this case, <code>data = pipeStream.readText(true, EOL_ANY, 5)</code>).  This will cause the VoltScript executable to pause processing for 1 second; giving the buffer time to clear, allowing subsequent <code>Print</code> statements to operate as expected. </p> <ol> <li> <p>Copy the following JSON content to your clipboard.</p> <pre><code>[{\"id\":1,\"firstName\":\"Bobby\",\"lastName\":\"Stodd\",\"email\":\"bstodd0@ibm.com\",\"gender\":\"Male\"},{\"id\":2,\"firstName\":\"Leeanne\",\"lastName\":\"Mortimer\",\"email\":\"lmortimer1@posterous.com\",\"gender\":\"Female\"},{\"id\":3,\"firstName\":\"Rochette\",\"lastName\":\"Santora\",\"email\":\"rsantora2@unc.edu\",\"gender\":\"Female\"},{\"id\":4,\"firstName\":\"Missy\",\"lastName\":\"Prestedge\",\"email\":\"mprestedge3@nih.gov\",\"gender\":\"Female\"},{\"id\":5,\"firstName\":\"Cleavland\",\"lastName\":\"Lortzing\",\"email\":\"clortzing4@gov.uk\",\"gender\":\"Male\"}]\n</code></pre> </li> <li> <p>Return focus to the main.vss file in your VS Code editor.</p> </li> <li>Press Ctrl+Shift+P (Cmd+Shift+P on Mac), then select VoltScript: Save &amp; Run Script. (You can start typing \"VoltScript\" to filter the available commands).</li> <li> <p>Press the <code>Enter</code> key to confirm your input (no script arguments are necessary).</p> </li> <li> <p>Paste the JSON from clipboard into the paused VoltScript terminal window and press Enter to pass the string into the script. The file is at sampleJson.</p> </li> </ol> <p>Success</p> <p>You have successfully read in a complex JSON array from the command line, converted it to an array of VoltScript objects with two lines of code, and manipulated the data for a response.</p>"},{"location":"tutorials/walkthrough/lab-03b.html#review","title":"Review","text":"<p>This gives you an idea of a day in the life of a Volt MX Go VoltScript developer. You will use VoltScript Dependency Manager to avoid having to copy and paste dependencies around. You will be writing middleware functions, which will receive input from an Iris app, including parameters and query string information. It will then need to act upon that data, potentially retrieving data from a remote database, and return a JSON response for the Iris app.</p> <p>In the things to explore, you can change the function so it can be unit tested. Apart from input, there is no external integration, so integration tests are irrelevant. These tests will allow you to prevent regression bugs. The same process can be used to check output for dummy input from the IDE, without running from command line.</p> <p>The code for the lab is available on GitHub.</p>"},{"location":"tutorials/walkthrough/lab-03b.html#content-assist","title":"Content Assist","text":"<p>Content assist is available for both <code>atlas.json</code> and <code>atlas-settings.json</code>. To explore this, create a new <code>atlas.json</code> or <code>atlas-settings.json</code> file, and in the editor simply start typing the word 'atlas'.   A content-assist dialog will appear, from which you can click on the appropriate content you wish.  Doing so will auto-populate your new file with default content.  </p> <p></p>"},{"location":"tutorials/walkthrough/lab-03b.html#things-to-explore","title":"Things to explore","text":""},{"location":"tutorials/walkthrough/lab-03b.html#unit-tests","title":"Unit Tests","text":"<ol> <li>Create a new file in test called <code>unitTests.vss</code>.</li> <li> <p>Paste in the following code:</p> <pre><code>    Option Declare\n    Option Public\n\n    UseVSE \"*JsonVSE\"\n    Use \"../libs/VoltScriptTesting\"\n    Use \"../libs/functions\"\n\n    Sub Initialize\n        Dim testSuite as New TestSuite(\"Unit Tests\")\n        Dim data as String\n        Dim response as JsonObject\n        Dim children as Variant\n\n        data = |[{\"id\":1,\"firstName\":\"Bobby\",\"lastName\":\"Stodd\",\"email\":\"bstodd0@ibm.com\",\"gender\":\"Male\"},{\"id\":2,\"firstName\":\"Leeanne\",\"lastName\":\"Mortimer\",\"email\":\"lmortimer1@posterous.com\",\"gender\":\"Female\"},{\"id\":3,\"firstName\":\"Rochette\",\"lastName\":\"Santora\",\"email\":\"rsantora2@unc.edu\",\"gender\":\"Female\"},{\"id\":4,\"firstName\":\"Missy\",\"lastName\":\"Prestedge\",\"email\":\"mprestedge3@nih.gov\",\"gender\":\"Female\"},{\"id\":5,\"firstName\":\"Cleavland\",\"lastName\":\"Lortzing\",\"email\":\"clortzing4@gov.uk\",\"gender\":\"Male\"}]|\n        Set response = mainFunction(data)\n        Call testSuite.describe(\"Check five elements returned\").assertEqualsInteger(5, response.childCount)\n        children = response.getChildren()\n        Call testSuite.describe(\"Check first element has name\").assertTrue(children(0).IsChild(\"name\"))\n        Call testSuite.describe(\"Check first name is Bobby Stood\").assertEqualsString(\"Bobby Stood\",_\n            children(0).getChild(\"name\").scalarValue, True)\n    End Sub</code></pre> </li> <li> <p>Press Ctrl+Shift+P (Cmd+Shift+P on Mac), then select VoltScript: Save &amp; Run Script. (You can start typing \"VoltScript\" to filter the available commands).</p> </li> <li> <p>Press the <code>Enter</code> key to confirm your input (no script arguments are necessary).</p> </li> <li> <p>Information on the test run will be printed to the Output view, showing that 3 tests ran, one of which failed.</p> </li> <li>A \"unit-test-reports\" directory will be added, and a file will be created. Right-click and select Reveal in File Explorer.</li> <li>Right-click the file and open in a browser.</li> <li>Click on the failing test and diagnose the problem. The test is checking for \"Stood\", but the correct value is \"Stodd\".</li> <li>Change the assertion and don't forget to also change the test description.</li> <li>Run the tests again.</li> </ol> <p>Success</p> <p>The tests should now run successfully.</p>"},{"location":"tutorials/walkthrough/lab-03b.html#other-things-to-explore","title":"Other things to explore","text":"<ul> <li>Investigate content assist for <code>atlas.json</code> and <code>effective-atlas.json</code>.</li> <li>Review what's printed to output for VoltScript Dependency Manager.</li> <li> <p>Look at the <code>effective-atlas.json</code> and understand the structure.</p> </li> <li> <p>Consider how the VoltScript Dependency Manager might impact community involvement. What do you think needs to be included in source control repositories?</p> </li> <li>Consider how the VoltScript Dependency Manager might be used in a CI/CD environment. What do you think should be included / excluded from your source control repositories?</li> <li>Review the <code>seti.ini</code>. Review the use of relative paths. Identify how module is adapted to the actual filename expected.</li> </ul> <p>Note</p> <p>VoltScript Extensions for all operating systems will be added to the relevant directory in your project, ready for deployment on any operating system!</p>"},{"location":"tutorials/walkthrough/lab-04.html","title":"Lab 04 - Reading from a DRAPI Request","text":""},{"location":"tutorials/walkthrough/lab-04.html#duration-30-min","title":"Duration 30 min","text":""},{"location":"tutorials/walkthrough/lab-04.html#what-you-will-learn","title":"What you will learn","text":"<p>You will learn how to connect to an HCL Domino REST API Scope and pull information from a view using VoltScript Code and DrapiVSE.  </p>"},{"location":"tutorials/walkthrough/lab-04.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 03b completed</li> <li>Familiarity with creating a Domino Database from a Template</li> <li>Familiarity with creating a Scope and Schema in the HCL Domino REST API</li> </ul>"},{"location":"tutorials/walkthrough/lab-04.html#steps","title":"Steps","text":""},{"location":"tutorials/walkthrough/lab-04.html#drapi-setup","title":"DRAPI SETUP","text":"<ol> <li>Download the Demo Companies and Contacts Template and save it locally.  </li> <li>Create a New Database instance from the template on the HCL Domino server upon which your HCL Domino REST API is installed, and set the ACL appropriately for your DRAPI instance.  </li> <li>Create a Scope called <code>companiesandcontacts</code>, and associate it with the <code>demo_companies_and_contacts</code> Schema in your newly created database.</li> </ol>"},{"location":"tutorials/walkthrough/lab-04.html#the-ide","title":"The IDE","text":"<ol> <li> <p>Create a new VS Code VoltScript Workspace folder called lab-04.</p> <ol> <li>Open Visual Studio Code.</li> <li> <p>From the Explorer view, click Open Folder.</p> <p></p> </li> <li> <p>Create a new folder in your user directory, with the name stated above.</p> </li> <li>Select the newly created folder to open in VS Code.</li> </ol> </li> </ol>"},{"location":"tutorials/walkthrough/lab-04.html#atlasjson","title":"atlas.json","text":"<ol> <li>Download the atlas.json and save it to your <code>lab-04</code> folder.  </li> <li>Modify <code>atlas.json</code> value for <code>authors</code> appropriately and save it.</li> <li>Run VoltScript Dependency Setup and create your <code>atlas-settings.json</code> file as you did in Lab 03a</li> <li>From the Command Palette, run <code>VoltScript: Install Dependencies</code>.  </li> </ol>"},{"location":"tutorials/walkthrough/lab-04.html#voltscript-code","title":"VOLTSCRIPT CODE","text":"<ol> <li>Download main.vss and save it to the src folder.</li> <li>Open src/main.vss and modify the script.<ul> <li>Set the values for the constants <code>DRAPI_URL</code>, <code>USER_NAME</code>, and <code>USER_PASSWORD</code> to the appropriate values for your environment. Ensure that the /api/v1 suffix remains for <code>DRAPI_URL</code>.  </li> </ul> </li> <li> <p>As you review the script, you will find the DrapiVSE Documentation to be a useful reference.</p> <ul> <li>The script instantiates a new <code>DrapiServer</code> object, and then sets the <code>serverUrl</code> property.  </li> <li>It then logs into the server using the appropriate credentials, and then prints the user's information to the console.  </li> <li>The script then gets the appropriate <code>DrapiRequest</code> from the <code>DrapiServer</code> object, and prints out information about all of the views.  It is important to note here that information returned by the <code>getLists</code> method is restricted to only the <code>Active Views</code> you configured during the DRAPI SETUP portion of this lab.  </li> <li>The script then prints out all of the entries in the <code>contactsByCompany</code> view; which at this point should be an empty array (no entries).</li> </ul> </li> <li> <p>Return focus to the main.vss file in your VS Code editor.</p> </li> <li>Press Ctrl+Shift+P (Cmd+Shift+P on Mac), then select VoltScript: Save &amp; Run Script. (You can start typing \"VoltScript\" to filter the available commands).</li> <li>Press the <code>Enter</code> key to confirm your input (no script arguments are necessary).</li> </ol> <p>Success</p> <p>You have successfully connected to an HCL Domino REST API Instance, passed authentication, and queried information from a specific Scope and printed it out to the console -all with just a few lines of VoltScript Code.  </p>"},{"location":"tutorials/walkthrough/lab-04.html#review","title":"Review","text":"<p>This gives you an idea of a day in the life of a VoltScript developer. You will use VoltScript Dependency Manager to avoid having to copy and paste dependencies around. You can retrieve data from a remote data store using various VoltScript Extensions, and retrieve information from them.</p> <p>The code for the lab is available on GitHub.</p>"},{"location":"tutorials/walkthrough/lab-04.html#looking-forward","title":"Looking Forward","text":"<p>In Lab 05, you will learn to use the VoltScriptJsonConverter to process raw JSON data into JSON document records.  </p> <p>In Lab 06, you will use the JSON document records to add Customer and Contact records to your database.  This will provide you with populated content for use with a Volt Foundry Integration Service you will create in a later lab.  </p>"},{"location":"tutorials/walkthrough/lab-05.html","title":"Lab 05 - VoltScript Json Converter","text":""},{"location":"tutorials/walkthrough/lab-05.html#duration-20-min","title":"Duration 20 min","text":""},{"location":"tutorials/walkthrough/lab-05.html#what-you-will-learn","title":"What you will learn","text":"<p>You will expand your basic JSON parsing skills from Lab 03b using the <code>JsonVSE</code> VoltScript Extension.  You will learn how the VS-Code VoltScript environment behaves when a run-time exception occurs, and how to correct simple typo mistakes in your source code.</p>"},{"location":"tutorials/walkthrough/lab-05.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 04 completed  </li> </ul>"},{"location":"tutorials/walkthrough/lab-05.html#steps","title":"Steps","text":""},{"location":"tutorials/walkthrough/lab-05.html#the-ide","title":"The IDE","text":"<ol> <li> <p>Create a new VS Code VoltScript Workspace folder called lab-05.</p> <ol> <li>Open Visual Studio Code.</li> <li> <p>From the Explorer view, click Open Folder.</p> <p></p> </li> <li> <p>Create a new folder in your user directory, with the name stated above.</p> </li> <li>Select the newly created folder to open in VS Code.</li> </ol> </li> </ol>"},{"location":"tutorials/walkthrough/lab-05.html#atlasjson","title":"atlas.json","text":"<ol> <li>Download the atlas.json and save it to your <code>lab-05</code> folder.  </li> <li>Modify <code>atlas.json</code> value for <code>authors</code> appropriately and save it.</li> <li>Run VoltScript Dependency Setup and create your <code>atlas-settings.json</code> file as you did in Lab 03a</li> <li>From the Command Palette, run <code>VoltScript: Install Dependencies</code>.  </li> </ol>"},{"location":"tutorials/walkthrough/lab-05.html#sample-json-data","title":"Sample JSON Data","text":"<ol> <li>Download the sample JSON data is available on customerscontacts.json and save it to the src folder.</li> </ol>"},{"location":"tutorials/walkthrough/lab-05.html#voltscript-code","title":"VOLTSCRIPT CODE","text":"<ol> <li>Download main.vss and save it to the src folder.</li> <li>Download functions.vss and save it to the src folder.</li> <li> <p>Open src/main.vss and src/functions.vss and examine the scripts.</p> </li> <li> <p>As you review these scripts, you may find the api documentation for JsonVSE and the VoltScriptJsonConverter to be useful.  </p> <ul> <li>The script starts out by calling the <code>convertJson()</code> method.  </li> <li>This method instantiates a <code>JsonParser</code> object and loads it from the <code>customerscontacts.json</code> file.  </li> <li>It then instantiates a new <code>JsonBasicObjectArrayConverter</code> and a new JsonObject array for docs.  </li> </ul> <pre><code>\n    ' Instantiate the converter \n    Set contactConverter = New JsonBasicObjectArrayConverter(|Contact|, CLASS_CONTAINER_LIBRARY)\n\n    ' instantiate the result\n    Set docs = new JsonObject(True)\n</code></pre> <ul> <li>Of special note here is the constructor arguments for the <code>JsonBasicObjectArrayConverter</code>.  The source code for this class can be found in libs/VoltScriptJsonConverter.vss.  Note that the name of the class for the conversion and the path to the library containing the class definition are passed to the constructor.  </li> <li>The script then deserializes the Customers' information from the contacts and for each spawns a new Customer object:  </li> </ul> <pre><code>\n    'Deserialize Customers\n    Call helper.withCustomConverter(|contacts|, contactConverter)\n    ForAll child in jsonObj.getChildren()\n        Set temp = child\n        Set company = helper.toObject(temp, |Company|, CLASS_CONTAINER_LIBRARY).fromJson(temp)\n        Call company.addToJsonArray(docs)\n    End ForAll\n</code></pre> <ul> <li>After adding the new Customer objects, the docs array is returned to the calling code in src/main.vss.  </li> <li>The code in src/main.vss then instantiates a new carrier JSON object (payload) and inserts the docs array as a new value (<code>documents</code>).  </li> <li>Finally the code prints out the results of the operation.  Any errors, should they occur, are also printed out.  </li> </ul> </li> <li> <p>Return focus to the main.vss file in your VS Code editor.</p> </li> <li>Press Ctrl+Shift+P (Cmd+Shift+P on Mac), then select VoltScript: Save &amp; Run Script. (You can start typing \"VoltScript\" to filter the available commands).</li> <li>Press the <code>Enter</code> key to confirm your input (no script arguments are necessary).</li> </ol> <p>Success</p> <p>You have successfully used JsonVSE to read in and process JSON content from a file.  You have additionally used VoltScriptJsonConverter to convert these JSON Objects into VoltScript objects, and then add content from these VoltScript objects back into a JSON Object Array.  </p>"},{"location":"tutorials/walkthrough/lab-05.html#review","title":"Review","text":"<p>This gives you an idea of a day in the life of a VoltScript developer. You can use VoltScript Dependency Manager to avoid having to copy and paste dependencies around. You can process JSON data using <code>JsonVSE</code>, convert JSON to / from VoltScript objects using <code>VoltScriptJsonConverter</code>, and use error information to discover and correct typos in your code.  </p> <p>In the things to explore, you can extend your familiarity with the JsonObject instance.</p> <p>The code for the lab is available on GitHub.</p>"},{"location":"tutorials/walkthrough/lab-05.html#looking-forward","title":"Looking Forward","text":"<p>In Lab 06, you will use the JSON document records to add Customer and Contact records to your database. This will provide you with populated content for use with a Volt Foundry Integration Service you will create in a later lab.  </p>"},{"location":"tutorials/walkthrough/lab-05.html#things-to-explore","title":"Things to explore","text":""},{"location":"tutorials/walkthrough/lab-05.html#examine-the-payload-jsonobject","title":"Examine the payload JsonObject","text":"<p>Modify your src/main.vss file to compare / contrast the docs and payload Json Objects</p> Revised src/main.vss file <pre><code>    Option Declare\n    Option Public\n\n    Use \"../src/functions\"\n\n    Sub Initialize() \n        Dim docs as JsonObject\n        Dim payload as JsonObject\n        Dim temp as JsonObject\n\n        Try \n            Set docs = convertJson()\n            Set payload = New JsonObject()\n            Call payload.insertValue(\"documents\", docs)\n\n            Print |Success!|\n            Print |Created | &amp; docs.childCount &amp; | JSON documents.| \n\n            ' Print the Counts\n            Print || \n            Print |Docs.ChildCount: | &amp; docs.ChildCount \n            Print |Payload.ChildCount: | &amp; payload.ChildCount\n\n            ' Print the First Child of docs \n            Print || \n            ForAll child in docs.getChildren()\n                Set temp = child\n                Print |Docs First Child: | &amp; temp.toString(True)\n                Exit Forall \n            End ForAll\n\n            ' Print the First Child of payload \n            Print || \n            ForAll child in payload.getChildren()\n                Set temp = child\n                Print |Payload First Child: | &amp; temp.toString(False)\n                Exit Forall \n            End ForAll\n\n            ' Get the documents from the payload \n            Print || \n                Set temp = payload.getChild(\"documents\")\n            Print |Temp.ChildCount: | &amp; temp.ChildCount \n\n            ' Print the First Child of payload's documents \n            Print || \n            ForAll child in temp.getChildren()\n                Set temp = child\n                Print |Payload's documents' First Child: | &amp; temp.toString(True)\n                Exit Forall \n            End ForAll \n        Catch\n            Print getErrorInfo(||) \n        End Try\n    End Sub\n</code></pre>"},{"location":"tutorials/walkthrough/lab-06.html","title":"Lab 06 - Putting it all Together","text":""},{"location":"tutorials/walkthrough/lab-06.html#duration-40-min","title":"Duration 40 min","text":""},{"location":"tutorials/walkthrough/lab-06.html#what-you-will-learn","title":"What you will learn","text":"<p>You will combine the skills you have learned in previous labs in order to generate Customers and Contacts documents in a Domino Database.</p>"},{"location":"tutorials/walkthrough/lab-06.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Lab 05 completed.</li> </ul>"},{"location":"tutorials/walkthrough/lab-06.html#steps","title":"Steps","text":""},{"location":"tutorials/walkthrough/lab-06.html#the-ide","title":"The IDE","text":"<ol> <li>Copy your VS Code VoltScript Workspace folder lab-05 to a new folder called lab-06.</li> </ol>"},{"location":"tutorials/walkthrough/lab-06.html#atlasjson","title":"atlas.json","text":"<ol> <li>Delete the <code>effective-atlas.json</code> and <code>seti.ini</code> files from your lab-06 folder.</li> <li> <p>Edit your <code>atlas.json</code> file as follows:  </p> <ul> <li>Change the name, description, and displayName properties to reflect this lab.</li> </ul> <pre><code>    \"name\": \"voltscript-intro-lab-6\",\n    \"description\": \"Lab 06 - Putting it all Together\",\n    \"displayName\": \"JsonVSE + VoltScriptJsonConverter + DrapiVSE\",\n</code></pre> <ul> <li>Add a <code>vseDependencies</code> JSON object for <code>DrapiVSE</code> after the <code>dependencies</code> array.</li> </ul> <pre><code>    \"dependencies\": [\n        {\n            \"library\": \"voltscript-json-converter\",\n            \"version\": \"latest\",\n            \"module\": \"VoltScriptJsonConverter.vss\",\n            \"repository\": \"hcl-github\"\n        }\n    ],    \n    \"vseDependencies\": {\n        \"DrapiVSE\": {\n            \"library\": \"DrapiVSE VoltScript Extension\",\n            \"version\": \"1.0.1\",\n            \"module\": \"drapivse\",\n            \"repository\": \"volt-mx-marketplace\"\n        }\n    }\n</code></pre> </li> <li> <p>Run VoltScript Dependency Setup and create your <code>atlas-settings.json</code> file as you did in Lab 03a</p> </li> <li>From the Command Palette, run <code>VoltScript: Install Dependencies</code>.  </li> </ol>"},{"location":"tutorials/walkthrough/lab-06.html#voltscript-code","title":"VOLTSCRIPT CODE","text":"<p>As you work on this code, you may find the api documentation for JsonVSE, the VoltScriptJsonConverter to be useful.</p> <ol> <li>Edit your <code>src/main.vss</code> file:  <ul> <li>If you completed Lab 05 - Things to Explore then remove those changes.</li> <li>Add a <code>UseVSE \"DrapiVSE\"</code> instruction after the options.  </li> <li>Open your main.vss file from Lab 04 - VoltScript Code and copy the constants and values for <code>DRAPI_SCOPE</code>, <code>VIEWNAME</code>, <code>DRAPI_URL</code>, <code>USER_NAME</code>, and <code>USER_PASSWORD</code>.  Paste these into your main.vss file for this lab.  </li> <li>Add variables to your <code>Initialize()</code> method for a new DrapiServer and a DrapiRequest object.</li> <li>Using your main.vss file from Lab 04 - VoltScript Code as a guide, add code to your main.vss file for this lab that will set the new DrapiServer's <code>serverUrl</code>, log into the DrapiServer using your credentials, get the <code>companiescontacts</code> scope in a DrapiRequest and list all the views.</li> <li>Create a <code>generateDrapiDocs()</code> method that has DrapiRequest and a JsonObject arguments, and returns a JsonObject containing response information.  This method should utilize method(s) from DrapiRequest to generate documents within the HCL Domino REST API database.  Consider adding <code>Try / Catch</code> logic and <code>Print</code> statments to write output to the console when running.  </li> <li>Add code to your <code>Initialize()</code> method that will call your new method, and (if successful) print out the number of documents that are created.</li> </ul> </li> <li>Test and run your main.vss file in your VS Code editor. Debug and run again as necessary until you can successfully generate the Customer and Contacts documents.  Try to get your code to work without having to use the <code>Initialize()</code> and <code>generateDrapiDocs()</code> examples.  </li> </ol> Initialize() method <pre><code>    Sub Initialize() \n        Dim server as New DrapiServer()\n        Dim request as DrapiRequest, response as DrapiResponse\n\n        Dim docs as JsonObject\n        Dim payload as JsonObject\n        Dim scopeResponse as JsonObject \n\n        Try \n            Set docs = convertJson()\n            Set payload = New JsonObject()\n            Call payload.insertValue(\"documents\", docs)\n\n            Print |Created | &amp; docs.childCount &amp; | JSON documents.| \n\n            ' Connect to the DrapiServer\n            server.serverUrl = DRAPI_URL\n            Call server.login(USER_NAME, USER_PASSWORD)\n            Print \"JWT Token: \" &amp; server.JWTToken\n\n            ' Get the named scope in a DrapiRequest \n            Set request = server.createRequest(DRAPI_SCOPE)\n\n            ' List the Views in the DrapiRequest \n            Print DRAPI_SCOPE &amp; | Views: | &amp; request.getLists() \n\n            ' Generate the DrapiDocs \n            Set response = generateDrapiDocs(request, payload)\n\n            If response.ResponseCode = 200 then \n                Print \"Documents created successfully.\"\n            End If  \n\n        Catch\n            Print getErrorInfo(||) \n        End Try\n    End Sub</code></pre> generateDrapiDocs() function <pre><code>    Function generateDrapiDocs(request as DrapiRequest, payload as JsonObject) as JsonObject \n        Dim parser as new JsonParser()\n        Dim response as String\n        Dim result as JsonObject\n\n        Try \n            Set response = request.bulkCreateDocuments(payload.toString(false)) \n            Call parser.loadFromJson(response.ContentBody)\n            Set result = parser.getRootObject()        \n        Catch \n            Print getErrorInfo(||)\n        End Try \n\n        Return result \n\n    End Function </code></pre> <p>Success</p> <p>You have successfully used JsonVSE to read in and process JSON content from a file.  You have additionally used VoltScriptJsonConverter to convert these JSON Objects into VoltScript objects, and then add content from these VoltScript objects back into a JSON Object Array. Finally, you have used this JSON object array, in conjunction with DrapiVSE to generate multiple documents in a Domino database.  </p>"},{"location":"tutorials/walkthrough/lab-06.html#review","title":"Review","text":"<p>This gives you an idea of a day in the life of a VoltScript developer. You can make use of many different VoltScript abilities such as the Dependency Management Process, VoltScript Extensions, and VoltScript Library Modules to quickly and easily accomplish fairly complicated tasks with just a little thought and a few lines of VoltScript Code.  </p> <p>In the things to explore, you can use the <code>DrapiResponse</code> object to get additional information about Customers and Contacts documents.</p> <p>The code for the lab is available on GitHub.</p>"},{"location":"tutorials/walkthrough/lab-06.html#looking-forward","title":"Looking Forward","text":"<p>In the next set of tutorials, Introduction to VoltScript for Volt Foundry, you can extend your VoltScript skills to begin working with HCL Volt MX Go.</p>"},{"location":"tutorials/walkthrough/lab-06.html#things-to-explore","title":"Things to explore","text":"<p>Try creating a new method in your <code>main.vss</code> that will return the number of Companies or Contacts, and print out that information to the console. The afformentioned API documentation should be helpful.</p> getDocumentCount() method <pre><code>    Function getDocumentCount(request as DrapiRequest, viewname As String) As Integer  \n        Dim viewentries as JsonObject\n        Dim response as DrapiResponse, entryargs as New GetListEntriesArgs\n        Dim parser as New JsonParser\n\n        Try \n            entryArgs.mode = \"default\"\n            entryArgs.RichTextAs = \"html\"\n            Set response = request.getListEntries(viewName, entryargs)\n            Call parser.loadFromJson(response.ContentBody) \n            Set viewentries = parser.getRootObject() \n\n            return viewentries.childCount \n\n        Catch \n            Print getErrorInfo(||)\n        End Try \n    End Function </code></pre> Revised Initialize() method <pre><code>    Sub Initialize()\n        Dim server as New DrapiServer()\n        Dim scope as DrapiRequest, response as DrapiResponse\n\n        Dim docs as JsonObject\n        Dim payload as JsonObject\n        Dim scopeResponse as JsonObject \n\n        Try \n            Set docs = convertJson()\n            Set payload = New JsonObject()\n            Call payload.insertValue(\"documents\", docs)\n\n            Print |Created | &amp; docs.childCount &amp; | JSON documents.| \n\n            ' Connect to the DrapiServer\n            server.serverUrl = DRAPI_URL\n            Call server.login(USER_NAME, USER_PASSWORD)\n            Print \"JWTToken: \" &amp; server.JWTToken\n\n            ' Get the named scope in a DrapiRequest \n            Set request = server.createRequest(DRAPI_SCOPE)\n\n            ' List the Views in the DrapiRequest\n            Print DRAPI_SCOPE &amp; | Views: | &amp; request.getLists() \n\n            ' Generate the DrapiDocs \n            Set scopeResponse = generateDrapiDocs(request, payload)\n\n            If Not (scopeResponse is Nothing) then \n                Print || \n                Print |Created | &amp; scopeResponse.childCount &amp; | Drapi Documents.|\n            End If  \n\n            ' Count the View Documents \n            Print |There are | &amp; getDocumentCount(request, |Companies|) &amp; | Companies.|\n            Print |There are | &amp; getDocumentCount(request, |Contacts|) &amp; | Contacts.|\n\n        Catch\n            Print getErrorInfo(||) \n        End Try\n    End Sub</code></pre>"},{"location":"whatsnew/index.html","title":"What's new","text":"<p>The section provides information on the latest features, improvements, and resolved issues related to VoltScript. For open source VoltScript Library Modules, see the relevant repository.</p> <ul> <li>Volt MX Go v10.0</li> <li>Early Access</li> </ul>"},{"location":"whatsnew/earlyaccess.html","title":"Early Access","text":"<p>The section provides information on the features, improvements, and resolved issues related to the early access version of VoltScript. For open source VoltScript Library Modules, see the relevant repository.</p> <p>Important</p> <p>Items marked in red are API changes that may impact your applications and should be reviewed before upgrading.</p> Early Access v4 Early Access v3 Early Access v2 Early Access v1"},{"location":"whatsnew/earlyaccess.html#early-access-v4","title":"Early Access v4","text":""},{"location":"whatsnew/earlyaccess.html#new","title":"New","text":""},{"location":"whatsnew/earlyaccess.html#voltscript-runtime","title":"VoltScript Runtime","text":"<ul> <li>Debugger support has been extended to include variable inspection. For more details, see debugging.</li> <li>seti.ini support for Silicon Mac has been added.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-archipelago-dependency-management","title":"VoltScript Archipelago Dependency Management","text":"<ul> <li>The current directory is provided as a default for the base project directory.</li> <li>Directory paths that begin \"~\" or \".\" are supported.</li> <li>VoltScript Logging support has been added, but is not yet enabled. This is because of directory permissions issues for the current user when writing to archipelago directories.</li> <li>Silicon Mac support has been added.</li> <li>Support for <code>runtimePlatforms</code> in atlas.json has been added. Only VSEs for the requested runtime platform(s) will be copied into the VSEs directory.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-build-management-vs-code-extension","title":"VoltScript Build Management VS Code Extension","text":"<ul> <li>Runtime platform support and validation added for atlas.json. This means dependency management will only pull in VSEs for the platforms requested.</li> <li>Minimal snippets for atlas.json and atlas-settings.json added.</li> <li>List dependencies command palette option has been added.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-extensions","title":"VoltScript Extensions","text":"<ul> <li>All VSEs have been compiled for Silicon Mac.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#hashvse","title":"HashVSE","text":"<ul> <li>Functions have been added for PKCS encryption, decryption, key file generation, and reading key files.</li> <li>CryptUtilities has bytesToText() function.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#keepvse","title":"KeepVSE","text":"<ul> <li>Added DominoVersion and DRAPIVersion properties to KeepServer.</li> <li>Added OpenSSL version info to KeepServer.LibCurlVersion.</li> <li>Added KeepDocument.Raw (get and set).</li> <li>Added KeepDocument.MetaData (get only).</li> <li>Added KeepScope.RunAgentWithContext. Note: Keep API does not currently allow context to be sent to server.</li> <li>Added KeepDocument.DeleteAttachment.</li> <li>Added KeepScope.GetListPivot().</li> <li>Added KeepScope.GetQueryResultsProcessor().</li> <li>Added KeepDocument.GetRichText().</li> <li>Added KeepServer.RTProcessors to fetch rich text processors from Keep server.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#improvements","title":"Improvements","text":""},{"location":"whatsnew/earlyaccess.html#voltscript-runtime_1","title":"VoltScript Runtime","text":"<ul> <li>GetThreadInfo(12) returns four elements instead of three. The second element is now the current class, or an empty string if the call is not made from a class</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-archipelago-dependency-management_1","title":"VoltScript Archipelago Dependency Management","text":"<ul> <li>Duplicate VSE message when writing seti.ini has been clarified.</li> <li>0-byte downloads are gracefully handled.x</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-build-management-vs-code-extension_1","title":"VoltScript Build Management VS Code Extension","text":"<ul> <li>Change default URLs for marketplace login to point to demo marketplace. The change at EA3 was incorrect.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-extensions_1","title":"VoltScript Extensions","text":"<ul> <li>The VSEVersion property has been updated to \"1.0.3\" for all VSE's except XMLVSE, which is 1.0.2.</li> <li>Calling any VSE's methods with no arguments will now raise an error instead of causing a crash.</li> <li>libcurl has been updated to 8.13.0 in CouchVSE, KeepVSE, and WebVSE.</li> <li>OpenSSL has been updated to version 3.3.4 in CouchVSE, HashVSE, KeepVSE, and WebVSE.</li> <li>Enhancements have been made to better support for UTF-16 literal strings on Linux.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#hashvse_1","title":"HashVSE","text":"<ul> <li>String handling has been improved.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#jsonvse","title":"JsonVSE","text":"<ul> <li>Fixed a crash when calling JsonObject.ValueArray on a JSON array of non-scalars.</li> <li><code>JSONObject.getArrayValues()</code> has been removed. This was previously marked deprecated. Use <code>getChildren()</code> instead.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#keepvse_1","title":"KeepVSE","text":"<ul> <li>...View... APIs have been renamed to ...List.... This is to be more consistent with Domino REST API rather than Notes classes. Affected methods are GetListCategories, GetListEntries, GetListEntriesByKey, GetListInfo, GetAllForms, and GetAllLists.</li> <li>Fixed a crash if server info was requested before logging in.</li> <li>Allowed strings and string arrays for KeepScope.GetListPivot and KeepScope.GetListEntriesByKey.</li> <li>Added RichTextAs argument to KeepScope.BulkGet and remove KeepScope.GetDocuments.</li> <li>Fixed KeepDocument.GetRichText accessing the wrong endpoint.</li> <li>Added RTItemName optional parameter to KeepDocument.GetRichText.</li> <li>Fixed KeepProfileDocument.Save crashing with empty documents.</li> <li>Fixed KeepDocument.ReplaceValue crashing on new docs.</li> <li>Fixed recursive call error with bool overload of AddURLParam.</li> <li>Updated error message handling for all methods that raise an error when an error code is returned from the Keep server. JSON responses are parsed into a readable format, HTTP error code is raised error code.</li> <li>Extended KeepScope.GetFormInfo() to support passing a mode, to get the Form info for that specific mode.</li> <li>Changed the parameter order of KeepVSE.KeepDocument.Save(). FormMode is now before ParentUNID.</li> <li>KeepDocument.Save() is now a Subroutine since it always returned True or raised an error.</li> <li>KeepDocument Get API has been changed to handle rich text differently.</li> <li>Added VerboseLogging property to WebRequest to enable debugging.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#webvse","title":"WebVSE","text":"<ul> <li>Fixed changing headers via WebRequest properties. Previous additional headers were added.</li> <li>Fixed URL encoding to avoid double-encoding '+' or '%'.</li> <li>Fixed crash when WebRequest's AddHeaders, AddCookie, FileUpload are called with empty strings.</li> <li>Fixed extra colons in createRequestWithUrl. Output URL's passed to curl in verbose logging. Encode spaces with \"%20\" instead of \"+\".</li> <li>Downloads don't create a file unless data is returned from libcurl.</li> <li>Provided curl error messages in ContentBody if no HTTP response code, update shared headers.</li> <li>Added VerboseLogging property to WebRequest to enable debugging.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#osutilsvse","title":"OSUtilsVSE","text":"<ul> <li>Support use of \"~\" for user's home directory.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#couchvse","title":"CouchVSE","text":"<ul> <li>Added VerboseLogging property to WebRequest to enable debugging.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#early-access-v3","title":"Early Access v3","text":""},{"location":"whatsnew/earlyaccess.html#new_1","title":"New","text":""},{"location":"whatsnew/earlyaccess.html#volt-foundry","title":"Volt Foundry","text":"<ul> <li>A Volt Foundry image has been added to Harbor to allow you to write and/or test VoltScript integration services and VoltScript preprocessors / postprocessors. See Tutorials for more.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#others","title":"Others","text":"<ul> <li>Documentation added regarding VoltScript in Volt Foundry.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#improvements_1","title":"Improvements","text":""},{"location":"whatsnew/earlyaccess.html#voltscript-runtime_2","title":"VoltScript Runtime","text":"<ul> <li>GetThreadInfo(13) platform names have been improved, adding options for Linux ARM and Mac.</li> </ul> <p>Note</p> <p>OSUtilsVSE has not been changed at this time and still outputs the same as EA2.</p>"},{"location":"whatsnew/earlyaccess.html#voltscript-archipelago-dependency-management_2","title":"VoltScript Archipelago Dependency Management","text":"<ul> <li>VSEs can now be referenced by name for <code>library</code> and <code>module</code>. See VSEs reference for more details.</li> <li>Improved messaging if <code>Kill</code> function fails to delete files.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-build-management-vs-code-extension_2","title":"VoltScript Build Management VS Code Extension","text":"<ul> <li>Change default URLs for marketplace login to point to main marketplace, not demo.</li> <li>Snippets and JSON validation updated for new way to reference VSE library and module.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-extensions_2","title":"VoltScript Extensions","text":"<ul> <li>The VSEVersion property has been updated to \"1.0.2\" for all VSE's.</li> <li>Calling any VSE's methods with no arguments will now raise an error instead of causing a crash.</li> <li>OpenSSL has been updated to version 3.3.1 in CouchVSE, HashVSE, KeepVSE, and WebVSE.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#hashvse_2","title":"HashVSE","text":"<ul> <li>Now statically linked on Windows, to simplify the VSE loading process.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#jsonvse_1","title":"JsonVSE","text":"<ul> <li>Added <code>JSONObject.IsDescendant()</code> and <code>JSONObject.IsDescendantPath()</code> to check if there is an object within the provided path. <code>IsDescendant()</code> takes a String Array. <code>JSONObject.IsDescendantPath()</code> takes a String and delimiter (default <code>/</code>) - use <code>\"first/second/third\"</code> to search for an object in the path <code>first</code>, <code>second</code>, <code>third</code>.</li> <li>Added <code>JSONObject.GetDescendantPath()</code> to retrieve a descendant <code>JSONObject</code> from an object using the provided path.</li> <li><code>JSONObject.hasField()</code> has been removed, use <code>isChild()</code> instead.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#keepvse_2","title":"KeepVSE","text":"<ul> <li>Added <code>KeepDocument.GetValue()</code> to retrieve a value from a document's item.</li> <li>Added <code>KeepDocument.ReplaceValue()</code> to replace a value with the given one, inserting it if it does not exist.</li> <li>Added <code>KeepScope.Evaluate()</code> to compile and execute a Notes @function formula.</li> <li>Added <code>KeepScope.GetProfileList()</code> to retrieve a profile document for a given user.</li> <li>Added <code>KeepScope.BulkGet()</code> to retrieve a bulk list of documents by UNID.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#webvse_1","title":"WebVSE","text":"<ul> <li>Added <code>WebRequest.SendAsync()</code> to make a web request in a background thread. This method returns a <code>Completion</code> object that can be checked when convenient, similar to <code>WebRequest.DownloadFileNoWait()</code>.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#xmlvse","title":"XMLVSE","text":"<ul> <li>Added <code>XMLObject.IsDescendant()</code> to check if a provided path (String Array) is a descendant of the calling object.</li> <li>Added <code>XMLObject.FindObjectByPath()</code> to find an <code>XMLObject</code> in the current object based on a provided path.</li> <li>Added <code>XMLObject.ReplaceChildObject()</code> to replace a child <code>XMLObject</code> with a new one.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#zuluvse","title":"ZuluVSE","text":"<ul> <li>Added <code>DateTimeParser.ConvertLSFormat()</code> to convert a LotusScript format date time string to the C++ style format used by ZuluVSE.</li> <li>Added <code>DateTimeObject.EpochTimeMS</code> to represent the object's epoch time in miliseconds.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#early-access-v2","title":"Early Access v2","text":""},{"location":"whatsnew/earlyaccess.html#new_2","title":"New","text":""},{"location":"whatsnew/earlyaccess.html#voltscript-runtime_3","title":"VoltScript Runtime","text":"<ul> <li>Added <code>--http-server &lt;port&gt;</code> start option for access over HTTP. For more information, see Run HTTP server.</li> <li>Added <code>--debug-server &lt;port&gt;</code> start option to run debugging listening on a specific port. Kindly note that debugging is provided as a preview. For more information, see Run from VS Code</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-language-server-vs-code-extension","title":"VoltScript Language Server VS Code Extension","text":"<ul> <li>Added support for CreateUUID function.</li> <li>Added debug server support.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#voltscript-build-management-vs-code-extension_3","title":"VoltScript Build Management VS Code Extension","text":"<ul> <li>Added Volt Foundry-related functionality to the VoltScript Build Management extension for Visual Studio code. For more information, see Use VS Code Extension Build Development Features.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#xmlvse_1","title":"XMLVSE","text":"<ul> <li>XMLVSE is a new VSE for deserializing, manipulating, and serializing XML objects. Its interface is inspired by JsonVSE, and also supports a fluent programming model. See the XMLVSE API documentation for full details.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#improvements_2","title":"Improvements","text":""},{"location":"whatsnew/earlyaccess.html#voltscript-extensions_3","title":"VoltScript Extensions","text":"<ul> <li>Compiled all VoltScript extensions for RedHat Universal Base Image 8.8 Minimal (RHEL 8), thus reducing the compiler-level for glibc version.</li> <li>Updated the atlas.json for VoltScript Collections and VoltScript JSON Converter Script Library Modules to use the relevant JsonVSE version.</li> <li>VSE's that use libcurl, such as WebVSE, KeepVSE, CouchVSE, now support the RHEL location of CA certificates in addition to the Ubuntu location. This allows a user to open a HTTPS connection to most servers without manually setting the location of the CA certificates.</li> <li>Updated libcurl to version 8.4.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#contextvse","title":"ContextVSE","text":"<ul> <li>Now supports a JSON object as the context. <code>Context.Context</code> will extract the <code>context</code> property from the root level of the object if the incoming context is a JSON string and this property is present. No changes to non-JSON context.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#couchvse_1","title":"CouchVSE","text":"<ul> <li>The version of libcurl can now be checked using the property <code>CouchServer.LibCurlVersion</code>, which is a string.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#hashvse_3","title":"HashVSE","text":"<ul> <li>The version of OpenSSL can now be checked using the property <code>HashUtilities.OpenSSLVersion</code>, which is a string.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#jsonvse_2","title":"JsonVSE","text":"<ul> <li>Constructor now takes an optional boolean parameter <code>true</code> to return a JSON array. If no parameter or <code>false</code> is passed, the constructor returns a JSON object.</li> <li>Methods for populating the JSON object are fluent, returning the current JSON object to allow calls to be chained.</li> <li>Added <code>JSONObject.HasField()</code> to provide an easy way to check if an object has a certain field. We subsequently realised this duplicated functionality available in <code>JSONObject.isChild()</code>, so the method was deprecated and was removed in EA3.</li> <li>Added <code>JsonParser.IsValidJSON()</code> to check if a provided string is a valid JSON. This can be used to sanitize incoming data before attempting to parse it.</li> <li> <p>Added <code>JSONObject.RemoveArrayEntry()</code> to enable the removal of a specific index from an array.</p> <p>Note</p> <p>You cannot use <code>JSONObject.RemoveChild()</code> to remove an entry from an array.</p> </li> <li> <p>Added <code>JSONObject.ScalarValue</code> that always returns doubles for numeric values. NOTE: This means integers will have a fractional portion (e.g. 1.0).</p> </li> </ul>"},{"location":"whatsnew/earlyaccess.html#keepvse_3","title":"KeepVSE","text":"<ul> <li>The version of libcurl can now be checked using the property <code>KeepServer.LibCurlVersion</code>, which is a string.</li> <li>Added <code>KeepProfileDocument</code> to allow the creation, update, or deletion of a profile document.</li> <li>Added <code>KeepDocument.DownloadAttachment()</code> to download and save an attachment to a local file path.</li> <li>Added optional <code>Mode</code> and <code>AllMeta</code> (short for \"all metadata\") arguments to <code>KeepScope.GetViewEntries()</code> and <code>KeepScope.GetViewEntriesByKey()</code>.</li> <li>Added <code>KeepServer.GetUserInfo()</code> to fetch information about the current user.</li> <li>Added <code>KeepScope.BulkDelete()</code> to delete multiple documents by UNID.</li> <li>Added <code>KeepScope.BulkCreate()</code> to create multiple documents based on a provided JSON string.</li> <li>Added <code>KeepScope.FolderAddDocuments()</code> and <code>KeepScope.FolderRemoveDocuments()</code> to organize documents in folders.</li> <li>Added <code>KeepScope.GetViewInfo()</code> to fetch information about a specific design view.</li> <li><code>KeepServer</code> now checks the script context for a JWT token, parsing and adding it to its requests if it is present.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#streamvse","title":"StreamVSE","text":"<ul> <li>A <code>Stream</code> can now be opened as an in-memory buffer only, without being attached to a file. Set the charset to <code>MEMORY</code> or <code>BUFFER</code> to activate this mode. This can be useful for building a long string or logging. The final string can be returned by setting <code>Stream.Position</code> to 0 and calling <code>Stream.ReadText</code>.</li> <li>Fixed reading from a pipe on standard input.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#webvse_2","title":"WebVSE","text":"<ul> <li>The version of libcurl can now be checked using the property <code>WebServer.LibCurlVersion</code>, which is a string.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#zuluvse_1","title":"ZuluVSE","text":"<ul> <li>Date/time parsing now handles fractional seconds.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#others_1","title":"Others","text":"<ul> <li>Added documentation around writing code for Volt Foundry. For more information, see Understanding VoltScript in Volt Foundry and Use with Volt Foundry.</li> </ul>"},{"location":"whatsnew/earlyaccess.html#early-access-v1","title":"Early Access v1","text":"<ul> <li>First release of the early access version of VoltScript.</li> </ul>"},{"location":"whatsnew/v10.html","title":"Volt MX Go v10.0","text":"<p>With the release of Volt MX Go v10.0, VoltScript has reached General Availability. It's now available as a custom code technology adapter for Volt Foundry Integration Service, enabling seamless back-end integrations and significantly enhancing development capabilities.</p>"}]}